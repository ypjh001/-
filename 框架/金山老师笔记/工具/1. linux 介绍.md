# [1. linux 介绍](https://jshand.gitee.io/#/course/server/linux?id=_1-linux-介绍)

inux 是一种自由和开放源码的类 UNIX 操作系统。

Linux 英文解释为 **Linux is not Unix**。

Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。

Linux 遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。

由于 Linux 是自由软件，任何人都可以创建一个符合自己需求的 Linux 发行版。

新手往往会被 Linux 众多的发行版本搞得一头雾水，我们首先来解释一下这个问题。

从技术上来说，李纳斯•托瓦兹开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。

在 Linux 内核的发展过程中，各种 Linux 发行版本起了巨大的作用，正是它们推动了 Linux 的应用，从而让更多的人开始关注 Linux。因此，把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以Linux为核心的操作系统软件包”。

Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层（由发行商整合开发的应用）才有所体现。

## [1.1 Linux的发行版](https://jshand.gitee.io/#/course/server/linux?id=_11-linux的发行版)

![img](https://jshand.gitee.io/imgs/centos/2021-05-08_154957.png)

Linux 的发行版本可以大体分为两类：

- 商业公司维护的发行版本，以著名的 Red Hat 为代表；
- 社区组织维护的发行版本，以 Debian 为代表。

很难说大量 Linux 版本中哪一款更好，每个版本都有自己的特点。下面为大家介绍几款常用的 Linux 发行版本。

### [1.Red Hat Linux](https://jshand.gitee.io/#/course/server/linux?id=_1red-hat-linux)

![img](http://c.biancheng.net/uploads/allimg/180927/2-1P92FZ955U1.jpg)

Red Hat（红帽公司）创建于 1993 年，是目前世界上资深的 Linux 厂商，也是最获认可的 Linux 品牌。

Red Hat 公司的产品主要包括 RHEL（Red Hat Enterprise Linux，收费版本）和 CentOS（RHEL 的社区克隆版本，免费版本）、Fedora Core（由 Red Hat 桌面版发展而来，免费版本）。

Red Hat 是在我国国内使用人群最多的 Linux 版本，资料丰富，如果你有什么不明白的地方，则容易找到人来请教，而且大多数 Linux 教程是以 Red Hat 为例来讲解的。

本教程以我国国内互联网公司常用的 Linux 发行版本 CentOS 为例讲解，它是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任。有实力的公司可以选择付费版本。

### [2.Ubuntu Linux](https://jshand.gitee.io/#/course/server/linux?id=_2ubuntu-linux)

![img](http://c.biancheng.net/uploads/allimg/180927/2-1P92F910131I.jpg)

Ubuntu 基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供。

Ubuntu 的创始人 Mark Shuttleworth 是非常具有传奇色彩的人物。他在大学毕业后创建了一家安全咨询公司，1999 年以 5.75 亿美元被收购，由此一跃成为南非最年轻有为的本土富翁。作为一名狂热的天文爱好者，Mark Shuttleworth 于 2002 年自费乘坐俄罗斯联盟号飞船，在国际空间站中度过了 8 天的时光。之后，Mark Shuttleworth 创立了 Ubuntu 社区，2005 年 7 月 1 日建立了 Ubuntu 基金会，并为该基金会投资 1000 万美元。他说，太空的所见正是他创立 Ubuntu 的精神之所在。如今，他最热衷的事情就是到处为自由开源的 Ubuntu 进行宣传演讲。

### [3.SuSE Linux](https://jshand.gitee.io/#/course/server/linux?id=_3suse-linux)

![img](http://c.biancheng.net/uploads/allimg/180927/2-1P92F91030358.jpg)

SuSE Linux 以 Slackware Linux 为基础，原来是德国的 SuSE Linux AG 公司发布的 Linux 版本，1994 年发行了第一版，早期只有商业版本，2004 年被 Novell 公司收购后，成立了 OpenSUSE 社区，推出了自己的社区版本 OpenSUSE。

SuSE Linux 在欧洲较为流行，在我国国内也有较多应用。值得一提的是，它吸取了 Red Hat Linux 的很多特质。

SuSE Linux 可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便。

### [4.Gentoo Linux](https://jshand.gitee.io/#/course/server/linux?id=_4gentoo-linux)

![img](http://c.biancheng.net/uploads/allimg/180927/2-1P92F9104QS.jpg)

Gentoo 最初由 Daniel Robbins（FreeBSD 的开发者之一）创建，首个稳定版本发布于 2002 年。Gentoo 是所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。

不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。自从 Gentoo 1.0 面世后，它就像一场风暴，给 Linux 世界带来了巨大的惊喜，同时也吸引了大量的用户和开发者投入 Gentoo Linux 的怀抱。

有人这样评价 Gentoo：快速、设计干净而有弹性，它的出名是因为其高度的自定制性（基于源代码的发行版）。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译。这也是为什么 Gentoo 适合比较有 Linux 使用经验的老手使用。

要注意的是，由于编译软件需要消耗大量的时间，所以，如果你所有的软件都由自己编译，并安装 KDE 桌面系统等比较大的软件包，则可能需要花费很长时间。

### [5.其他 Linux 发行版](https://jshand.gitee.io/#/course/server/linux?id=_5其他-linux-发行版)

除以上 4 种 Linux 发行版外，还有很多其他版本，表 1 罗列了几种常见的 Linux 发行版以及它们各自的特点：

| 版本名称     | 网 址                                        | 特 点                                                        | 软件包管理器                                        |
| ------------ | -------------------------------------------- | ------------------------------------------------------------ | --------------------------------------------------- |
| Debian Linux | [www.debian.org](http://www.debian.org/)     | 开放的开发模式，且易于进行软件包升级                         | apt                                                 |
| Fedora Core  | [www.redhat.com](http://www.redhat.com/)     | 拥有数量庞人的用户，优秀的社区技术支持. 并且有许多创新       | up2date（rpm），yum （rpm）                         |
| CentOS       | [www.centos.org](http://www.centos.org/)     | CentOS 是一种对 RHEL（Red Hat Enterprise Linux）源代码再编译的产物，由于 Linux 是开发源代码的操作系统，并不排斥样基于源代码的再分发，CentOS 就是将商业的 Linux 操作系统 RHEL 进行源代码再编译后分发，并在 RHEL 的基础上修正了不少已知的漏洞 | rpm                                                 |
| SUSE Linux   | [www.suse.com](http://www.suse.com/)         | 专业的操作系统，易用的 YaST 软件包管理系统                   | YaST（rpm），第三方 apt （rpm）软件库（repository） |
| Mandriva     | [www.mandriva.com](http://www.mandriva.com/) | 操作界面友好，使用图形配置工具，有庞大的社区进行技术支持，支持 NTFS 分区的大小变更 | rpm                                                 |
| KNOPPIX      | [www.knoppix.com](http://www.knoppix.com/)   | 可以直接在 CD 上运行，具有优秀的硬件检测和适配能力，可作为系统的急救盘使用 | apt                                                 |
| Gentoo Linux | [www.gentoo.org](http://www.gentoo.org/)     | 高度的可定制性，使用手册完整                                 | portage                                             |
| Ubuntu       | [www.ubuntu.com](http://www.ubuntu.com/)     | 优秀已用的桌面环境，基于 Debian 构建                         | apt                                                 |

> 关于RPM、APT、YUM

**rpm**

> RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。

**apt**:

> 适用于deb包管理式的操作系统，主要使用在ubuntu，主要解决软件包之间的依赖性问题，但是因为下载速度慢被人诟病

**YUM**

> yum是Yellow dog Updater, Modified的简称, 是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 yum，是Yellow dog Updater, Modified的简称

**下面是具体学习其中一个**

**[学习apt](https://developer.ibm.com/tutorials/l-lpic1-102-4/)**

[**学习yum和rpm**](https://developer.ibm.com/tutorials/l-lpic1-102-5/)

## [1.2 Linux 发行版本的选择](https://jshand.gitee.io/#/course/server/linux?id=_12-linux-发行版本的选择)

Linux 的发行版本众多，在此不逐一介绍，下面给选择 Linux 发行版本犯愁的朋友一点建议：

1. 如果你需要的是一个服务器系统，而且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议你选择 CentOS 或 RHEL。
2. 如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu。
3. 如果你想深入摸索一下 Linux 各个方面的知识，而且还想非常灵活地定制自己的 Linux 系统，那就选择 Gentoo 吧，尽情享受 Gentoo 带来的自由快感。
4. 如果你对系统稳定性要求很高，则可以考虑 FreeBSD。
5. 如果你需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE。

## [1.3 Linux 应用领域](https://jshand.gitee.io/#/course/server/linux?id=_13-linux-应用领域)

今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。

目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。

- 巴西联邦政府由于支持 Linux 而世界闻名。
- 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。
- 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。
- 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。
- 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。
- 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。
- 法国和德国同样开始逐步采用 Linux。

## [1.4 Linux vs Windows](https://jshand.gitee.io/#/course/server/linux?id=_14-linux-vs-windows)

目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下

| 比较     | Windows                                                      | Linux                                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 界面     | 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 | 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。 |
| 驱动程序 | 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 | 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 |
| 使用     | 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 | 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。     |
| 学习     | 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。   | 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 |
| 软件     | 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 | 大部分软件都可以自由获取，同样功能的软件选择较少。           |

## [1.5 Linux系统的优缺点](https://jshand.gitee.io/#/course/server/linux?id=_15-linux系统的优缺点)

 相比 Windows 系统，Linux 系统有更好的稳定性，那么除此之外，Linux 系统还有那些优点（或者不足）呢？

### [1.大量的可用软件及免费软件](https://jshand.gitee.io/#/course/server/linux?id=_1大量的可用软件及免费软件)

 Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义。

但不可否认的是，Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏，所以，即便打游戏、看影片用的也是 Windows，至于 Linux，就把它用在擅长的服务器领域吧。

### [2.良好的可移植性及灵活注](https://jshand.gitee.io/#/course/server/linux?id=_2良好的可移植性及灵活注)

 Linux 系统有良好的可移植性，它几乎支持所有的 CPU 平台，这使得它便于裁剪和定制。我们可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用。

如果读者希望不进行安装就体验 Linux 系统，则可以在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统。

### [3. 优良的稳定性和安全性](https://jshand.gitee.io/#/course/server/linux?id=_3-优良的稳定性和安全性)

 著名的黑客埃里克•雷蒙德（EricS.Raymond）有一句名言：“足够多的眼睛，就可让所有问题浮现”。举个例子，假如笔者在演讲，台下人山人海，明哥中午吃饭不小心，有几个饭粒粘在衣领上了，分分钟就会被大家发现，因为看的人太多了；如果台下就稀稀落落两三个人且离得很远，那就算明哥衣领上有一大块油渍也不会被发现。

Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注。

提到 Linux 的安全性，我们可以做一个实验：在一台计算机上，在安装了 Windows 系统后不安装杀毒软件联网一个月，看看会有什么情况；同样，在安装了 Linux 系统后不安装杀毒软件联网一个月，我们比较一下，大家就明白了什么是 Linux 的安全性。Windows 系统不安装杀毒软件，相信大家都知道会有什么下场吧……

### [4. 支持几乎所有的网络协议及开发语言](https://jshand.gitee.io/#/course/server/linux?id=_4-支持几乎所有的网络协议及开发语言)

经常有初学的朋友问我，Linux 是不是对 TCP/IP 协议支持不好、是不是 Java 开发环境不灵之类的问题。前面在 UNIX 发展史中已经介绍了，UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而哪一个网络协议与 TCP/IP 无关呢？所以，Linux 对网络协议和开发语言的支持很好。

Linux 的优点在此不一一列举，只说明这几点供读者参考。诚然，Linux 不可能没有缺点，如桌面应用还有待完善、Linux 的标准统一还需要推广、开源软件的盈利模式与发展还有待考验等，不过，瑕不掩瑜。

# [2 Linux的安装](https://jshand.gitee.io/#/course/server/linux?id=_2-linux的安装)

本文以Centos为例进行安装讲解。CentOS是从redhat源代码编译重新发布版。CentOS去除很多与服务器功能无关的应用，系统简单但非常稳定，命令行操作可以方便管理系统和应用，并且有帮助文档和社区的支持。一般新手入门比较好

> Centos常用连接：

- [CentOS官网](https://www.centos.org/)
- [CentOS下载](https://www.centos.org/download/)
- [CentOS常用镜像](http://isoredirect.centos.org/centos/7/isos/x86_64/)

> 虚拟机

- [Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)
- [VMware Workstation Pro](https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html)

## [2.1 安装VMware Workstation](https://jshand.gitee.io/#/course/server/linux?id=_21-安装vmware-workstation)

本文使用VMware Workstation Pro 14进行说明，下面是具体安装过程，详见截图。

## [2.2 创建虚拟机](https://jshand.gitee.io/#/course/server/linux?id=_22-创建虚拟机)

 操作如下，详见截图：

![img](https://jshand.gitee.io/imgs/centos/2021-05-06_093513.png)

![2021-05-06_093650](https://jshand.gitee.io/imgs/centos/2021-05-06_093650.png)

![2021-05-06_093835](https://jshand.gitee.io/imgs/centos/2021-05-06_093835.png)

![2021-05-06_094156](https://jshand.gitee.io/imgs/centos/2021-05-06_094156.png)

![2021-05-06_094905](https://jshand.gitee.io/imgs/centos/2021-05-06_094905.png)

![2021-05-06_095034](https://jshand.gitee.io/imgs/centos/2021-05-06_095034.png)

![2021-05-06_095451](https://jshand.gitee.io/imgs/centos/2021-05-06_095451.png)

## [2.3 安装操作系统](https://jshand.gitee.io/#/course/server/linux?id=_23-安装操作系统)

创建完虚拟机后，启动虚拟机器，后因为已经安装了虚拟光盘，会自动执行引导并进入操作系统安装程序，操作截图如下：

![img](https://jshand.gitee.io/imgs/centos/2021-05-08_151152.png)

![2021-05-08_151207](https://jshand.gitee.io/imgs/centos/2021-05-08_151207.png)

![2021-05-08_151222](https://jshand.gitee.io/imgs/centos/2021-05-08_151222.png)

![2021-05-08_151230](https://jshand.gitee.io/imgs/centos/2021-05-08_151230.png)

![2021-05-08_151307](https://jshand.gitee.io/imgs/centos/2021-05-08_151307.png)

![2021-05-08_151326](https://jshand.gitee.io/imgs/centos/2021-05-08_151326.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-23_143714.png)

![2021-05-08_151556](https://jshand.gitee.io/imgs/centos/2021-05-08_151556.png)

![2021-05-08_151646](https://jshand.gitee.io/imgs/centos/2021-05-08_151646.png)

![2021-05-08_151717](https://jshand.gitee.io/imgs/centos/2021-05-08_151717.png)

![2021-05-08_151818](https://jshand.gitee.io/imgs/centos/2021-05-08_151818.png)

![2021-05-08_151937](https://jshand.gitee.io/imgs/centos/2021-05-08_151937.png)

# [3 配置网络](https://jshand.gitee.io/#/course/server/linux?id=_3-配置网络)

## [3.1 桥接模式](https://jshand.gitee.io/#/course/server/linux?id=_31-桥接模式)

推荐使用桥接上网，此种模宿主机（Windows）和虚拟机（Linux）是可以无配置自动互相可以访问到的。此时虚拟机使用dhcp服务自动上网如果需要配置固定ip可以

## [3.2 NAT网络方式](https://jshand.gitee.io/#/course/server/linux?id=_32-nat网络方式)

使用NAT的方式，有宿主机通过VMWare的DHCP服务自动的分配IP，并且利用宿主机上网

![img](https://jshand.gitee.io/imgs/centos/2021-05-23_152915.png)

设置NAT的子网IP 和网关地址

![2021-05-23_153203](https://jshand.gitee.io/imgs/centos/2021-05-23_153203.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-23_153222.png)

## [3.3 配置网络](https://jshand.gitee.io/#/course/server/linux?id=_33-配置网络)

### [1.动态ip](https://jshand.gitee.io/#/course/server/linux?id=_1动态ip)

设置虚拟使用dhcp服务动态获取ip的方式连接网络（安装完默认即是）

桌面右键【打开终端】私用vi命令编辑网卡

```
 vi /etc/sysconfig/network-scripts/ifcfg-ens33
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no

#上网获取ip的方式 dhcp 动态获取， static
BOOTPROTO=dhcp

DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=78103a00-3711-4385-aa00-099147a15da0
DEVICE=ens33

#开启
ONBOOT=yes
```

编辑完成之后 按`ESC`输入`:wq`保存并退出

重启网卡

```bash
service  服务名 restart |start| stop
service network restart

systemctl restart network 
```

测试网络是否通畅（局域网中真机 和虚拟机之间的网络是否通畅）

在一个机器上 使用 ping 目标机器

### [2.静态ip](https://jshand.gitee.io/#/course/server/linux?id=_2静态ip)

同dhcp方式获取动态ip一样，静态ip需要修改网卡配置文件

```
 vi /etc/sysconfig/network-scripts/ifcfg-ens33
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no

#上网获取ip的方式 dhcp 动态获取， static固定，静态的
BOOTPROTO=static

#网卡ip地址，
IPADDR=192.168.1.160
#子网掩码
NETMASK=255.255.255.0
#网关
GATEWAY=192.168.1.1
#DNS服务器，可以配置多个，分别加上数字DNS1、DNS2、DNS3等
DNS1=119.29.29.29
DNS2=8.8.8.8


DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=78103a00-3711-4385-aa00-099147a15da0
DEVICE=ens33

#开启
ONBOOT=yes
```

# [4 使用客户端访问虚拟机](https://jshand.gitee.io/#/course/server/linux?id=_4-使用客户端访问虚拟机)

## [4.1 xshell 安装](https://jshand.gitee.io/#/course/server/linux?id=_41-xshell-安装)

https://www.jianshu.com/p/4716cc35750f

SecureCRT、putty

xshell 7 选择 ：School/HOME

## [4.2 新建一个连接](https://jshand.gitee.io/#/course/server/linux?id=_42-新建一个连接)

![2021-05-23_153536](https://jshand.gitee.io/imgs/centos/2021-05-23_153536.png)

![2021-05-23_153222](https://jshand.gitee.io/imgs/centos/2021-05-23_153222.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_084839.png)

在xshell 中新建一个连接

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085036.png)

 通过命令`ip addr`命令查看虚拟机的ip地址

```
[root@localhost ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:7a:37:b5 brd ff:ff:ff:ff:ff:ff
    inet 192.168.77.129/24 brd 192.168.77.255 scope global noprefixroute dynamic ens33
       valid_lft 1710sec preferred_lft 1710sec
    inet6 fe80::aa80:b507:de7d:bb2f/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default qlen 1000
    link/ether 52:54:00:86:b2:7a brd ff:ff:ff:ff:ff:ff
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
4: virbr0-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000
    link/ether 52:54:00:86:b2:7a brd ff:ff:ff:ff:ff:ff
```

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_084839.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085036.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085146.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085231.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085253.png) ![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085320.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_085525.png)

 在使用shell连接虚拟机时连接等待时长太长，ssh的服务端在连接时会自动检测dns环境是否一致导致的，修改为不检测即可。

打开sshd服务的配置文件/etc/ssh/sshd_config，把UseDNS yes,改为UseDNS no

```bash
vi /etc/ssh/sshd_config
```

编辑完成后按ESC并输入`:wq`保存并推出。重启ssh服务

> sshd_config文件

```config
#    $OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $

# This is the sshd server system-wide configuration file.  See
# sshd_config(5) for more information.

# This sshd was compiled with PATH=/usr/local/bin:/usr/bin

# The strategy used for options in the default sshd_config shipped with
# OpenSSH is to specify options with their default value where
# possible, but leave them commented.  Uncommented options override the
# default value.

# If you want to change the port on a SELinux system, you have to tell
# SELinux about this change.
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
#
#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key

# Ciphers and keying
#RekeyLimit default none

# Logging
#SyslogFacility AUTH
SyslogFacility AUTHPRIV
#LogLevel INFO

# Authentication:

#LoginGraceTime 2m
#PermitRootLogin yes
#StrictModes yes
#MaxAuthTries 6
#MaxSessions 10

#PubkeyAuthentication yes

# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
# but this is overridden so installations will only check .ssh/authorized_keys
AuthorizedKeysFile    .ssh/authorized_keys

#AuthorizedPrincipalsFile none

#AuthorizedKeysCommand none
#AuthorizedKeysCommandUser nobody

# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
#HostbasedAuthentication no
# Change to yes if you don't trust ~/.ssh/known_hosts for
# HostbasedAuthentication
#IgnoreUserKnownHosts no
# Don't read the user's ~/.rhosts and ~/.shosts files
#IgnoreRhosts yes

# To disable tunneled clear text passwords, change to no here!
#PasswordAuthentication yes
#PermitEmptyPasswords no
PasswordAuthentication yes

# Change to no to disable s/key passwords
#ChallengeResponseAuthentication yes
ChallengeResponseAuthentication no

# Kerberos options
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no
#KerberosUseKuserok yes

# GSSAPI options
GSSAPIAuthentication yes
GSSAPICleanupCredentials no
#GSSAPIStrictAcceptorCheck yes
#GSSAPIKeyExchange no
#GSSAPIEnablek5users no

# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication and
# PasswordAuthentication.  Depending on your PAM configuration,
# PAM authentication via ChallengeResponseAuthentication may bypass
# the setting of "PermitRootLogin without-password".
# If you just want the PAM account and session checks to run without
# PAM authentication, then enable this but set PasswordAuthentication
# and ChallengeResponseAuthentication to 'no'.
# WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several
# problems.
UsePAM yes

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes
#PermitTTY yes
#PrintMotd yes
#PrintLastLog yes
#TCPKeepAlive yes
#UseLogin no
#UsePrivilegeSeparation sandbox
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#ShowPatchLevel no
UseDNS no
#PidFile /var/run/sshd.pid
#MaxStartups 10:30:100
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

# no default banner path
#Banner none

# Accept locale-related environment variables
AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE
AcceptEnv XMODIFIERS

# override default of no subsystems
Subsystem    sftp    /usr/libexec/openssh/sftp-server

# Example of overriding settings on a per-user basis
#Match User anoncvs
#    X11Forwarding no
#    AllowTcpForwarding no
#    PermitTTY no
#    ForceCommand cvs server
```

切换到/et/ssh目录

```bash
cd /etc/ssh
```

执行mv命令将原来的 配置文件重命名做一个备份`mv sshd_config sshd_config.bak`

```
[root@localhost ssh]# ls
moduli  ssh_config  sshd_config  ssh_host_ecdsa_key  ssh_host_ecdsa_key.pub  ssh_host_ed25519_key  ssh_host_ed25519_key.pub  ssh_host_rsa_key  ssh_host_rsa_key.pub

[root@localhost ssh]# mv sshd_config sshd_config.bak

[root@localhost ssh]# ls
moduli  ssh_config  sshd_config.bak  ssh_host_ecdsa_key  ssh_host_ecdsa_key.pub  ssh_host_ed25519_key  ssh_host_ed25519_key.pub  ssh_host_rsa_key  ssh_host_rsa_key.pub
[root@localhost ssh]# 
```

重新创建一个空的sshd_config文件

```
touch sshd_config
[root@localhost ssh]# touch sshd_config
[root@localhost ssh]# ls
moduli  sshd_config  ssh_config  sshd_config.bak  ssh_host_ecdsa_key  ssh_host_ecdsa_key.pub  ssh_host_ed25519_key  ssh_host_ed25519_key.pub  ssh_host_rsa_key  ssh_host_rsa_key.pub
```

使用vi命令编辑 `vi sshd_config`

将上述配置文件copy到vi中，保存并推出`ESC` `:wq`

```bash
service sshd restart
或者 centos7
systemctl restart sshd.service
```

# [5. centos忘记密码怎么办？](https://jshand.gitee.io/#/course/server/linux?id=_5-centos忘记密码怎么办？)

很多时候在使用CentOS 7 的时候会因为使用多个用户名而导致忘记root密码，那么应该如何找回或者修改密码呢下面就跟大家分享下。

> 首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。如图：

![img](https://jshand.gitee.io/imgs/centos/d2001d7de137c976180f4c7044672b5fd4462b08.jpg)

> 接着，进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”，在行的最后面输入：init=/bin/sh。如图：

![img](https://jshand.gitee.io/imgs/centos/d2001d7de137c976180f4c7044672b5fd4462b08.jpg)

# [6. Linux 系统目录结构](https://jshand.gitee.io/#/course/server/linux?id=_6-linux-系统目录结构)

登录系统后，在当前命令窗口下输入命令：

```bash
 ls / 
```

![img](https://jshand.gitee.io/imgs/centos/4_20.png)

![2021-05-08_162706](https://jshand.gitee.io/imgs/centos/2021-05-08_162706.png)

> 树状目录结构：

![d0c50-linux2bfile2bsystem2bhierarchy](https://jshand.gitee.io/imgs/centos/d0c50-linux2bfile2bsystem2bhierarchy.jpg)

以下是对这些目录的解释：

- **/**：

  根目录一般不放文件，用于放置目录

- **/bin**：

  bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。

- **/boot：** 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。

- **/dev ：** dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。

- **/etc：** etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。

- **/home**： 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。

- **/lib**： lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。

- **/lost+found**： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

- **/media**： linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。

- **/mnt**： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。

- **/opt**： opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。

- **/proc**： proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：

  ```
  echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all
  ```

- **/root**： 该目录为系统管理员，也称作超级权限者的用户主目录。

- **/sbin**： s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。

- **/selinux**： 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。

- **/srv**： 该目录存放一些服务启动之后需要提取的数据。

- **/sys**：

  这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。

  sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。

  该文件系统是内核设备树的一个直观反映。

  当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。

- **/tmp**： tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。

- **/usr**： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。

- **/usr/bin：** 系统用户使用的应用程序。

- **/usr/sbin：** 超级用户使用的比较高级的管理程序和系统守护程序。

- **/usr/src：** 内核源代码默认的放置目录。

- **/var**： var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。

- **/run**： 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。

在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。

**/etc**： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。

**/bin, /sbin, /usr/bin, /usr/sbin**: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。

值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。

**/var**： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。

# [7.Linux中的Shell](https://jshand.gitee.io/#/course/server/linux?id=_7linux中的shell)

是用户和Linux内核之间的接口程序 命令解析器。它接收用户命令，然后调用相应的应用程序。 同时它又是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高阶语言中才具有的控制结构，包括循环和分支。

## [9.1 常见的三种Linux Shell](https://jshand.gitee.io/#/course/server/linux?id=_91-常见的三种linux-shell)

Sh (Bourne Shell) /bin/sh Bash(Bourne Again Shell) /bin/bash Linux 标准,最常用 Arm-Linux/Busybox 采用此风格 C Shell Korn Shell Z Shell

## [7.2 Shell提示符](https://jshand.gitee.io/#/course/server/linux?id=_72-shell提示符)

Shell提示符标识了命令行的开始。

- 普通用户以“$”作为shell提示符

- 根用户以“#”作为提示符

  username:用户名，显示当前登录用户的账户名 hostname:主机名，显示登录的主机名 directon:目录名，显示当前所处的路径，当在根目录下显示为“/”，当在用户主目录下显示为“~”；

```
[root@zhangshun bin]# 
```

## [7.3 Shell命令](https://jshand.gitee.io/#/course/server/linux?id=_73-shell命令)

两种类型命令

- Shell内部命令
- 外部应用程序命令

```bash
command [option] [arguments]
ls –l /home
```

## [7.4 shell命令补全](https://jshand.gitee.io/#/course/server/linux?id=_74-shell命令补全)

用上下方向键调阅命令历史记录；

用Tab键输入命令行自动补齐 补全命令、文件名等. 通过`history`查找历史命令

## [7.5 基本命令](https://jshand.gitee.io/#/course/server/linux?id=_75-基本命令)

大多数的linux命令都存放在系统下/bin 、 /sbin 、/usr/bin 、/usr/sbin 等几个目录下

绿色：可执行程序 浅蓝色：软连接文件 深蓝色：目录 红色：压缩文件 红底白字表示失效的符号链接

![img](https://jshand.gitee.io/imgs/centos/2021-05-24_112832.png)

## [7.4 帮助命令](https://jshand.gitee.io/#/course/server/linux?id=_74-帮助命令)

man

```
[root@zhangshun ~]# man ls
```

info
查看info手册,info是一个基于菜单的超文本系统，是由GNU项目开发并由Linux发布。

```
[root@zhangshun ~]# info ls
```

查看man手册,可以显示系统手册页中的内容，这些内容大多数都是对命令的解释信息

> 命令接此参数

```
[root@zhangshun ~]#  ls --help
```

# [9. 文件系统](https://jshand.gitee.io/#/course/server/linux?id=_9-文件系统)

在LINUX系统中有一个重要的概念：一切都是文件。 其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。这样带来优势也是显而易见的：

UNIX 权限模型也是围绕文件的概念来建立的，所以对设备也就可以同样处理了。

![img](https://jshand.gitee.io/imgs/centos/20190529154719250.png)

## [9.1文件系统架构](https://jshand.gitee.io/#/course/server/linux?id=_91文件系统架构)

1. 硬盘驱动

   常见的硬盘类型有PATA, SATA和AHCI等，在Linux系统中，对不同硬盘所提供的驱动模块一般都存放在内核目录树drivers/ata中，而对于一般通用的硬盘驱动，也许会直接被编译到内核中，而不会以模块的方式出现，可以通过查看/boot/config-xxx.xxx文件来确认：

   CONFIG_SATA_AHCI=y

2. General Block Device Layer

   这一层的作用，正是解答了上面提出的第一个问题，不同的硬盘驱动，会提供不同的IO接口，内核认为这种杂乱的接口，不利于管理，需要把这些接口抽象一下，形成一个统一的对外接口，这样，不管你是什么硬盘，什么驱动，对外而言，它们所提供的IO接口没什么区别，都一视同仁的被看作块设备来处理。

   所以，如果在一层做的任何修改，将会直接影响到所有文件系统，不管是ext3,ext4还是其它文件系统，只要在这一层次做了某种修改，对它们都会产生影响。

3. 文件系统

   文件系统这一层相信大家都再熟悉不过了，目前大多Linux发行版本默认使用的文件系统一般是ext4，另外，新一代的btrfs也呼之欲出，不管什么样的文件系统，都是由一系列的mkfs.xxx命令来创建，如：

   ```bash
   mkfs.ext4 /dev/sda
   
   mkfs.btrfs /dev/sdb
   ```

   内核所支持的文件系统类型，可以通过内核目录树 fs 目录中的内容来查看。

4. 虚拟文件系统(VFS)

   Virtual File System这一层，正是用来解决上面提出的第二个问题，试想，当我们通过mkfs.xxx系列命令创建了很多不同的文件系统，但这些文件系统都有各自的API接口，而用户想要的是，不管你是什么API，他们只关心mount/umount，或open/close等操作。

   所以，VFS就把这些不同的文件系统做一个抽象，提供统一的API访问接口，这样，用户空间就不用关心不同文件系统中不一样的API了。VFS所提供的这些统一的API，再经过System Call包装一下，用户空间就可以经过SCI的系统调用来操作不同的文件系统。

   VFS所提供的常用API有：

   - mount()， umount() …

   - open()，close() …

   - mkdir() …

     和文件系统关系最密切的就是存储介质，存储介质大致有RAM，ROM，磁盘磁带，闪存等。

   闪存（Flash Memory）是一种长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）的存储器，数据删除不是以单个的字节为单位而是以固定的区块为单位（注意：NOR Flash 为字节存储。），区块大小一般为256KB到20MB。闪存是电子可擦除只读存储器（EEPROM）的变种，EEPROM与闪存不同的是，它能在字节水平上进行删除和重写而不是整个芯片擦写，这样闪存就比EEPROM的更新速度快。由于其断电时仍能保存数据，闪存通常被用来保存设置信息，如在电脑的BIOS（基本输入输出程序）、PDA（个人数字助理）、数码相机中保存资料等。

   外存通常是磁性介质或光盘，像硬盘，软盘，磁带，CD等，能长期保存信息，并且不依赖于电来保存信息，但是由机械部件带动，速度与CPU相比就显得慢的多。内存指的就是主板上的存储部件，是CPU直接与之沟通，并用其存储数据的部件，存放当前正在使用的（即执行中）的数据和程序，它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路，内存只用于暂时存放程序和数据，一旦关闭电源或发生断电，其中的程序和数据就会丢失。

   RAM又分为动态的和静态。。静态被用作cache，动态的常用作内存。。网上说闪存不能代替DRAM是因为闪存不像RAM（随机存取存储器）一样以字节为单位改写数据，因此不能取代RAM。这个以后可以了解下硬件的知识再来辨别.

## [9.2 文件命名规则](https://jshand.gitee.io/#/course/server/linux?id=_92-文件命名规则)

(1) 除了/之外，所有字符都合法；

(2) 特殊字符如@、#、￥、&、()、-、空格等最好不要使用，当使用空格作为文件名时，执行命令会出错；

(3) 避免使用”.”作为文件名的第一个字符，因为在Linux系统中以”.”为开头的文件代表隐藏，系统将自动隐藏以”.”为开头的文件；

(4) Linux系统区分大小写，因此文件命名也区分大小写；

(5) Linux文件后缀名无意义，但是为方便识别应定义后缀(.txt、.php等)，定义后缀在大多数情况亦能将文件与目录区分；

(6) 文件位置最好设置在Linux专用目录下，如配置文件大多时候放置于/etc目录下

(7) 文件夹及文件的命名尽量聚有其特定的含义。

(8) 三个特殊目录，”.”：代表当前目录，”..”：代表上一级目录，”/”：代表根目录。 ~ 用户的家目录

## [9.3 用户的文件权限](https://jshand.gitee.io/#/course/server/linux?id=_93-用户的文件权限)

linux中对文件进行授权使分为 用户（U）、组权限(G)、其他用户权限(O) , 所有授权（A）

每个文件上都有三组权限 UGO 每一个权限使用 使用RWX进行授权，

- r 读权限 4
- w写权限 2
- x 执行权限 1
- 0 000 ---：无权限
- 1 001 --x：执行
- 2 010 -w-：写
- 3 011 -wx：写和执行
- 4 100 r--：只读
- 5 101 r-x：读和执行
- 6 110 rw-：读写
- 7 111 rwx：读写执行
- 

 使用chmod命令改变 文件的授权

```bash
#授权所有用户都能访问:
[root@zhangshun test]# chmod 777 progremm
```

去掉组内的执行权限

```
chmod g-r 
```

# [10.命令终端](https://jshand.gitee.io/#/course/server/linux?id=_10命令终端)

## [10.1 终端介绍](https://jshand.gitee.io/#/course/server/linux?id=_101-终端介绍)

早期计算机比较昂贵，不能做到每个人一台机器，为实现多人操作提供在机器上开发接口接入不同的操作设备这就是早期的终端，

![img](https://jshand.gitee.io/imgs/centos/2021-5-9_22_17_27.png)

![2021-05-08_162706](https://jshand.gitee.io/imgs/centos/2021-05-08_162706.png)

对应的是上述样式。

进入终端后显示

```
[root@localhost ~]#
```

root：表示当前登录用户

localhost: 表示当前主机,类似于

~~：表示当前所在的目录，~~有特殊含义表示当前用户的家目录

\#：表示当前用户权限，`#`代表超级用户，`$`代表普通用户

## [10.2 常用命令归类](https://jshand.gitee.io/#/course/server/linux?id=_102-常用命令归类)

> 文件系统

```
cat`、`chattr`、`chgrp`、`chmod`、`chown`、`cksum`、`cmp`、`diff`、`diffstat`、`file`、`find`、`git`、`gitview`、`indent`、`cut`、`ln`、`less`、`locate`、`isattr`、`mattrib`、`mc`、`mdel`、`mdir`、`mktemp`、`more`、`mmove`、`mread`、`mren`、`mtools`、`mtoolstest`、`mv`、`od`、`paste`、`patch`、`rcp`、`rm`、`slocate`、`split`、`tee`、`tmpwatch`、`touch`、`umask`、`which`、`cp`、`in`、`mcopy`、`mshowfat`、`rhmask`、`whereis
```

> 磁盘管理

```
cd`、`df`、`dirs`、`du`、`edquota`、`eject`、`mcd`、`mdeltree`、`mdu`、`mkdir`、`mlabel`、`mmd`、`mrd`、`mzip`、`pwd`、`quota`、`mount`、`mmount`、`rmdir`、`rmt`、`stat`、`tree`、`umount`、`ls`、`quotacheck`、`quotaoff`、`lndir`、`repquota`、`quotaon
```

> 文档处理

```
col`、`colrm`、`comm`、`csplit`、`ed`、`egrep`、`ex`、`fgrep` `fmt`、`fold`、`grep`、`ispell`、`jed`、`joe`、`join`、`look` `mtype`、`pico`、`rgrep`、`sed`、`sort`、`spell`、`tr`、`expr` `uniq`、`wc
```

> 文件传输

```
lprm`、`lpr`、`lpq`、`lpd`、`bye`、`ftp` `uuto`、`uupick`、`uucp`、`uucico`、`tftp`、`ncftp` `ftpshut`、 `ftpwho`、`ftpcount
```

> 磁盘维护

```
badblocks`、`cfdisk`、`dd`、`e2fsck`、`ext2ed` `fsck`、`swapoff`、`fsconf`、`fdformat`、`hdparm` `mformat`、`mkbootdisk`、`mkdosfs`、`mke2fs`、`mkfs.ext2` `mkfs.msdos`、`mkinitrd`、`mkisofts`、`mkswap`、`mpartition` `swapon`、`symlinks`、`sync`、`mbadblocks`、`mkfs` `fsck.ext2` 、`fdisk` 、 `losetup` 、 `mkfs` 、 `sfdisk
```

> 网络通讯

```
apachectl`、`arpwatch`、`dip`、`getty`、`mingetty`、`uux` `telnet`、`uulog`、`uustat`、`ppp-off`、`netconfig`、`nc` `httpd`、`ifconfig`、`minicom`、`mesg`、`dnsconf`、`wall` `netstat`、`ping`、`pppstats`、`samba`、`setserial`、`talk` `traceroute`、`tty`、`newaliases`、`uuname`、`netconf`、`write` `statserial`、` efax`、`pppsetup`、`tcpdump`、`ytalk`、`cu` `smbd`、`testparm`、`smbd`、`smbclient`、`shapecfg
```

> 系统管理

```
adduser`、`chfn`、`useradd`、`date`、`exit`、`finger` `fwhois`、`sleep`、`suspend`、`groupdel`、`groupmod`、`halt` `kill`、`last`、`lastb`、`login`、`logname`、`logout` `ps`、`nice`、`procinfo`、`top`、`pstree`、`reboot` `rlogin`、`rsh`、`sliplogin`、`screen`、`shutdown`、`rwho` `sudo`、`gitps`、`swatch`、`tload`、`logrotate`、`kill` `uname`、`chsh`、`userconf`、`userdel`、`usermod`、`vlock` `who`、`whoami`、`whois`、`newgrp`、`renice`、`su` `skill`、`w`、`id`、`free
```

> 系统设置

```
reset`、`clear`、`alias`、`dircolors`、`aumix`、`bind` `chroot`、`clock`、`crontab`、`declare`、`depmod`、`dmesg` `enable`、`eval`、`export`、`pwunconv`、`grpconv`、`rpm` `insmod`、`kbdconfig`、`lilo`、`liloconfig`、`lsmod`、`minfo` `set`、`modprobe`、`ntsysv`、`moouseconfig`、`passwd`、`pwconv` `rdate`、`resize`、`rmmod`、`grpunconv`、`    time` `setup`、`sndconfig`、`setenv`、`setconsole`、`timeconfig`、`ulimit` `unset`、`chkconfig`、`apmd`、`hwclock`、`mkkickstart`、`fbset` `unalias`、`SVGAText Mode
```

> 备份和压缩

```
ar`、`bunzip2`、`bzip2`、`bzip2recover`、`gunzip`、`unarj` `compress`、`cpio`、`dump`、`uuencode`、`gzexe`、`gzip` `lha`、`restore`、`tar`、`uudecode`、`unzip`、`zip` `zipinfo
```

> 设备管理

```
setleds`、`loadkeys`、`rdev`、`dumpkeys`、`MAKEDEV
```

# [11. 常用命令](https://jshand.gitee.io/#/course/server/linux?id=_11-常用命令)

## [1. cd (change directory)](https://jshand.gitee.io/#/course/server/linux?id=_1-cd-change-directory)

变换工作目录至 dirName。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home directory (也就是刚 login 时所在的目录)
范例 : 跳到 /usr/bin/ :
　　 cd /usr/bin

　　跳到自己的 home directory :
　　 cd ~

　　跳到目前目录的上上两层 :
　　 cd ../..

　　 cd - 返回进入当前目录前所在目录

## [2.pwd](https://jshand.gitee.io/#/course/server/linux?id=_2pwd)

print work directory

执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。

## [3.ls](https://jshand.gitee.io/#/course/server/linux?id=_3ls)

显示目录内容

显示指定工作目录下之内容（列出目前工作目录所含之档案及子目录)。-a 显示所有档案及目录 (ls内定将档案名或目录名称开头为"."的视为隐藏档，不会列出)
　　-l 除档案名称外，亦将档案型态、权限、拥有者、档案大小等资讯详细列出
　　-r 将档案以相反次序显示(原定依英文字母次序)
　　-t 将档案依建立时间之先后次序列出
　　-A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)
　　-F 在列出的档案名称后加一符号；例如可执行档则加 "*", 目录则加 "/"
　　-R 若目录下有档案，则以下之档案亦皆依序列出

　　范例：
　　列出目前工作目录下所有名称是 s 开头的档案，愈新的排愈后面 :
　　 ls -ltr s*

　　将 /bin 目录以下所有目录及档案详细资料列出 :
　　 ls -lR /bin

　　列出目前工作目录下所有档案及目录；目录于名称后加 "/", 可执行档于名称后加 "*" :
　　 ls -AF

## [4.mkdir](https://jshand.gitee.io/#/course/server/linux?id=_4mkdir)

Linux mkdir（英文全拼：make directory）命令用于创建目录。

> 语法

```
mkdir [-p] dirName
```

**参数说明**：

- -p 确保目录名称存在，不存在的就建一个。

> 实例

在工作目录下，建立一个名为 jshand 的子目录 :

```
mkdir jshand
```

在工作目录下的 jshand2 目录中，建立一个名为 test 的子目录。

若 jshand2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 jshand2 目录不存在，则产生错误。）

```
mkdir -p jshand2/test
```

## [5.du](https://jshand.gitee.io/#/course/server/linux?id=_5du)

Linux du （英文全拼：disk usage）命令用于显示目录或文件的大小。

du 会显示指定的目录或文件所占用的磁盘空间。

**参　　数**：

-a或-all 显示目录中个别文件的大小。
-b或-bytes 显示目录或文件大小时，以byte为单位。
-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
-D或--dereference-args 显示指定符号连接的源文件大小。
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
-k或--kilobytes 以1024 bytes为单位。
-l或--count-links 重复计算硬件连接的文件。
-L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文件大小。
-m或--megabytes 以1MB为单位。
-s或--summarize 仅显示总计。
-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。
--exclude=<目录或文件> 略过指定的目录或文件。
--max-depth=<目录层数> 超过指定层数的目录后，予以忽略。
--help 显示帮助。
--version 显示版本信息。

```bash
[root@zhangshun lstest]# du -h
4.0K    ./child
8.0K    .
```

## [6.df](https://jshand.gitee.io/#/course/server/linux?id=_6df)

Linux df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。

文件-a, --all 包含所有的具有 0 Blocks 的文件系统 文件
--block-size={SIZE} 使用 {SIZE} 大小的 Blocks 文件
-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...) 文件
-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024 文件-i,
--inodes 列出 inode 资讯，不列出已使用 block 文件
-k, --kilobytes 就像是 --block-size=1024 文件
-l, --local 限制列出的文件结构 文件
-m, --megabytes 就像 --block-size=1048576 文件--no-sync 取得资讯前不 sync (预设值) 文件
-P, --portability 使用 POSIX 输出格式 文件--sync 在取得资讯前 sync 文件
-t, --type=TYPE 限制列出文件系统的 TYPE 文件
-T, --print-type 显示文件系统的形式 文件
-x, --exclude-type=TYPE 限制列出文件系统不要显示 TYPE 文件
-v (忽略) 文件--help 显示这个帮手并且离开 文件--version 输出版本资讯并且离开

```bash
[root@zhangshun lstest]# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda1        99G  5.2G   89G   6% /
devtmpfs        1.8G     0  1.8G   0% /dev
tmpfs           1.8G     0  1.8G   0% /dev/shm
tmpfs           1.8G  728K  1.8G   1% /run
tmpfs           1.8G     0  1.8G   0% /sys/fs/cgroup
overlay          99G  5.2G   89G   6% /var/lib/docker/overlay2/54ae4c1c3f8592ecace52f21e5294a41d3bc3fd34c6acdc3c770d37478f74d3c/merged
tmpfs           365M     0  365M   0% /run/user/0
overlay          99G  5.2G   89G   6% /var/lib/docker/overlay2/e7150f4d5e21dbc793fe490d46557f470505ed9a105d2675243c0909b176ad08/merged
overlay          99G  5.2G   89G   6% /var/lib/docker/overlay2/0755e617fca6e0086f8d4d09879cf7c737e8359b408937b6116f6adc0e07f9a6/merged
```

## [7.touch](https://jshand.gitee.io/#/course/server/linux?id=_7touch)

Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。

ls -l 可以显示档案的时间记录。

```
touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]
```

- **参数说明**：
- a 改变档案的读取时间记录。
- m 改变档案的修改时间记录。
- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
- f 不使用，是为了与其他 unix 系统的相容性而保留。
- r 使用参考档的时间记录，与 --file 的效果一样。
- d 设定时间与日期，可以使用各种不同的格式。
- t 设定档案的时间记录，格式与 date 指令相同。
- --no-create 不会建立新档案。
- --help 列出指令格式。
- --version 列出版本讯息。

```
[root@zhangshun lstest]# touch myshell
[root@zhangshun lstest]# ll
total 4
drwxr-xr-x 2 root root 4096 May 24 15:01 child
-rw-r--r-- 1 root root    0 May 24 15:48 myshell
-rw-r--r-- 1 root root    0 May 24 15:02 parent.txt
[root@zhangshun lstest]# ll
total 4
drwxr-xr-x 2 root root 4096 May 24 15:01 child
-rw-r--r-- 1 root root    0 May 24 15:48 myshell
-rw-r--r-- 1 root root    0 May 24 15:02 parent.txt
[root@zhangshun lstest]# touch myshell 
[root@zhangshun lstest]# ll
total 4
drwxr-xr-x 2 root root 4096 May 24 15:01 child
-rw-r--r-- 1 root root    0 May 24 15:49 myshell
-rw-r--r-- 1 root root    0 May 24 15:02 parent.txt
[root@zhangshun lstest]# 
```

## [8.file](https://jshand.gitee.io/#/course/server/linux?id=_8file)

Linux file命令用于辨识文件类型。

通过file指令，我们得以辨识该文件的类型。

```bash
file [-bcLvz][-f <名称文件>][-m <魔法数字文件>...][文件或目录...]
```

**参数**：

- -b 　列出辨识结果时，不显示文件名称。
- -c 　详细显示指令执行过程，便于排错或分析程序执行的情形。
- -f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。
- -L 　直接显示符号连接所指向的文件的类别。
- -m<魔法数字文件> 　指定魔法数字文件。
- -v 　显示版本信息。
- -z 　尝试去解读压缩文件的内容。
- [文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。

```bash
[root@zhangshun ~]# file myshell 
myshell: UTF-8 Unicode text

[root@zhangshun ~]# file -i myshell 
myshell: text/plain; charset=utf-8

[root@zhangshun ~]# file pic.png 
pic.png: PNG image data, 442 x 307, 8-bit/color RGB, non-interlaced

[root@zhangshun ~]# file -i pic.png 
pic.png: image/png; charset=binary

[root@zhangshun ~]# file /bin/cd
/bin/cd: POSIX shell script, ASCII text executable

[root@zhangshun ~]# file -i /bin/cd
/bin/cd: text/x-shellscript; charset=us-ascii
```

## [9.cat](https://jshand.gitee.io/#/course/server/linux?id=_9cat)

cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。

```
cat [-AbeEnstTuv] [--help] [--version] fileName
```

**参数说明：**

**-n 或 --number**：由 1 开始对所有输出的行数编号。

**-b 或 --number-nonblank**：和 -n 相似，只不过对于空白行不编号。

**-s 或 --squeeze-blank**：当遇到有连续两行以上的空白行，就代换为一行的空白行。

**-v 或 --show-nonprinting**：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。

**-E 或 --show-ends** : 在每行结束处显示 $。

**-T 或 --show-tabs**: 将 TAB 字符显示为 ^I。

**-A, --show-all**：等价于 -vET。

**-e：**等价于"-vE"选项；

**-t：**等价于"-vT"选项；

```
#使用行号显示  文件内容
[root@localhost ~]# cat -n /etc/sysconfig/network-scripts/ifcfg-ens33 
     1    TYPE=Ethernet
     2    PROXY_METHOD=none
     3    BROWSER_ONLY=no
     4    
     5    
     6    BOOTPROTO=dhcp
     7    
     8    
     9    
    10    DEFROUTE=yes
    11    IPV4_FAILURE_FATAL=no
    12    IPV6INIT=yes
    13    IPV6_AUTOCONF=yes
    14    IPV6_DEFROUTE=yes
    15    IPV6_FAILURE_FATAL=no
    16    IPV6_ADDR_GEN_MODE=stable-privacy
    17    NAME=ens33
    18    UUID=78103a00-3711-4385-aa00-099147a15da0
    19    DEVICE=ens33
    20    ONBOOT=yes
# 带行号输入内容，并重定向 netinfo  一个>覆盖，>>追加
[root@localhost ~]# cat -n /etc/sysconfig/network-scripts/ifcfg-ens33  >  ~/netinfo
[root@localhost ~]# cd ~
[root@localhost ~]# ll
总用量 12
-rw-------. 1 root root 1611 5月  23 23:02 anaconda-ks.cfg
-rw-r--r--. 1 root root 1659 5月  23 23:06 initial-setup-ks.cfg
-rw-r--r--. 1 root root  425 5月  24 16:18 netinfo
drwxr-xr-x. 2 root root    6 5月  23 23:12 公共
drwxr-xr-x. 2 root root    6 5月  23 23:12 模板
drwxr-xr-x. 2 root root    6 5月  23 23:12 视频
drwxr-xr-x. 2 root root    6 5月  23 23:12 图片
drwxr-xr-x. 2 root root    6 5月  23 23:12 文档
drwxr-xr-x. 2 root root    6 5月  23 23:12 下载
drwxr-xr-x. 2 root root    6 5月  23 23:12 音乐
drwxr-xr-x. 2 root root    6 5月  23 23:12 桌面
[root@localhost ~]# cat netinfo 
     1    TYPE=Ethernet
     2    PROXY_METHOD=none
     3    BROWSER_ONLY=no
     4    
     5    
     6    BOOTPROTO=dhcp
     7    
     8    
     9    
    10    DEFROUTE=yes
    11    IPV4_FAILURE_FATAL=no
    12    IPV6INIT=yes
    13    IPV6_AUTOCONF=yes
    14    IPV6_DEFROUTE=yes
    15    IPV6_FAILURE_FATAL=no
    16    IPV6_ADDR_GEN_MODE=stable-privacy
    17    NAME=ens33
    18    UUID=78103a00-3711-4385-aa00-099147a15da0
    19    DEVICE=ens33
    20    ONBOOT=yes
```

## [10.echo](https://jshand.gitee.io/#/course/server/linux?id=_10echo)

echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：

```bash
#输出变量
[root@zhangshun ~]# echo $LANG 
en_US.UTF-8

#输出变量
[root@zhangshun ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/maven3.8/bin:/opt/jdk1.8.0_291/bin:/root/bin


[root@zhangshun ~]# echo 你好
你好
```

## [11. tail](https://jshand.gitee.io/#/course/server/linux?id=_11-tail)

tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。

tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。

```
tail [参数] [文件]  
```

**参数：**

- -f 循环读取
- -q 不显示处理信息
- -v 显示详细的处理信息
- -c<数目> 显示的字节数
- -n<行数> 显示文件的尾部 n 行内容
- --pid=PID 与-f合用,表示在进程ID,PID死掉之后结束
- -q, --quiet, --silent 从不输出给出文件名的首部
- -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒

```bash
[root@fulfill ~]# tail -f /etc/nginx/logs/fulfill.com.cn_access.log  -n 200

119.39.46.195 - - [21/May/2021:16:20:00 +0800] "GET /xy.html HTTP/1.1" 404 403 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
58.21.37.36 - - [21/May/2021:16:20:00 +0800] "GET /5.asp HTTP/1.1" 404 402 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
175.17.150.122 - - [21/May/2021:16:20:00 +0800] "GET /sec.htm HTTP/1.1" 404 403 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
119.39.46.165 - - [21/May/2021:16:20:00 +0800] "GET /wolf.asp HTTP/1.1" 404 405 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
121.57.228.218 - - [21/May/2021:16:20:00 +0800] "GET /2009624162439.cer HTTP/1.1" 404 413 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
1.30.29.10 - - [21/May/2021:16:20:00 +0800] "GET /lan.htm HTTP/1.1" 404 403 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
27.224.136.250 - - [21/May/2021:16:20:00 +0800] "GET /forkert.txt HTTP/1.1" 404 406 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
119.39.47.49 - - [21/May/2021:16:20:00 +0800] "GET /blackdos.html HTTP/1.1" 404 406 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
223.166.75.118 - - [21/May/2021:16:20:00 +0800] "GET /vip.asp HTTP/1.1" 404 403 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
36.5.158.160 - - [21/May/2021:16:20:00 +0800] "GET /icp4.asp HTTP/1.1" 404 404 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
36.106.167.115 - - [21/May/2021:16:20:00 +0800] "GET /right.asp HTTP/1.1" 404 405 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
220.200.162.212 - - [21/May/2021:16:20:00 +0800] "GET /national_v3_070.txt HTTP/1.1" 404 415 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
123.160.232.251 - - [21/May/2021:16:20:00 +0800] "GET /m_crll.htm HTTP/1.1" 404 407 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
36.57.174.139 - - [21/May/2021:16:20:00 +0800] "GET /lf.asp HTTP/1.1" 404 402 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
123.191.135.202 - - [21/May/2021:16:20:00 +0800] "GET /300.asp HTTP/1.1" 404 403 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
221.198.83.171 - - [21/May/2021:16:20:00 +0800] "GET /ty.htm HTTP/1.1" 404 402 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
```

## [12.cp](https://jshand.gitee.io/#/course/server/linux?id=_12cp)

Linux cp（英文全拼：copy file）命令主要用于复制文件或目录。

**语法**

```
cp [options] source dest
```

或

```
cp [options] source... directory
```

**参数说明**：

- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
- -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
- -f：覆盖已经存在的目标文件而不给出提示。
- -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
- -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
- -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
- -l：不复制文件，只是生成链接文件。

```bash
#创建文件
[root@localhost ~]# touch source
#向文件中写入内容
[root@localhost ~]# echo 原始文件 >> source 

#查看目录中是否存在文件
[root@localhost ~]# ls
anaconda-ks.cfg  initial-setup-ks.cfg  netinfo  source  公共  模板  视频  图片  文档  下载  音乐  桌面

#查看文件
[root@localhost ~]# cat source 
原始文件

#复制到另外一个文件夹
[root@localhost ~]# cp source  /usr

#查看复制后的目录中是否存在
[root@localhost ~]# ls /usr
bin  etc  games  include  lib  lib64  libexec  local  sbin  share  source  src  tmp

#查看原始文件 还在
[root@localhost ~]# ls
anaconda-ks.cfg  initial-setup-ks.cfg  netinfo  source  公共  模板  视频  图片  文档  下载  音乐  桌面

#当前目录复制文件
[root@localhost ~]# cp source source.bak
#查看复制后的文件是否存在
[root@localhost ~]# ls
anaconda-ks.cfg  initial-setup-ks.cfg  netinfo  source  source.bak  公共  模板  视频  图片  文档  下载  音乐  桌面

#重复的文件会有覆盖与否的提示
[root@localhost ~]# cp source source.bak
cp：是否覆盖"source.bak"？ y

#复制目录时会有提示，
[root@zhangshun ~]# cp docker/ ./aaa
cp: omitting directory ‘docker/’

#通过ls查看复制没有成功 
[root@zhangshun ~]# ls
a.txt  bbbbtxt   class.info  docszs       

#通过添加-r命令 递归的复制文件夹及子目录和目录中的文件
[root@zhangshun ~]# cp -r  docker/ ./aaa
[root@zhangshun ~]# ll
total 112
drwxr-xr-x 4 root root  4096 May 24 18:08 aaa
```

## [13.mv](https://jshand.gitee.io/#/course/server/linux?id=_13mv)

Linux mv（英文全拼：move file）命令用来为文件或目录改名、或将文件或目录移入其它位置。

```bash
mv [options] source dest
mv [options] source... directory
```

**参数说明**：

- **-b**: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。
- **-i**: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。
- **-f**: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。
- **-n**: 不要覆盖任何已存在的文件或目录。
- **-u**：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。

**实例**

将文件 aaa 改名为 bbb :

```
mv aaa bbb
```

将 info 目录放入 logs 目录中。注意，如果 logs 目录不存在，则该命令将 info 改名为 logs。

```
mv info/ logs 
```

再如将 **/usr/jshand** 下的所有文件和目录移到当前目录下，命令行为：

```
$ mv /usr/jshand/*  . 
```

## [14.rm](https://jshand.gitee.io/#/course/server/linux?id=_14rm)

Linux rm（英文全拼：remove）命令用于删除一个文件或者目录。

```
rm [options] name...
```

**参数**：

- -i 删除前逐一询问确认。
- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
- -r 将目录及以下之档案亦逐一删除。

```bash
#删除文件有提示  rm= rm -i
[root@zhangshun ~]# rm a.txt
rm: remove regular empty file ‘a.txt’? y
[root@zhangshun ~]# ls
aaa    bbbbtxt   class.info  docker  ifs-engineering  info.txt  kill-boot.sh  myshell   nohup.log  pusite.sh  springBootLog.log  test
A.txt  build.sh  destdir     docszs  info             inof      lstest        mysql.sh  pic.png    run.sh     start.sh


#删除文件 不需要确认 与 -i相反
[root@zhangshun ~]# rm -f info.txt 
[root@zhangshun ~]# ls
aaa      build.sh    destdir  docszs           inof          lstest   mysql.sh   pic.png    run.sh             start.sh
bbbbtxt  class.info  docker   ifs-engineering  kill-boot.sh  myshell  nohup.log  pusite.sh  springBootLog.log  test



#无参数删除目录 会有错误提示
[root@zhangshun ~]# rm test
rm: cannot remove ‘test’: Is a directory

#使用-r 参数删除目录
[root@zhangshun ~]# rm -r test/
rm: descend into directory ‘test/’? y
rm: remove regular empty file ‘test/progremm’? y
rm: remove directory ‘test/’? y


#使用-rf命令删除目录并且不需要提示
[root@zhangshun ~]# rm -rf aaa
[root@zhangshun ~]# ls
build.sh  destdir  docker  docszs  ifs-engineering  kill-boot.sh  lstest  mysql.sh  pic.png  pusite.sh  run.sh  springBootLog.log  start.sh


#创建文件夹
[root@zhangshun ~]# mkdir mydir
[root@zhangshun ~]# cd mydir/

#在文件夹中创建3个文件
[root@zhangshun mydir]# touch f1 f2 f3
[root@zhangshun mydir]# ls
f1  f2  f3

#慎重 删除当前目录的文件及子目录
[root@zhangshun mydir]# rm -rf *
[root@zhangshun mydir]# ll
total 0
```

## [15.tac](https://jshand.gitee.io/#/course/server/linux?id=_15tac)

从最后一行开始显示文件

与cat刚好相反，从最后一行开始显示

## [16 more/less](https://jshand.gitee.io/#/course/server/linux?id=_16-moreless)

NAME more — 在显示器上阅读文件的过滤器

总览 (SYNOPSIS) more [-dlfpcsu] [-num] [+/ pattern] [+ linenum] [file ...]

描述 (DESCRIPTION) More 是 一个 过滤器, 用于 分页 显示 (一次一屏) 文本. 这个 版本 非常 基本. 用户 应该 知道 less(1) 提供了 more(1) 的 模拟, 并且 做了 增强.

选项 (OPTION) 下面 介绍 命令行选项. 选项 可以 从 环境变量 MORE 中获取 (要 确保 它们 以 短横线 开头 (``-'')), 但是 命令行选项 能够 覆盖 它们.

```
 -num  这个选项指定屏幕的行数 (以整数表示).

 -d    让 more 给 用户 显示 提示信息 "[Press space to continue, 'q' to quit.]", 当 用户 按下 其他键 时, 显示 "[Press 'h' for instructions.]", 而不是
       扬声器 鸣笛.

 -l    More 在 通常情况下 把 ^L (form feed) 当做 特殊字符, 遇到 这个字符 就会 暂停.  -l 选项 可以 阻止 这种特性.

 -f    使 more 计数 逻辑行, 而不是 屏幕行 (就是说, 长行 不会 断到 下一行).

 -p    不卷屏, 而是 清除 整个屏幕, 然后 显示 文本.

 -c    不卷屏, 而是 从 每一屏的 顶部 开始 显示 文本, 每 显示完 一行, 就 清除 这一行的 剩余部分.

 -s    把 重复的空行 压缩成 一个 空行.

 -u    防止下划线.

 +/    在 显示 每个文件 前, 搜索 +/ 选项 指定的 文本串.
```

less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。

**参数说明**：

- -b <缓冲区大小> 设置缓冲区的大小
- -e 当文件显示结束后，自动离开
- -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
- -g 只标志最后搜索的关键词
- -i 忽略搜索时的大小写
- -m 显示类似more命令的百分比
- -N 显示每行的行号
- -o <文件名> 将less 输出的内容在指定文件中保存起来
- -Q 不使用警告音
- -s 显示连续空行为一行
- -S 行过长时间将超出部分舍弃
- -x <数字> 将"tab"键显示为规定的数字空格
- /字符串：向下搜索"字符串"的功能
- ?字符串：向上搜索"字符串"的功能
- n：重复前一个搜索（与 / 或 ? 有关）
- N：反向重复前一个搜索（与 / 或 ? 有关）
- b 向上翻一页
- d 向后翻半页
- h 显示帮助界面
- Q 退出less 命令
- u 向前滚动半页
- y 向前滚动一行
- 空格键 滚动一页
- 回车键 滚动一行
- [pagedown]： 向下翻动一页
- [pageup]： 向上翻动一页

## [17.nl](https://jshand.gitee.io/#/course/server/linux?id=_17nl)

显示时同时输出行号

NAME nl - number lines of files

SYNOPSIS nl [OPTION]... [FILE]...

DESCRIPTION Write each FILE to standard output, with line numbers added. With no FILE, or when FILE is -, read standard input.

```
   Mandatory arguments to long options are mandatory for short options too.

   -b, --body-numbering=STYLE
          use STYLE for numbering body lines

   -d, --section-delimiter=CC
          use CC for separating logical pages

   -f, --footer-numbering=STYLE
          use STYLE for numbering footer lines

   -h, --header-numbering=STYLE
          use STYLE for numbering header lines

   -i, --line-increment=NUMBER
          line number increment at each line

   -l, --join-blank-lines=NUMBER
          group of NUMBER empty lines counted as one

   -n, --number-format=FORMAT
          insert line numbers according to FORMAT
```

## [18. ln](https://jshand.gitee.io/#/course/server/linux?id=_18-ln)

Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。

当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

其中参数的格式为

[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]

[--help] [--version] [--]

**命令功能** : Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。

不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。

**软链接**：

- 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
- 2.软链接可以 跨文件系统 ，硬链接不可以
- 3.软链接可以对一个不存在的文件名进行链接
- 4.软链接可以对目录进行链接

**硬链接**：

- 1.硬链接，以文件副本的形式存在。但不占用实际空间。
- 2.不允许给目录创建硬链接
- 3.硬链接只有在同一个文件系统中才能创建

#### [命令参数](https://jshand.gitee.io/#/course/server/linux?id=命令参数)

**必要参数**：

- -b 删除，覆盖以前建立的链接
- -d 允许超级用户制作目录的硬链接
- -f 强制执行
- -i 交互模式，文件存在则提示用户是否覆盖
- -n 把符号链接视为一般目录
- -s 软链接(符号链接)
- -v 显示详细的处理过程

**选择参数**：

- -S "-S<字尾备份字符串> "或 "--suffix=<字尾备份字符串>"
- -V "-V<备份方式>"或"--version-control=<备份方式>"
- --help 显示帮助信息
- --version 显示版本信息

**示例**

1. 准备一个脚本文件 touch run.sh

2. 编辑脚本文件

   ```
   #!/bin/bash
   
   date
   ```

3. 给脚本添加执行权限

   ```
   chmod u +x run.sh
   ```

4. 执行脚本

   ```
   [root@localhost ~]# ./run.sh 
   2021年 05月 25日 星期二 09:33:48 CST
   ```

1. 在 /usr/local/bin创建一个连接,并且测试连接文件是否可以执行

   ```bash
   root@localhost ~]# ln run.sh /usr/local/bin/myrun.sh
   [root@localhost ~]# ls /usr/local/bin/
   myrun.sh
   [root@localhost ~]# ./usr/local/bin/myrun.sh
   -bash: ./usr/local/bin/myrun.sh: 没有那个文件或目录
   [root@localhost ~]# sh /usr/local/bin/myrun.sh 
   2021年 05月 25日 星期二 09:35:58 CST
   ```

6.创建软连接

```bash
#创建符号连接 -s 此时没有使用绝对路径
[root@localhost ~]# ln -s run.sh  /usr/local/bin/run.sh

[root@localhost ~]# ls /usr/local/bin/
myrun.sh  run.sh

#运行文件有提示
[root@localhost ~]# sh /usr/local/bin/run.sh 
sh: /usr/local/bin/run.sh: 符号连接的层数过多


[root@localhost ~]# cd /usr/local/bin/
[root@localhost bin]# ls
myrun.sh  run.sh
#删除已经创建好的 符号连接
[root@localhost bin]# rm -f run.sh 
[root@localhost bin]# ls
myrun.sh



#重新创建 /root/run.sh
[root@localhost ~]# ln -s /root/run.sh  /usr/local/bin/run.sh
[root@localhost ~]# sh /usr/local/bin/run.sh 
2021年 05月 25日 星期二 09:49:25 CST
```

当删除原始文件的时候 硬链接依然可以正常执行，符号连接生效。

## [19.find](https://jshand.gitee.io/#/course/server/linux?id=_19find)

Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

**语法**

```
find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;
```

**参数说明** :

find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。

expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。

-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件

-amin n : 在过去 n 分钟内被读取过

-anewer file : 比文件 file 更晚被读取过的文件

-atime n : 在过去n天内被读取过的文件

-cmin n : 在过去 n 分钟内被修改过

-cnewer file :比文件 file 更新的文件

-ctime n : 在过去n天内被修改过的文件

-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name

-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写

-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写

-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。

-type c : 文件类型是 c 的文件。

d: 目录

c: 字型装置文件

b: 区块装置文件

p: 具名贮列

f: 一般文件

l: 符号连结

s: socket

-pid n : process id 是 n 的文件

你可以使用 ( ) 将运算式分隔，并使用下列运算。

exp1 -and exp2

! expr

-not expr

exp1 -or exp2

exp1, exp2

```bash
[root@localhost ~]#find / -name "ssh"

[root@localhost ~]#find /etc -maxdepth 0  -name "ssh"

[root@localhost ~]#find /etc -maxdepth 5  -name "ssh"
```

## [20.which](https://jshand.gitee.io/#/course/server/linux?id=_20which)

Linux which命令用于查找文件。

which指令会在环境变量$PATH设置的目录里查找符合条件的文件。

**参数**：

- -n<文件名长度> 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
- -p<文件名长度> 　与-n参数相同，但此处的<文件名长度>包括了文件的路径。
- -w 　指定输出时栏位的宽度。
- -V 　显示版本信息。

## [21.whereis](https://jshand.gitee.io/#/course/server/linux?id=_21whereis)

Linux whereis命令用于查找文件。

该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。

该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。

**参数**：

-b 　只查找二进制文件。

-B<目录> 　只在设置的目录下查找二进制文件。

-f 　不显示文件名前的路径名称。

-m 　只查找说明文件。

-M<目录> 　只在设置的目录下查找说明文件。

-s 　只查找原始代码文件。

-S<目录> 　只在设置的目录下查找原始代码文件。

-u 　查找不包含指定类型的文件。

```bash
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

[root@localhost ~]# whereis cd
cd: /usr/bin/cd /usr/share/man/man1/cd.1.gz /usr/share/man/man1p/cd.1p.gz

[root@localhost ~]# man cd

[root@localhost ~]# which cd
/usr/bin/cd
```

# [12 进程操作相关命令](https://jshand.gitee.io/#/course/server/linux?id=_12-进程操作相关命令)

- ps 显示当前系统中由该用户运行的进程列表
- kill 输出特定的信号给指定的进程，并根据该信号而完成指定的行为
- top 动态显示当前系统中由该用户运行的进程列表
- renice 修改一个正在运行的进程的优先级
- pstree 列出当前的进程，以及它们的树状结构

## [12.1 ps](https://jshand.gitee.io/#/course/server/linux?id=_121-ps)

Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。

**参数**：

- ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义

- -A 列出所有的进程

- -w 显示加宽可以显示较多的资讯

- -au 显示较详细的资讯

- -aux 显示所有包含其他使用者的行程

- au(x) 输出格式 :

  ```
  USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
  ```

  - USER: 行程拥有者
  - PID: pid
  - %CPU: 占用的 CPU 使用率
  - %MEM: 占用的记忆体使用率
  - VSZ: 占用的虚拟记忆体大小
  - RSS: 占用的记忆体大小
  - TTY: 终端的次要装置号码 (minor device number of tty)
  - STAT: 该行程的状态:
    - D: 无法中断的休眠状态 (通常 IO 的进程)
    - R: 正在执行中
    - S: 静止状态
    - T: 暂停执行
    - Z: 不存在但暂时无法消除
    - W: 没有足够的记忆体分页可分配
    - <: 高优先序的行程
    - N: 低优先序的行程
    - L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
  - START: 行程开始时间
  - TIME: 执行的时间
  - COMMAND:所执行的指令

```bash
[root@localhost ~]# ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 08:39 ?        00:00:12 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root          2      0  0 08:39 ?        00:00:00 [kthreadd]
root          4      2  0 08:39 ?        00:00:00 [kworker/0:0H]
root          6      2  0 08:39 ?        00:00:01 [ksoftirqd/0]
root          7      2  0 08:39 ?        00:00:04 [migration/0
```

BSD语法

```bash
[root@localhost ~]# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.1  0.1 194904  8000 ?        Ss   08:39   0:12 /usr/lib/systemd/systemd --switched-root --system --deserialize 2
root          2  0.0  0.0      0     0 ?        S    08:39   0:00 [kthreadd]
root          4  0.0  0.0      0     0 ?        S<   08:39   0:00 [kworker/0:0H]
root          6  0.0  0.0      0     0 ?        S    08:39   0:01 [ksoftirqd/0]
root          7  0.0  0.0      0     0 ?        S    08:39   0:04 [migration/0]
root          8  0.0  0.0      0     0 ?        S    08:39   0:00 [rcu_bh]
```

## [12.2 grep](https://jshand.gitee.io/#/course/server/linux?id=_122-grep)

过滤文本，定位文本的

```
[root@localhost ~]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
polkitd:x:999:998:User for polkitd:/:/sbin/nologin
libstoragemgmt:x:998:995:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin
colord:x:997:994:User for colord:/var/lib/colord:/sbin/nologin
rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
saned:x:996:993:SANE scanner daemon user:/usr/share/sane:/sbin/nologin
gluster:x:995:992:GlusterFS daemons:/run/gluster:/sbin/nologin
saslauth:x:994:76:Saslauthd user:/run/saslauthd:/sbin/nologin
abrt:x:173:173::/etc/abrt:/sbin/nologin
setroubleshoot:x:993:990::/var/lib/setroubleshoot:/sbin/nologin
rtkit:x:172:172:RealtimeKit:/proc:/sbin/nologin
pulse:x:171:171:PulseAudio System Daemon:/var/run/pulse:/sbin/nologin
radvd:x:75:75:radvd user:/:/sbin/nologin
chrony:x:992:987::/var/lib/chrony:/sbin/nologin
unbound:x:991:986:Unbound DNS resolver:/etc/unbound:/sbin/nologin
qemu:x:107:107:qemu user:/:/sbin/nologin
tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin
sssd:x:990:984:User for sssd:/:/sbin/nologin
usbmuxd:x:113:113:usbmuxd user:/:/sbin/nologin
geoclue:x:989:983:User for geoclue:/var/lib/geoclue:/sbin/nologin
ntp:x:38:38::/etc/ntp:/sbin/nologin
gdm:x:42:42::/var/lib/gdm:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologin
gnome-initial-setup:x:988:982::/run/gnome-initial-setup/:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
jshand:x:1000:1000:jshand:/home/jshand:/bin/bash



#通过grep命令 定位
[root@localhost ~]# cat /etc/passwd | grep jshand
jshand:x:1000:1000:jshand:/home/jshand:/bin/bash



[root@localhost ~]# ps -ef|grep ssh
root       1243      1  0 08:40 ?        00:00:00 /usr/sbin/sshd -D
root       4737   4522  0 08:41 ?        00:00:00 /usr/bin/ssh-agent /bin/sh -c exec -l /bin/bash -c "env GNOME_SHELL_SESSION_MODE=classic gnome-session --session gnome-classic"
root       9866   1243  0 10:57 ?        00:00:00 sshd: root@pts/0
root      10640   9871  0 11:07 pts/0    00:00:00 grep --color=auto ssh
```

## [12.3 top /free](https://jshand.gitee.io/#/course/server/linux?id=_123-top-free)

```
[root@localhost ~]# top
top - 11:09:12 up  2:29,  2 users,  load average: 0.06, 0.04, 0.05
Tasks: 228 total,   1 running, 227 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  7828268 total,  5947240 free,  1065584 used,   815444 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  6664768 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                      
  4789 root      20   0 3694564 189188  65836 S   1.0  2.4   0:39.76 gnome-shell                                                  
   748 rtkit     21   1  198784   1772   1408 S   0.3  0.0   0:00.34 rtkit-daemon                                                 
   751 root      20   0  295564   5304   4056 S   0.3  0.1   0:32.01 vmtoolsd                                                     
  5048 root      20   0  608644  25484  18816 S   0.3  0.3   0:24.01 vmtoolsd                                                     
 10681 root      20   0  162100   2364   1580 R   0.3  0.0   0:00.23 top                                                          
     1 root      20   0  194904   8000   4232 S   0.0  0.1   0:12.82 systemd                                                      
     2 root      20   0       0      0      0 S   0.0  0.0   0:00.15 kthreadd                                                     
     4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                 
     6 root      20   0       0      0      0 S   0.0  0.0   0:01.04 ksoftirqd/0                                                  
     7 root      rt   0       0      0      0 S   0.0  0.0   0:04.99 migration/0                                                  
     8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh                                                       
     9 root      20   0       0      0      0 S   0.0  0.0   0:04.65 rcu_sched                                                    
    10 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 lru-add-drain                                                
    11 root      rt   0       0      0      0 S   0.0  0.0   0:00.37 watchdog/0                                                   
    12 root      rt   0       0      0      0 S   0.0  0.0   0:00.10 watchdog/1                                                   
    13 root      rt   0       0      0      0 S   0.0  0.0   0:04.90 migration/1                                                  
    14 root      20   0       0      0      0 S   0.0  0.0   0:01.54 ksoftirqd/1     
free  -m
```

## [12.4 pstree](https://jshand.gitee.io/#/course/server/linux?id=_124-pstree)

```bash
[root@localhost ~]# pstree
systemd─┬─ModemManager───2*[{ModemManager}]
        ├─NetworkManager─┬─dhclient
        │                └─2*[{NetworkManager}]
        ├─VGAuthService
        ├─2*[abrt-watch-log]
        ├─abrtd
        ├─accounts-daemon───2*[{accounts-daemon}]
        ├─alsactl
        ├─at-spi-bus-laun─┬─dbus-daemon───{dbus-daemon}
        │                 └─3*[{at-spi-bus-laun}]
        ├─at-spi2-registr───2*[{at-spi2-registr}]
        ├─atd
        ├─auditd─┬─audispd─┬─sedispatch
```

## [12.5 kill](https://jshand.gitee.io/#/course/server/linux?id=_125-kill)

Linux kill 命令用于删除执行中的程序或工作。

kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看。

**参数说明**：

- -l <信息编号> 　若不加<信息编号>选项，则 -l 参数会列出全部的信息名称。
- -s <信息名称或编号> 　指定要送出的信息。
- [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。

使用 kill -l 命令列出所有可用信号。

最常用的信号是：

- 1 (HUP)：重新加载进程。
- 9 (KILL)：杀死一个进程。
- 15 (TERM)：正常停止一个进程。

**示例**创建一个运行脚本，能一直执行内容如下

> \#!/bin/bash
>
> ping [www.baidu.com](http://www.baidu.com/)

```bash
#创建文件
[root@zhangshun ~]# touch pingtest 

#编辑测试脚本
[root@zhangshun ~]# vi pingtest 

#添加执行权限
[root@zhangshun ~]# chmod a+x pingtest 

#执行脚本
[root@zhangshun ~]# ./pingtest 
PING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=4 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=5 ttl=52 time=6.72 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=6 ttl=52 time=6.76 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=7 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=8 ttl=52 time=6.72 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=9 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=10 ttl=52 time=6.75 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=11 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=12 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=13 ttl=52 time=6.72 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=14 ttl=52 time=6.75 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=15 ttl=52 time=6.75 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=16 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=17 ttl=52 time=6.76 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=18 ttl=52 time=6.75 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=19 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=20 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=21 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=22 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=23 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=24 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=25 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=26 ttl=52 time=6.72 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=27 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=28 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=29 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=30 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=31 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=32 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=33 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=34 ttl=52 time=6.73 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=35 ttl=52 time=6.71 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=36 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=37 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=38 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=39 ttl=52 time=6.74 ms
64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=40 ttl=52 time=6.71 ms
./pingtest: line 3:  6276 Killed                  ping www.baidu.com
```

在ping任务执行的过程中，另外再打开一个窗口执行

```
[root@zhangshun ~]# ps -ef|grep ping 
root      6311  6253  0 11:32 pts/0    00:00:00 /bin/bash ./pingtest
root      6312  6311  0 11:32 pts/0    00:00:00 ping www.baidu.com
root      6333  6315  0 11:32 pts/1    00:00:00 grep --color=auto ping
[root@zhangshun ~]# kill -9 6312
```

最终效果是进程被杀死

![img](https://jshand.gitee.io/imgs/centos/2021-05-25_113345.png)

# [13.打包、压缩](https://jshand.gitee.io/#/course/server/linux?id=_13打包、压缩)

## [13.1 tar](https://jshand.gitee.io/#/course/server/linux?id=_131-tar)

Linux tar（英文全拼：tape archive ）命令用于备份文件。

tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

**常用参数**

> -c或--create 建立新的备份文件。
>
> -z ：使用gzip格式压缩。(tar.gz、tgz.)
>
> -j ：使用bzip2格式压缩（bz2，bzip2）
>
> -x ：解包或者解压缩
>
> -t ：查看包内文件
>
> -c ：建立一个压缩包或者tar包
>
> -v ：可视化显示过程
>
> -f ：后面跟文件名，（filename）
>
> -g ：建立新 GNU 格式的备份（建立一个快照文件）
>
> –exclude ：压缩时排除文件
>
> -C ：指定一个解压缩的位置
>
> -p ：保留原文件属性

**全量参数**：

-A或--catenate 新增文件到已存在的备份文件。 -b<区块数目>或--blocking-factor=<区块数目> 设置每笔记录的区块数目，每个区块大小为12Bytes。 -B或--read-full-records 读取数据时重设区块大小。 -c或--create 建立新的备份文件。 -C<目的目录>或--directory=<目的目录> 切换到指定的目录。 -d或--diff或--compare 对比备份文件内和文件系统上的文件的差异。 -f<备份文件>或--file=<备份文件> 指定备份文件。 -F<Script文件>或--info-script=<Script文件> 每次更换磁带时，就执行指定的Script文件。 -g或--listed-incremental 处理GNU格式的大量备份。 -G或--incremental 处理旧的GNU格式的大量备份。 -h或--dereference 不建立符号连接，直接复制该连接所指向的原始文件。 -i或--ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。 -k或--keep-old-files 解开备份文件时，不覆盖已有的文件。 -K<文件>或--starting-file=<文件> 从指定的文件开始还原。 -l或--one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。 -L<媒体容量>或-tape-length=<媒体容量> 设置存放每体的容量，单位以1024 Bytes计算。 -m或--modification-time 还原文件时，不变更文件的更改时间。 -M或--multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。 -N<日期格式>或--newer=<日期时间> 只将较指定日期更新的文件保存到备份文件里。 -o或--old-archive或--portability 将资料写入备份文件时使用V7格式。 -O或--stdout 把从备份文件里还原的文件输出到标准输出设备。 -p或--same-permissions 用原来的文件权限还原文件。 -P或--absolute-names 文件名使用绝对名称，不移除文件名称前的"/"号。 -r或--append 新增文件到已存在的备份文件的结尾部分。 -R或--block-number 列出每个信息在备份文件中的区块编号。 -s或--same-order 还原文件的顺序和备份文件内的存放顺序相同。 -S或--sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。 -t或--list 列出备份文件的内容。 -T<范本文件>或--files-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。 -u或--update 仅置换较备份文件内的文件更新的文件。 -U或--unlink-first 解开压缩文件还原文件之前，先解除文件的连接。 -v或--verbose 显示指令执行过程。 -V<卷册名称>或--label=<卷册名称> 建立使用指定的卷册名称的备份文件。 -w或--interactive 遭遇问题时先询问用户。 -W或--verify 写入备份文件后，确认文件正确无误。 -x或--extract或--get 从备份文件中还原文件。 -X<范本文件>或--exclude-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。 -z或--gzip或--ungzip 通过gzip指令处理备份文件。 -Z或--compress或--uncompress 通过compress指令处理备份文件。 -<设备编号><存储密度> 设置备份用的外围设备编号及存放数据的密度。 --after-date=<日期时间> 此参数的效果和指定"-N"参数相同。 --atime-preserve 不变更文件的存取时间。 --backup=<备份方式>或--backup 移除文件前先进行备份。 --checkpoint 读取备份文件时列出目录名称。 --concatenate 此参数的效果和指定"-A"参数相同。 --confirmation 此参数的效果和指定"-w"参数相同。 --delete 从备份文件中删除指定的文件。 --exclude=<范本样式> 排除符合范本样式的文件。 --group=<群组名称> 把加入设备文件中的文件的所属群组设成指定的群组。 --help 在线帮助。 --ignore-failed-read 忽略数据读取错误，不中断程序的执行。 --new-volume-script=<Script文件> 此参数的效果和指定"-F"参数相同。 --newer-mtime 只保存更改过的文件。 --no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。 --null 从null设备读取文件名称。 --numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。 --owner=<用户名称> 把加入备份文件中的文件的拥有者设成指定的用户。 --posix 将数据写入备份文件时使用POSIX格式。 --preserve 此参数的效果和指定"-ps"参数相同。 --preserve-order 此参数的效果和指定"-A"参数相同。 --preserve-permissions 此参数的效果和指定"-p"参数相同。 --record-size=<区块数目> 此参数的效果和指定"-b"参数相同。 --recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。 --remove-files 文件加入备份文件后，就将其删除。 --rsh-command=<执行指令> 设置要在远端主机上执行的指令，以取代rsh指令。 --same-owner 尝试以相同的文件拥有者还原文件。 --suffix=<备份字尾字符串> 移除文件前先行备份。 --totals 备份文件建立后，列出文件大小。 --use-compress-program=<执行指令> 通过指定的指令处理备份文件。 --version 显示版本信息。 --volno-file=<编号文件> 使用指定文件内的编号取代预设的卷册编号。

- 打包（压缩）

  -z ：使用gzip格式压缩。(tar.gz、tgz.) -c ：建立一个压缩包或者tar包 -v ：可视化显示过程 -f ：后面跟文件名，（filename）

  tar -zcvf

```bash
[root@localhost ~]# tar -zcvf target.tar.gz testtar
testtar/
testtar/f1
testtar/f2
testtar/f3
testtar/f4
testtar/f5
testtar/f6
[root@localhost ~]# ls
aaa                   netinfo     target.tar.gz  模板  文档  桌面
anaconda-ks.cfg       source      testtar        视频  下载
initial-setup-ks.cfg  source.bak  公共           图片  音乐
```

- 查看包中的内容

  -t ：查看包内文件

```
[root@localhost ~]# tar -tf target.tar.gz
testtar/
testtar/f1
testtar/f2
testtar/f3
testtar/f4
testtar/f5
testtar/f6
```

- 解压缩

```bash
[root@localhost bin]# tar -xvf jdk-8u291-linux-x64.tar.gz
jdk1.8.0_291/man/man1/jhat.1
jdk1.8.0_291/man/man1/jinfo.1
jdk1.8.0_291/man/man1/jmap.1
jdk1.8.0_291/man/man1/jps.1
jdk1.8.0_291/man/man1/jrunscript.1
jdk1.8.0_291/man/man1/jsadebugd.1
jdk1.8.0_291/man/man1/jstack.1
jdk1.8.0_291/man/man1/jstat.1
jdk1.8.0_291/man/man1/jstatd.1
jdk1.8.0_291/man/man1/native2ascii.1
jdk1.8.0_291/man/man1/rmic.1
jdk1.8.0_291/man/man1/schemagen.1
jdk1.8.0_291/man/man1/serialver.1
jdk1.8.0_291/man/man1/wsgen.1
jdk1.8.0_291/man/man1/wsimport.1
jdk1.8.0_291/man/man1/xjc.1
jdk1.8.0_291/man/man1/jvisualvm.1
jdk1.8.0_291/man/man1/javafxpackager.1
jdk1.8.0_291/man/man1/javapackager.1
jdk1.8.0_291/man/ja_JP.UTF-8/
```

# [14.添加环境变量 ×](https://jshand.gitee.io/#/course/server/linux?id=_14添加环境变量-×)

JAVA_HOME=/root/jdk1.8.0_291

PATH=$PATH:$JAVA_HOME/bin

export PATH

当前用户的环境环境变量

在当前用户家目录中的 .bash_profile文件中追加上述内容

激活当前用户的 profile

```
[root@localhost ~]# source .bash_profile 
[root@localhost ~]# java -version
java version "1.8.0_291"
Java(TM) SE Runtime Environment (build 1.8.0_291-b10)
Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)
```

# [15.信息查看相关操作命令](https://jshand.gitee.io/#/course/server/linux?id=_15信息查看相关操作命令)

dmesg 显示系统的启动信息 uptime 关于系统相关的时间信息 who 查看当前系统用户 last 用户登入信息 pwd 当前所在路径信息 hostname 域名 cal 日历信息 date 时间及日期信息

# [16.关机相关的](https://jshand.gitee.io/#/course/server/linux?id=_16关机相关的)

shutdown -h -r -t

Linux shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。

使用权限：系统管理者。

**语法**

```
shutdown [-t seconds] [-rkhncfF] time [message]
```

**参数说明**：

- -t seconds : 设定在几秒钟之后进行关机程序。
- -k : 并不会真的关机，只是将警告讯息传送给所有使用者。
- -r : 关机后重新开机。
- -h : 关机后停机。
- -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。
- -c : 取消目前已经进行中的关机动作。
- -f : 关机时，不做 fsck 动作(检查 Linux 档系统)。
- -F : 关机时，强迫进行 fsck 动作。
- time : 设定关机的时间。
- message : 传送给所有使用者的警告讯息。

```bash
halt  
reboot 
shutdown -r -t 延迟秒
shutdown -c 
shutdown -k
```

# [17.定时操作](https://jshand.gitee.io/#/course/server/linux?id=_17定时操作)

```
f1 f2 f3 f4 f5 program
```

- 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。
- 当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推
- 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推
- 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推
- 当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推

```
*    *    *    *    *
-    -    -    -    -
|    |    |    |    |
|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)
|    |    |    +---------- 月份 (1 - 12) 
|    |    +--------------- 一个月中的第几天 (1 - 31)
|    +-------------------- 小时 (0 - 23)
+------------------------- 分钟 (0 - 59)
```

创建脚本 vi mycron.sh

```bash
#!/bin/bash/

date >>  time.info
```

添加定时任务

```bash
[root@localhost ~] crontab -e

* * * * * /root/mycron.sh 
```

打开一个新终端，查看time.info文件

```
[root@localhost ~] tail -f mycron.sh

[root@localhost ~]# tail -f time.info 
2021年 05月 26日 星期三 09:55:33 CST
2021年 05月 26日 星期三 09:55:40 CST
2021年 05月 26日 星期三 09:57:02 CST
2021年 05月 26日 星期三 09:57:10 CST
2021年 05月 26日 星期三 09:57:11 CST
2021年 05月 26日 星期三 09:57:12 CST
2021年 05月 26日 星期三 09:57:13 CST
2021年 05月 26日 星期三 09:57:13 CST
2021年 05月 26日 星期三 10:05:02 CST
2021年 05月 26日 星期三 10:06:01 CST
2021年 05月 26日 星期三 10:07:01 CST
```

![img](https://jshand.gitee.io/imgs/centos/run.png)

# [18.Linux 用户和用户组管理](https://jshand.gitee.io/#/course/server/linux?id=_18linux-用户和用户组管理)

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。

用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。

每个用户账号都拥有一个唯一的用户名和各自的口令。

用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。

实现用户账号的管理，要完成的工作主要有如下几个方面：

- 用户账号的添加、删除与修改。
- 用户口令的管理。
- 用户组的管理。

------

## [一、Linux系统用户账号的管理](https://jshand.gitee.io/#/course/server/linux?id=一、linux系统用户账号的管理)

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。

### [1、添加新的用户账号使用useradd命令，其语法如下：](https://jshand.gitee.io/#/course/server/linux?id=_1、添加新的用户账号使用useradd命令，其语法如下：)

```
useradd 选项 用户名
```

**参数说明**：

- 选项:

  - -c comment 指定一段注释性描述。
  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
  - -g 用户组 指定用户所属的用户组。
  - -G 用户组，用户组 指定用户所属的附加组。
  - -s Shell文件 指定用户的登录Shell。
  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

- 用户名:

  指定新账号的登录名。

#### [实例1](https://jshand.gitee.io/#/course/server/linux?id=实例1)

```
# useradd –d  /home/sam -m sam
```

此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。

#### [实例2](https://jshand.gitee.io/#/course/server/linux?id=实例2)

```
# useradd -s /bin/sh -g group –G adm,root gem
```

此命令新建了一个用户gem，该用户的登录Shell是 `/bin/sh`，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。

这里可能新建组：`#groupadd group及groupadd adm`

增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。

### [2、删除帐号](https://jshand.gitee.io/#/course/server/linux?id=_2、删除帐号)

如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。

删除一个已有的用户账号使用`userdel`命令，其格式如下：

```
userdel 选项 用户名
```

常用的选项是 -r，它的作用是把用户的主目录一起删除。

例如：

```
# userdel -r sam
```

此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。

### [3、修改帐号](https://jshand.gitee.io/#/course/server/linux?id=_3、修改帐号)

修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。

修改已有用户的信息使用`usermod`命令，其格式如下：

```
usermod 选项 用户名
```

常用的选项包括`-c, -d, -m, -g, -G, -s, -u以及-o等`，这些选项的意义与`useradd`命令中的选项一样，可以为用户指定新的资源值。

另外，有些系统可以使用选项：-l 新用户名

这个选项指定一个新的账号，即将原来的用户名改为新的用户名。

例如：

```
# usermod -s /bin/ksh -d /home/z –g developer sam
```

此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。

### [4、用户口令的管理](https://jshand.gitee.io/#/course/server/linux?id=_4、用户口令的管理)

用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：

```
passwd 选项 用户名
```

可使用的选项：

- -l 锁定口令，即禁用账号。
- -u 口令解锁。
- -d 使账号无口令。
- -f 强迫用户下次登录时修改口令。

如果默认用户名，则修改当前用户的口令。

例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：

```
$ passwd 
Old password:****** 
New password:******* 
Re-enter new password:*******
```

如果是超级用户，可以用下列形式指定任何用户的口令：

```
# passwd sam 
New password:******* 
Re-enter new password:*******
```

普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。

为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：

```
# passwd -d sam
```

此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。

passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：

```
# passwd -l sam
```

------

## [二、Linux系统用户组的管理](https://jshand.gitee.io/#/course/server/linux?id=二、linux系统用户组的管理)

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。

用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

### [1、增加一个新的用户组使用groupadd命令。其格式如下：](https://jshand.gitee.io/#/course/server/linux?id=_1、增加一个新的用户组使用groupadd命令。其格式如下：)

```
groupadd 选项 用户组
```

可以使用的选项有：

- -g GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

#### [实例1：](https://jshand.gitee.io/#/course/server/linux?id=实例1：)

```
# groupadd group1
```

此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。

#### [实例2：](https://jshand.gitee.io/#/course/server/linux?id=实例2：)

```
# groupadd -g 101 group2
```

此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

### [2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：](https://jshand.gitee.io/#/course/server/linux?id=_2、如果要删除一个已有的用户组，使用groupdel命令，其格式如下：)

```
groupdel 用户组
```

#### [例如：](https://jshand.gitee.io/#/course/server/linux?id=例如：)

```
# groupdel group1
```

此命令从系统中删除组group1。

### [3、修改用户组的属性使用groupmod命令。其语法如下：](https://jshand.gitee.io/#/course/server/linux?id=_3、修改用户组的属性使用groupmod命令。其语法如下：)

```
groupmod 选项 用户组
```

常用的选项有：

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n新用户组 将用户组的名字改为新名字

#### [实例1：](https://jshand.gitee.io/#/course/server/linux?id=实例1：-1)

```
# groupmod -g 102 group2
```

此命令将组group2的组标识号修改为102。

#### [实例2：](https://jshand.gitee.io/#/course/server/linux?id=实例2：-1)

```
# groupmod –g 10000 -n group3 group2
```

此命令将组group2的标识号改为10000，组名修改为group3。

### [4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。](https://jshand.gitee.io/#/course/server/linux?id=_4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。)

用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

```
$ newgrp root
```

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

------

## [三、与用户账号有关的系统文件](https://jshand.gitee.io/#/course/server/linux?id=三、与用户账号有关的系统文件)

完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。

与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。

下面分别介绍这些文件的内容。

### [1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。](https://jshand.gitee.io/#/course/server/linux?id=_1、etcpasswd文件是用户管理工作涉及的最重要的一个文件。)

Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。

这个文件对所有用户都是可读的。它的内容类似下面的例子：

```
＃ cat /etc/passwd

root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
sys:x:3:3:Owner of system files:/usr/sys:
adm:x:4:4:System accounting:/usr/adm:
uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
auth:x:7:21:Authentication administrator:/tcb/files/auth:
cron:x:9:16:Cron daemon:/usr/spool/cron:
listen:x:37:4:Network daemon:/usr/net/nls:
lp:x:71:18:Printer administrator:/usr/spool/lp:
sam:x:200:50:Sam san:/home/sam:/bin/sh
```

从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：

```
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
```

### [1）"用户名"是代表用户账号的字符串。](https://jshand.gitee.io/#/course/server/linux?id=_1）quot用户名quot是代表用户账号的字符串。)

通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。

为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。

### [2）“口令”一些系统中，存放着加密后的用户口令字。](https://jshand.gitee.io/#/course/server/linux?id=_2）口令一些系统中，存放着加密后的用户口令字。)

虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。

### [3）“用户标识号”是一个整数，系统内部用它来标识用户。](https://jshand.gitee.io/#/course/server/linux?id=_3）用户标识号是一个整数，系统内部用它来标识用户。)

一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。

通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。

### [4）“组标识号”字段记录的是用户所属的用户组。](https://jshand.gitee.io/#/course/server/linux?id=_4）组标识号字段记录的是用户所属的用户组。)

它对应着/etc/group文件中的一条记录。

### [5)“注释性描述”字段记录着用户的一些个人情况。](https://jshand.gitee.io/#/course/server/linux?id=_5注释性描述字段记录着用户的一些个人情况。)

例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。

### [6)“主目录”，也就是用户的起始工作目录。](https://jshand.gitee.io/#/course/server/linux?id=_6主目录，也就是用户的起始工作目录。)

它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。

### [7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。](https://jshand.gitee.io/#/course/server/linux?id=_7用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即shell。)

Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。

系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。

用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。

利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。

### [8)系统中有一类用户称为伪用户（pseudo users）。](https://jshand.gitee.io/#/course/server/linux?id=_8系统中有一类用户称为伪用户（pseudo-users）。)

这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。

常见的伪用户如下所示：

```
伪 用 户 含 义 
bin 拥有可执行的用户命令文件 
sys 拥有系统文件 
adm 拥有帐户文件 
uucp UUCP使用 
lp lp或lpd子系统使用 
nobody NFS使用
```

------

## [拥有帐户文件](https://jshand.gitee.io/#/course/server/linux?id=拥有帐户文件)

**1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。**

由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。

**2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生**

它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用":"隔开。这些字段是：

```
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
```

1. "登录名"是与/etc/passwd文件中的登录名相一致的用户账号
2. "口令"字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
3. "最后一次修改时间"表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
4. "最小时间间隔"指的是两次修改口令之间所需的最小天数。
5. "最大时间间隔"指的是口令保持有效的最大天数。
6. "警告时间"字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
7. "不活动时间"表示的是用户没有登录活动但账号仍能保持有效的最大天数。
8. "失效时间"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

下面是/etc/shadow的一个例子：

```
＃ cat /etc/shadow

root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::
adm:*::0:0::::
uucp:*::0:0::::
nuucp:*::0:0::::
auth:*::0:0::::
cron:*::0:0::::
listen:*::0:0::::
lp:*::0:0::::
sam:EkdiSECLWPdSa:9740:0:0::::
```

### [3、用户组的所有信息都存放在/etc/group文件中。](https://jshand.gitee.io/#/course/server/linux?id=_3、用户组的所有信息都存放在etcgroup文件中。)

将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。

每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。

当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。

用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。

用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：

```
组名:口令:组标识号:组内用户列表
```

1. "组名"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
2. "口令"字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
3. "组标识号"与用户标识号类似，也是一个整数，被系统内部用来标识组。
4. "组内用户列表"是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

/etc/group文件的一个例子如下：

```
root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam
```

### [四、添加批量用户](https://jshand.gitee.io/#/course/server/linux?id=四、添加批量用户)

添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：

### [（1）先编辑一个文本用户文件。](https://jshand.gitee.io/#/course/server/linux?id=（1）先编辑一个文本用户文件。)

每一列按照`/etc/passwd`密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：

```
user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
user004::603:100:user:/home/user004:/bin/bash
user005::604:100:user:/home/user005:/bin/bash
user006::605:100:user:/home/user006:/bin/bash
```

### [（2）以root身份执行命令 `/usr/sbin/newusers`，从刚创建的用户文件`user.txt`中导入数据，创建用户：](https://jshand.gitee.io/#/course/server/linux?id=（2）以root身份执行命令-usrsbinnewusers，从刚创建的用户文件usertxt中导入数据，创建用户：)

```
# newusers < user.txt
```

然后可以执行命令 `vipw` 或 `vi /etc/passwd` 检查 `/etc/passwd` 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。

### [（3）执行命令/usr/sbin/pwunconv。](https://jshand.gitee.io/#/course/server/linux?id=（3）执行命令usrsbinpwunconv。)

将 `/etc/shadow` 产生的 `shadow` 密码解码，然后回写到 `/etc/passwd` 中，并将`/etc/shadow`的`shadow`密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 `shadow password` 功能。

```
# pwunconv
```

### [（4）编辑每个用户的密码对照文件。](https://jshand.gitee.io/#/course/server/linux?id=（4）编辑每个用户的密码对照文件。)

格式为：

```
用户名:密码
```

实例文件 `passwd.txt` 内容如下：

```
user001:123456
user002:123456
user003:123456
user004:123456
user005:123456
user006:123456
```

### [（5）以 root 身份执行命令 `/usr/sbin/chpasswd`。](https://jshand.gitee.io/#/course/server/linux?id=（5）以-root-身份执行命令-usrsbinchpasswd。)

创建用户密码，`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏。

```
# chpasswd < passwd.txt
```

### [（6）确定密码经编码写入/etc/passwd的密码栏后。](https://jshand.gitee.io/#/course/server/linux?id=（6）确定密码经编码写入etcpasswd的密码栏后。)

执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`，并将结果写入 `/etc/shadow`。

```
# pwconv
```

> 简单操作

```bash
#需求:
#用户 ：   oracle 
#用户组：  oracleins

#home目录  /home/oracle


#1 创建用户组
[root@localhost /]# groupadd oracleins

#创建oralce用户并制定组（oracleins） 以及家目录（/home/oracle）
[root@localhost /]# useradd   -d  /home/oracle -m  -g  oracleins oracle
#查看是否创建成功
[root@localhost /]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin
polkitd:x:999:998:User for polkitd:/:/sbin/nologin
libstoragemgmt:x:998:995:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin
colord:x:997:994:User for colord:/var/lib/colord:/sbin/nologin
rpc:x:32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin
saned:x:996:993:SANE scanner daemon user:/usr/share/sane:/sbin/nologin
gluster:x:995:992:GlusterFS daemons:/run/gluster:/sbin/nologin
saslauth:x:994:76:Saslauthd user:/run/saslauthd:/sbin/nologin
abrt:x:173:173::/etc/abrt:/sbin/nologin
setroubleshoot:x:993:990::/var/lib/setroubleshoot:/sbin/nologin
rtkit:x:172:172:RealtimeKit:/proc:/sbin/nologin
pulse:x:171:171:PulseAudio System Daemon:/var/run/pulse:/sbin/nologin
radvd:x:75:75:radvd user:/:/sbin/nologin
chrony:x:992:987::/var/lib/chrony:/sbin/nologin
unbound:x:991:986:Unbound DNS resolver:/etc/unbound:/sbin/nologin
qemu:x:107:107:qemu user:/:/sbin/nologin
tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin
sssd:x:990:984:User for sssd:/:/sbin/nologin
usbmuxd:x:113:113:usbmuxd user:/:/sbin/nologin
geoclue:x:989:983:User for geoclue:/var/lib/geoclue:/sbin/nologin
ntp:x:38:38::/etc/ntp:/sbin/nologin
gdm:x:42:42::/var/lib/gdm:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologin
gnome-initial-setup:x:988:982::/run/gnome-initial-setup/:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
jshand:x:1000:1000:jshand:/home/jshand:/bin/bash
oracle:x:1001:1001::/home/oracle:/bin/bash

#查看组是否创建成功
[root@localhost /]# cat /etc/group
root:x:0:
bin:x:1:
daemon:x:2:
sys:x:3:
adm:x:4:
tty:x:5:
disk:x:6:
lp:x:7:
mem:x:8:
kmem:x:9:
wheel:x:10:jshand
cdrom:x:11:
mail:x:12:postfix
man:x:15:
dialout:x:18:
floppy:x:19:
games:x:20:
tape:x:33:
video:x:39:
ftp:x:50:
lock:x:54:
audio:x:63:
nobody:x:99:
users:x:100:
utmp:x:22:
utempter:x:35:
input:x:999:
systemd-journal:x:190:
systemd-network:x:192:
dbus:x:81:
polkitd:x:998:
printadmin:x:997:
cgred:x:996:
libstoragemgmt:x:995:
colord:x:994:
rpc:x:32:
saned:x:993:
dip:x:40:
gluster:x:992:
ssh_keys:x:991:
saslauth:x:76:
abrt:x:173:
setroubleshoot:x:990:
rtkit:x:172:
pulse-access:x:989:
pulse-rt:x:988:
pulse:x:171:
radvd:x:75:
chrony:x:987:
unbound:x:986:
kvm:x:36:qemu
qemu:x:107:
tss:x:59:
libvirt:x:985:
sssd:x:984:
usbmuxd:x:113:
geoclue:x:983:
ntp:x:38:
gdm:x:42:
rpcuser:x:29:
nfsnobody:x:65534:
gnome-initial-setup:x:982:
sshd:x:74:
slocate:x:21:
avahi:x:70:
postdrop:x:90:
postfix:x:89:
stapusr:x:156:
stapsys:x:157:
stapdev:x:158:
tcpdump:x:72:
jshand:x:1000:
oracleins:x:1001:

#切换到oracle用户下
[root@localhost /]# su oracle

#改变到~目录
[oracle@localhost /]$ cd ~

#通过pwd 查看当前用户的home目录是/home/oracle
[oracle@localhost ~]$ pwd
/home/oracle
[oracle@localhost ~]$ 
```

# [19. 文件的用户权限](https://jshand.gitee.io/#/course/server/linux?id=_19-文件的用户权限)

- chown 改变文件的拥有者
- chgrp 改变文件的所属群组
- chmod 改变文件的可写、可读、可执行等属性
- umask 改变预设的建立文件或目录时的属性
- chattr 改变文件的特殊属性
- lsattr 显示文件的特殊属性

## [19.1 chmod](https://jshand.gitee.io/#/course/server/linux?id=_191-chmod)

> 以nmon软件为例

现在nmon的tar.gz文件 上传到 linux 服务器

http://nmon.sourceforge.net/

将下载的nmon文件的 `nmon_x86_64_centos7`上传到服务器端，

给nmon的这个文件添加当前用户的 执行权限s

```bash
[root@localhost opt]# chmod u+x nmon_x86_64_centos7

[root@localhost opt]# ./nmon_x86_64_centos7 
```

![img](https://jshand.gitee.io/imgs/centos/2021-05-26_135241.png)

![img](https://jshand.gitee.io/imgs/centos/2021-05-26_135345.png)

为了在其他位置调用nmon 添加到PATH环境变量所在的目录中

```bash
[root@localhost opt]# ln nmon_x86_64_centos7 /usr/bin/nmon
[root@localhost opt]# nmon
```

## [19.2 chown](https://jshand.gitee.io/#/course/server/linux?id=_192-chown)

**参数** :

- user : 新的文件拥有者的使用者 ID
- group : 新的文件拥有者的使用者组(group)
- -c : 显示更改的部分的信息
- -f : 忽略错误信息
- -h :修复符号链接
- -v : 显示详细的处理信息
- -R : 处理指定目录以及其子目录下的所有文件
- --help : 显示辅助说明
- --version : 显示版本

```
#通过ll 查询发现netinfo 归属于root：root用户组无权限
[root@localhost ~]# ll |grep netinfo 
-rw-r--r--. 1 root root    14 5月  26 09:28 netinfo

#通过 chown 改变文件所属权限组
[root@localhost ~]# chown oracle:oracleins netinfo 
[root@localhost ~]# ll |grep netinfo 
-rw-r--r--. 1 oracle oracleins    14 5月  26 09:28 netinfo
[root@localhost ~]# 
```

## [19.3 su命令](https://jshand.gitee.io/#/course/server/linux?id=_193-su命令)

Linux su（英文全拼：swith user）命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。

**参数说明**：

- -f 或 --fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh
- -m -p 或 --preserve-environment 执行 su 时不改变环境变数
- -c command 或 --command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者
- -s shell 或 --shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell
- --help 显示说明文件
- --version 显示版本资讯
- \- -l 或 --login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root
- USER 欲变更的使用者帐号
- ARG 传入新的 shell 参数

```bash
[root@localhost ~]# su oracle

[oracle@localhost root]$ 
```

### [19.4 passwd](https://jshand.gitee.io/#/course/server/linux?id=_194-passwd)

```bash
#改变某一个用户的密码
[root@localhost ~]# passwd oracle
更改用户 oracle 的密码 。
新的 密码：
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[root@localhost ~]# 
```

![img](https://jshand.gitee.io/imgs/centos/2021-05-26_143602.png)

## [19.4 sudo](https://jshand.gitee.io/#/course/server/linux?id=_194-sudo)

临时获取管理员权限执行命令

```
[oracle@localhost ~]$ sudo service network restart

我们信任您已经从系统管理员那里了解了日常注意事项。
总结起来无外乎这三点：

    #1) 尊重别人的隐私。
    #2) 输入前要先考虑(后果和风险)。
    #3) 权力越大，责任越大。

[sudo] oracle 的密码：
对不起，请重试。
[sudo] oracle 的密码：
oracle 不在 sudoers 文件中。此事将被报告。
[oracle@localhost ~]$ 
```

# [20.VI/VIM](https://jshand.gitee.io/#/course/server/linux?id=_20vivim)

所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。

但是目前我们使用比较多的是 vim 编辑器。

vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。

## [20.1 什么是 vim？](https://jshand.gitee.io/#/course/server/linux?id=_201-什么是-vim？)

Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。

连 vim 的官方网站 ([http://www.vim.org](http://www.vim.org/)) 自己也说 vim 是一个程序开发工具而不是文字处理软件。

vim 键盘图：

![img](https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif)

------

## [20.2 vi/vim 的使用](https://jshand.gitee.io/#/course/server/linux?id=_202-vivim-的使用)

基本上 vi/vim 共分为三种模式，分别是**命令模式（Command mode）**，**输入模式（Insert mode）**和**底线命令模式（Last line mode）**。 这三种模式的作用分别是：

### [20.2.1 命令模式：](https://jshand.gitee.io/#/course/server/linux?id=_2021-命令模式：)

用户刚刚启动 vi/vim，便进入了命令模式。

此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。

以下是常用的几个命令：

- **i** 切换到输入模式，以输入字符。
- **x** 删除当前光标所在处的字符。
- **:** 切换到底线命令模式，以在最底一行输入命令。

若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。

命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。

### [20.2.2 输入模式](https://jshand.gitee.io/#/course/server/linux?id=_2022-输入模式)

在命令模式下按下i就进入了输入模式。

在输入模式中，可以使用以下按键：

- **字符按键以及Shift组合**，输入字符
- **ENTER**，回车键，换行
- **BACK SPACE**，退格键，删除光标前一个字符
- **DEL**，删除键，删除光标后一个字符
- **方向键**，在文本中移动光标
- **HOME**/**END**，移动光标到行首/行尾
- **Page Up**/**Page Down**，上/下翻页
- **Insert**，切换光标为输入/替换模式，光标将变成竖线/下划线
- **ESC**，退出输入模式，切换到命令模式

### [底线命令模式](https://jshand.gitee.io/#/course/server/linux?id=底线命令模式)

在命令模式下按下:（英文冒号）就进入了底线命令模式。

底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。

在底线命令模式中，基本的命令有（已经省略了冒号）：

- q 退出程序
- w 保存文件

按ESC键可随时退出底线命令模式。

简单的说，我们可以将这三个模式想成底下的图标来表示：

![img](https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png)

------

## [vi/vim 使用实例](https://jshand.gitee.io/#/course/server/linux?id=vivim-使用实例)

### [使用 vi/vim 进入一般模式](https://jshand.gitee.io/#/course/server/linux?id=使用-vivim-进入一般模式)

如果你想要使用 vi 来建立一个名为 jshand.txt 的文件时，你可以这样做：

```
$ vim jshand.txt
```

直接输入 **vi 文件名** 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！

![img](https://www.runoob.com/wp-content/uploads/2014/07/078207F0-B204-4464-AAEF-982F45EDDAE9.jpg)

### [按下 i 进入输入模式(也称为编辑模式)，开始编辑文字](https://jshand.gitee.io/#/course/server/linux?id=按下-i-进入输入模式也称为编辑模式，开始编辑文字)

在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！

在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。

这个时候，键盘上除了 **Esc** 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。

![img](https://www.runoob.com/wp-content/uploads/2014/07/1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg)

### [按下 ESC 按钮回到一般模式](https://jshand.gitee.io/#/course/server/linux?id=按下-esc-按钮回到一般模式)

好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 **Esc** 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！

### [在一般模式中按下 **:wq** 储存后离开 vi](https://jshand.gitee.io/#/course/server/linux?id=在一般模式中按下-wq-储存后离开-vi)

OK，我们要存档了，存盘并离开的指令很简单，输入 **:wq** 即可保存离开！

![img](https://www.runoob.com/wp-content/uploads/2014/07/B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg)

OK! 这样我们就成功创建了一个 jshand.txt 的文件。

------

## [vi/vim 按键说明](https://jshand.gitee.io/#/course/server/linux?id=vivim-按键说明)

除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。

### [第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等](https://jshand.gitee.io/#/course/server/linux?id=第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等)

| 移动光标的方法                                               |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| h 或 向左箭头键(←)                                           | 光标向左移动一个字符                                         |
| j 或 向下箭头键(↓)                                           | 光标向下移动一个字符                                         |
| k 或 向上箭头键(↑)                                           | 光标向上移动一个字符                                         |
| l 或 向右箭头键(→)                                           | 光标向右移动一个字符                                         |
| 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ |                                                              |
| [Ctrl] + [f]                                                 | 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)          |
| [Ctrl] + [b]                                                 | 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)           |
| [Ctrl] + [d]                                                 | 屏幕『向下』移动半页                                         |
| [Ctrl] + [u]                                                 | 屏幕『向上』移动半页                                         |
| +                                                            | 光标移动到非空格符的下一行                                   |
| -                                                            | 光标移动到非空格符的上一行                                   |
| n                                                            | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 |
| 0 或功能键[Home]                                             | 这是数字『 0 』：移动到这一行的最前面字符处 (常用)           |
| $ 或功能键[End]                                              | 移动到这一行的最后面字符处(常用)                             |
| H                                                            | 光标移动到这个屏幕的最上方那一行的第一个字符                 |
| M                                                            | 光标移动到这个屏幕的中央那一行的第一个字符                   |
| L                                                            | 光标移动到这个屏幕的最下方那一行的第一个字符                 |
| G                                                            | 移动到这个档案的最后一行(常用)                               |
| nG                                                           | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
| gg                                                           | 移动到这个档案的第一行，相当于 1G 啊！ (常用)                |
| n                                                            | n 为数字。光标向下移动 n 行(常用)                            |
| 搜索替换                                                     |                                                              |
| /word                                                        | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |
| ?word                                                        | 向光标之上寻找一个字符串名称为 word 的字符串。               |
| n                                                            | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
| N                                                            | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |
| 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ |                                                              |
| :n1,n2s/word1/word2/g                                        | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) |
| :1,$s/word1/word2/g 或 :%s/word1/word2/g                     | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) |
| :1,$s/word1/word2/gc 或 :%s/word1/word2/gc                   | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) |
| 删除、复制与贴上                                             |                                                              |
| x, X                                                         | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |
| nx                                                           | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |
| dd                                                           | 删除游标所在的那一整行(常用)                                 |
| ndd                                                          | n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) |
| d1G                                                          | 删除光标所在到第一行的所有数据                               |
| dG                                                           | 删除光标所在到最后一行的所有数据                             |
| d$                                                           | 删除游标所在处，到该行的最后一个字符                         |
| d0                                                           | 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符      |
| yy                                                           | 复制游标所在的那一行(常用)                                   |
| nyy                                                          | n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) |
| y1G                                                          | 复制游标所在行到第一行的所有数据                             |
| yG                                                           | 复制游标所在行到最后一行的所有数据                           |
| y0                                                           | 复制光标所在的那个字符到该行行首的所有数据                   |
| y$                                                           | 复制光标所在的那个字符到该行行尾的所有数据                   |
| p, P                                                         | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) |
| J                                                            | 将光标所在行与下一行的数据结合成同一行                       |
| c                                                            | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |
| u                                                            | 复原前一个动作。(常用)                                       |
| [Ctrl]+r                                                     | 重做上一个动作。(常用)                                       |
| 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ |                                                              |
| .                                                            | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) |

### [第二部分：一般模式切换到编辑模式的可用的按钮说明](https://jshand.gitee.io/#/course/server/linux?id=第二部分：一般模式切换到编辑模式的可用的按钮说明)

| 进入输入或取代的编辑模式                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| i, I                                                         | 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) |
| a, A                                                         | 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) |
| o, O                                                         | 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用) |
| r, R                                                         | 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) |
| 上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ |                                                              |
| [Esc]                                                        | 退出编辑模式，回到一般模式中(常用)                           |

### [第三部分：一般模式切换到指令行模式的可用的按钮说明](https://jshand.gitee.io/#/course/server/linux?id=第三部分：一般模式切换到指令行模式的可用的按钮说明)

| 指令行的储存、离开等指令                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| :w                                                           | 将编辑的数据写入硬盘档案中(常用)                             |
| :w!                                                          | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |
| :q                                                           | 离开 vi (常用)                                               |
| :q!                                                          | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |
| 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ |                                                              |
| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |
| ZZ                                                           | 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) |
| ZQ                                                           | 不保存，强制退出。效果等同于 :q!。                           |
| :w [filename]                                                | 将编辑的数据储存成另一个档案（类似另存新档）                 |
| :r [filename]                                                | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |
| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |
| :! command                                                   | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ |
| vim 环境的变更                                               |                                                              |
| :set nu                                                      | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |
| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |

特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。

举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。

# [21.网络相关](https://jshand.gitee.io/#/course/server/linux?id=_21网络相关)

> 此处以CentOS7为例进行说明，其他版本稍有差别

- ifconfig
- ip

```
[root@localhost ~]# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.77.111  netmask 255.255.255.0  broadcast 192.168.77.255
        inet6 fe80::aa80:b507:de7d:bb2f  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:7a:37:b5  txqueuelen 1000  (Ethernet)
        RX packets 338  bytes 39961 (39.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 371  bytes 34211 (33.4 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255
        ether 52:54:00:86:b2:7a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@localhost ~]# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:7a:37:b5 brd ff:ff:ff:ff:ff:ff
    inet 192.168.77.111/24 brd 192.168.77.255 scope global noprefixroute dynamic ens33
       valid_lft 1196sec preferred_lft 1196sec
    inet6 fe80::aa80:b507:de7d:bb2f/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default qlen 1000
    link/ether 52:54:00:86:b2:7a brd ff:ff:ff:ff:ff:ff
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
4: virbr0-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000
    link/ether 52:54:00:86:b2:7a brd ff:ff:ff:ff:ff:ff
[root@localhost ~]# 
```

## [21.1 动态获取网卡配置](https://jshand.gitee.io/#/course/server/linux?id=_211-动态获取网卡配置)

```bash
[root@localhost ~]# cat  /etc/sysconfig/network-scripts/ifcfg-ens33 
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no

#通过DHCP 服务 动态获取IP地址
BOOTPROTO=dhcp


DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=78103a00-3711-4385-aa00-099147a15da0
DEVICE=ens33
ONBOOT=yes
```

## [21.2 静态ip地址](https://jshand.gitee.io/#/course/server/linux?id=_212-静态ip地址)

> IPADDR=192.168.77.111 NETMASK=255.255.255.0 GATEWAY=192.168.77.1 DNS1=192.168.8.18

```bash
[root@localhost ~]# cat  /etc/sysconfig/network-scripts/ifcfg-ens33 
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no

#静态ip
BOOTPROTO=static


DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=78103a00-3711-4385-aa00-099147a15da0
DEVICE=ens33
#ip地址
IPADDR=192.168.77.111
#子网掩码
NETMASK=255.255.255.0
#网关
GATEWAY=192.168.77.1
#DNS服务器 DNS1 、DNS2
DNS1=192.168.8.18


ONBOOT=yes
```

## [21.3 修改计算机（主机）名](https://jshand.gitee.io/#/course/server/linux?id=_213-修改计算机（主机）名)

```
#查看当前的主机名
[root@localhost ~]# hostname
localhost.localdomain
#临时修改
[root@localhost ~]# hostname aaaaa
#编辑 /et/hostname永久修改
[root@localhost ~]# vi /etc/hostname 
```

> centos6版本通过如下方式修改

```bash
[root@fulfill ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=fulfill
NETWORKING_IPV6=no
PEERNTP=no
GATEWAY=121.42.51.247
```

## [21.4 测试网络](https://jshand.gitee.io/#/course/server/linux?id=_214-测试网络)

### [1.netstat](https://jshand.gitee.io/#/course/server/linux?id=_1netstat)

netstat命令可以查看网络连接及服务相关的信息。

Linux netstat 命令用于显示网络状态。

利用 netstat 指令可让你得知整个 Linux 系统的网络情况。

**参数说明**：

- -a或--all 显示所有连线中的Socket。
- -A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。
- -c或--continuous 持续列出网络状态。
- -C或--cache 显示路由器配置的快取信息。
- -e或--extend 显示网络其他相关信息。
- -F或--fib 显示路由缓存。
- -g或--groups 显示多重广播功能群组组员名单。
- -h或--help 在线帮助。
- -i或--interfaces 显示网络界面信息表单。
- -l或--listening 显示监控中的服务器的Socket。
- -M或--masquerade 显示伪装的网络连线。
- -n或--numeric 直接使用IP地址，而不通过域名服务器。
- -N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。
- -o或--timers 显示计时器。
- -p或--programs 显示正在使用Socket的程序识别码和程序名称。
- -r或--route 显示Routing Table。
- -s或--statistics 显示网络工作信息统计表。
- -t或--tcp 显示TCP传输协议的连线状况。
- -u或--udp 显示UDP传输协议的连线状况。
- -v或--verbose 显示指令执行过程。
- -V或--version 显示版本信息。
- -w或--raw 显示RAW传输协议的连线状况。
- -x或--unix 此参数的效果和指定"-A unix"参数相同。
- --ip或--inet 此参数的效果和指定"-A inet"参数相同。

```bash
[root@localhost ~]# netstat -aop
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name     Timer
tcp        0      0 0.0.0.0:sunrpc          0.0.0.0:*               LISTEN      748/rpcbind          off (0.00/0/0)
tcp        0      0 aaaaa:domain            0.0.0.0:*               LISTEN      1782/dnsmasq         off (0.00/0/0)
tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      1251/sshd            off (0.00/0/0)
tcp        0      0 localhost:ipp           0.0.0.0:*               LISTEN      1252/cupsd           off (0.00/0/0)
tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN      1470/master          off (0.00/0/0)
tcp6       0      0 [::]:sunrpc             [::]:*                  LISTEN      748/rpcbind          off (0.00/0/0)
tcp6       0      0 [::]:ssh                [::]:*                  LISTEN      1251/sshd            off (0.00/0/0)
tcp6       0      0 localhost:ipp           [::]:*                  LISTEN      1252/cupsd           off (0.00/0/0)
tcp6       0      0 localhost:smtp          [::]:*                  LISTEN      1470/master          off (0.00/0/0)
udp        0      0 0.0.0.0:922             0.0.0.0:*                           748/rpcbind          off (0.00/0/0)
udp        0      0 0.0.0.0:mdns            0.0.0.0:*                           757/avahi-daemon: r  off (0.00/0/0)
udp        0      0 aaaaa:domain            0.0.0.0:*                           1782/dnsmasq         off (0.00/0/0)
udp        0      0 0.0.0.0:57399           0.0.0.0:*                           757/avahi-daemon: r  off (0.00/0/0)
udp        0      0 0.0.0.0:bootps          0.0.0.0:*                           1782/dnsmasq         off (0.00/0/0)
udp        0      0 0.0.0.0:bootpc          0.0.0.0:*                           1055/dhclient        off (0.00/0/0)
udp        0      0 0.0.0.0:sunrpc          0.0.0.0:*                           748/rpcbind          off (0.00/0/0)
udp        0      0 localhost:323           0.0.0.0:*                           760/chronyd          off (0.00/0/0)
udp6       0      0 [::]:922                [::]:*                              748/rpcbind          off (0.00/0/0)
udp6       0      0 [::]:sunrpc             [::]:*                              748/rpcbind          off (0.00/0/0)
udp6       0      0 localhost:323           [::]:*                              760/chronyd          off (0.00/0/0)
raw6       0      0 [::]:ipv6-icmp          [::]:*                  7           923/NetworkManager   off (0.00/0/0)
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node   PID/Program name     Path
unix  2      [ ACC ]     STREAM     LISTENING     30326    1470/master          private/smtp
unix  2      [ ACC ]     STREAM     LISTENING     30329    1470/master          private/relay
unix  2      [ ACC ]     STREAM     LISTENING     30335    1470/master          private/error
unix  2      [ ACC ]     STREAM     LISTENING     21505    1/systemd            /var/run/cups/cups.sock
unix  2      [ ACC ]     STREAM     LISTENING     30338    1470/master          private/retry
unix  2      [ ACC ]     STREAM     LISTENING     30341    1470/master          private/discard
unix  2      [ ]         DGRAM                    23299    760/chronyd          /var/run/chrony/chronyd.sock
unix  2      [ ACC ]     STREAM     LISTENING     21507    1/systemd            /var/run/libvirt/virtlockd-sock
unix  2      [ ACC ]     STREAM     LISTENING     30344    1470/master          private/local
unix  2      [ ACC ]     STREAM     LISTENING     30347    1470/master          private/virtual
```

### [2.ping](https://jshand.gitee.io/#/course/server/linux?id=_2ping)

ping发送数据包给指定计算机

**数说明**：

- -d 使用Socket的SO_DEBUG功能。
- -c <完成次数> 设置完成要求回应的次数。
- -f 极限检测。
- -i<间隔秒数> 指定收发信息的间隔时间。
- -I<网络界面> 使用指定的网络接口送出数据包。
- -l<前置载入> 设置在送出要求信息之前，先行发出的数据包。
- -n 只输出数值。
- -p<范本样式> 设置填满数据包的范本样式。
- -q 不显示指令执行过程，开头和结尾的相关信息除外。
- -r 忽略普通的Routing Table，直接将数据包送到远端主机上。
- -R 记录路由过程。
- -s<数据包大小> 设置数据包的大小。
- -t<存活数值> 设置存活数值TTL的大小。
- -v 详细显示指令的执行过程。
- -w 在 deadline 秒后退出。
- -W 在等待 timeout 秒后开始执行。

### [3.tarcert/traceroute](https://jshand.gitee.io/#/course/server/linux?id=_3tarcerttraceroute)

windows下的 路由情况查看

```bash
Microsoft Windows [版本 6.1.7601]
版权所有 (c) 2009 Microsoft Corporation。保留所有权利。

C:\Users\Administrator>tracert www.baidu.com

通过最多 30 个跃点跟踪
到 www.a.shifen.com [110.242.68.3] 的路由:

  1     1 ms    <1 毫秒    1 ms  PC-20180611ZRTA [192.168.77.1]
  2     1 ms     1 ms    <1 毫秒 192.168.251.109
  3     1 ms     1 ms     2 ms  192.168.251.51
  4     1 ms     2 ms     2 ms  221.208.25.33
  5     *        2 ms     1 ms  1.62.143.161
  6     2 ms     1 ms     2 ms  61.180.255.34
  7    24 ms    24 ms    24 ms  1.62.127.193
  8    26 ms    25 ms     *     219.158.23.9
  9    27 ms    27 ms    28 ms  110.242.66.178
 10    27 ms    30 ms    28 ms  221.194.45.154
 11     *        *        *     请求超时。
 12     *        *        *     请求超时。
 13     *        *        *     请求超时。
 14     *        *        *     请求超时。
 15     *       24 ms    24 ms  110.242.68.3

跟踪完成。
```

linux下查看路由记录

```bash
[root@fulfill ~]# traceroute www.baiud.com
traceroute to www.baiud.com (103.51.144.90), 30 hops max, 60 byte packets
 1  * * *
 2  11.208.177.97 (11.208.177.97)  4.946 ms 11.208.178.157 (11.208.178.157)  1.017 ms *
 3  11.208.176.218 (11.208.176.218)  1.291 ms 11.208.177.190 (11.208.177.190)  1.030 ms 11.208.177.174 (11.208.177.174)  124.001 ms
 4  116.251.114.126 (116.251.114.126)  1.276 ms 116.251.114.130 (116.251.114.130)  1.130 ms 116.251.117.174 (116.251.117.174)  0.943 ms
 5  116.251.113.37 (116.251.113.37)  1.192 ms  1.182 ms 116.251.113.53 (116.251.113.53)  0.763 ms
 6  * * *
 7  27.221.86.181 (27.221.86.181)  7.370 ms 27.221.94.77 (27.221.94.77)  1.129 ms 27.221.94.45 (27.221.94.45)  1.339 ms
 8  219.158.101.117 (219.158.101.117)  36.070 ms 219.158.102.53 (219.158.102.53)  36.939 ms  36.908 ms
 9  219.158.103.42 (219.158.103.42)  38.566 ms 219.158.97.2 (219.158.97.2)  36.135 ms 219.158.24.126 (219.158.24.126)  38.502 ms
10  219.158.103.26 (219.158.103.26)  45.262 ms 219.158.24.134 (219.158.24.134)  38.545 ms  41.610 ms
11  219.158.10.50 (219.158.10.50)  47.598 ms  47.580 ms  47.494 ms
12  219.158.38.66 (219.158.38.66)  37.037 ms  36.869 ms  37.398 ms
13  63-217-17-129.static.pccwglobal.net (63.217.17.129)  41.123 ms  40.474 ms  41.052 ms
14  63-217-17-130.static.pccwglobal.net (63.217.17.130)  39.806 ms  42.366 ms  42.400 ms
15  223-197-123-141.static.imsbiz.com (223.197.123.141)  39.392 ms  39.797 ms  40.948 ms
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *
```

# [22 使用yum安装软件](https://jshand.gitee.io/#/course/server/linux?id=_22-使用yum安装软件)

Linux rpm 命令用于管理套件。

rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。

Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於rpm包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。

## [22.1. yum 简介](https://jshand.gitee.io/#/course/server/linux?id=_221-yum-简介)

　　yum，是Yellow dog Updater, Modified 的简称，是杜克大学为了提高RPM 软件包安装性而开发的一种软件包管理器。起初是由yellow dog 这一发行版的开发者Terra Soft 研发，用python 写成，那时还叫做yup(yellow dog updater)，后经杜克大学的Linux@Duke 开发团队进行改进，遂有此名。yum 的宗旨是自动化地升级，安装/移除rpm 包，收集rpm 包的相关信息，检查依赖性并自动提示用户解决。yum 的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http 或ftp 站点，也可以是本地软件池，但必须包含rpm 的header，header 包括了rpm 包的各种信息，包括描述，功能，提供的文件，依赖性等。正是收集了这些header 并加以分析，才能自动化地完成余下的任务。

　　yum 的理念是使用一个中心仓库(repository)管理一部分甚至一个distribution 的应用程序相互关系，根据计算出来的软件依赖关系进行相关的升级、安装、删除等等操作，减少了Linux 用户一直头痛的dependencies 的问题。这一点上，yum 和apt 相同。apt 原为debian 的deb 类型软件管理所使用，但是现在也能用到RedHat 门下的rpm 了。

　　yum 主要功能是更方便的添加/删除/更新RPM 包，自动解决包的倚赖性问题，便于管理大量系统的更新问题。

　　yum 可以同时配置多个资源库(Repository)，简洁的配置文件（/etc/yum.conf），自动解决增加或删除rpm 包时遇到的依赖性问题，保持与RPM 数据库的一致性。

 服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。

 客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。

## [22.2 yum 安装](https://jshand.gitee.io/#/course/server/linux?id=_222-yum-安装)

CentOS 默认已经安装了yum，不需要另外安装

## [22.3 yum 配置](https://jshand.gitee.io/#/course/server/linux?id=_223-yum-配置)

yum 的配置文件分为两部分：main 和repository

- main 部分定义了全局配置选项，整个yum 配置文件应该只有一个main。常位于/etc/yum.conf 中。
- repository 部分定义了每个源/服务器的具体配置，可以有一到多个。常位于/etc/yum.repo.d 目录下的各文件中。

yum.conf 文件一般位于/etc目录下，一般其中只包含main部分的配置选项。

```
[root@zhangshun ~]# cat /etc/yum.conf 
[main]
cachedir=/var/cache/yum/$basearch/$releasever
keepcache=0
debuglevel=2
logfile=/var/log/yum.log
exactarch=1
obsoletes=1
gpgcheck=1
plugins=1
installonly_limit=5
bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&ref=http://bugs.centos.org/bug_report_page.php?category=yum
distroverpkg=centos-release


#  This is the default, if you make this bigger yum won't see if the metadata
# is newer on the remote and so you'll "gain" the bandwidth of not having to
# download the new metadata and "pay" for it by yum not having correct
# information.
#  It is esp. important, to have correct metadata, for distributions like
# Fedora which don't keep old packages around. If you don't like this checking
# interupting your command line usage, it's much better to have something
# manually check the metadata once an hour (yum-updatesd will do this).
# metadata_expire=90m

# PUT YOUR REPOS HERE OR IN separate files named file.repo
# in /etc/yum.repos.d
```

除了上述之外，还有一些可以添加的选项，如：

　　exclude=selinux*　　// 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。 　　gpgcheck=1　　// 有1和0两个选择，分别代表是否是否进行gpg(GNU Private Guard) 校验，以确定rpm 包的来源是有效和安全的。这个选项如果设置在[main]部分，则对每个repository 都有效。默认值为0

```
[root@localhost ~]# ll /etc/yum.repos.d/
总用量 40
-rw-r--r--. 1 root root 1664 10月 23 2020 CentOS-Base.repo
-rw-r--r--. 1 root root 1309 10月 23 2020 CentOS-CR.repo
-rw-r--r--. 1 root root  649 10月 23 2020 CentOS-Debuginfo.repo
-rw-r--r--. 1 root root  314 10月 23 2020 CentOS-fasttrack.repo
-rw-r--r--. 1 root root  630 10月 23 2020 CentOS-Media.repo
-rw-r--r--. 1 root root 1331 10月 23 2020 CentOS-Sources.repo
-rw-r--r--. 1 root root 8515 10月 23 2020 CentOS-Vault.repo
-rw-r--r--. 1 root root  616 10月 23 2020 CentOS-x86_64-kernel.repo
[root@localhost ~]# 
```

CentOS-Base.repo 是yum 网络源的配置文件

CentOS-Media.repo 是yum 本地源的配置文件

查看本地 源 CentOS-Media.repo

```
[root@localhost ~]# cat /etc/yum.repos.d/CentOS-Media.repo 
# CentOS-Media.repo
#
#  This repo can be used with mounted DVD media, verify the mount point for
#  CentOS-7.  You can use this repo and yum to install items directly off the
#  DVD ISO that we release.
#
# To use this repo, put in your DVD and use it with the other repos too:
#  yum --enablerepo=c7-media [command]
#  
# or for ONLY the media repo, do this:
#
#  yum --disablerepo=\* --enablerepo=c7-media [command]

[c7-media]
name=CentOS-$releasever - Media
baseurl=file:///media/CentOS/
        file:///media/cdrom/
        file:///media/cdrecorder/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
```

**关于repo 文件的格式**

所有repository 服务器设置都应该遵循如下格式：

```bash
[serverid]
name=Some name for this server
baseurl=url://path/to/repository/
```

- serverid 是用于区别各个不同的repository，必须有一个独一无二的名称；
- name 是对repository 的描述，支持像$releasever $basearch这样的变量；
- baseurl 是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是：

```bash
baseurl=url://server1/path/to/repository/
　　　　 url://server2/path/to/repository/
　　　　 url://server3/path/to/repository/
```

其中url 支持的协议有 http:// ftp:// file:// 三种。baseurl 后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl 只能有一个，也就是说不能像如下格式：

```bash
baseurl=url://server1/path/to/repository/
baseurl=url://server2/path/to/repository/
baseurl=url://server3/path/to/repository/
```

其中url 指向的目录必须是这个repository header 目录的上一级，它也支持$releasever $basearch 这样的变量。 url 之后可以加上多个选项，如gpgcheck、exclude、failovermethod 等，比如：

```bash
[updates-released]
name=Fedora Core $releasever - $basearch - Released Updates
baseurl=http://download.atrpms.net/mirrors/fedoracore/updates/$releasever/$basearch
　　　　 http://redhat.linux.ee/pub/fedora/linux/core/updates/$releasever/$basearch
　　　　 http://fr2.rpmfind.net/linux/fedora/core/updates/$releasever/$basearch
gpgcheck=1
exclude=gaim
failovermethod=priority
```

## [22.4配置国内yum源](https://jshand.gitee.io/#/course/server/linux?id=_224配置国内yum源)

> 国内yum源列表如下：

1. 企业贡献： 搜狐开源镜像站：http://mirrors.sohu.com/ 网易开源镜像站：http://mirrors.163.com/
2. 大学教学： 北京理工大学： [http://mirror.bit.edu.cn](http://mirror.bit.edu.cn/) (IPv4 only) [http://mirror.bit6.edu.cn](http://mirror.bit6.edu.cn/) (IPv6 only) 北京交通大学： [http://mirror.bjtu.edu.cn](http://mirror.bjtu.edu.cn/) (IPv4 only) [http://mirror6.bjtu.edu.cn](http://mirror6.bjtu.edu.cn/) (IPv6 only) [http://debian.bjtu.edu.cn](http://debian.bjtu.edu.cn/) (IPv4+IPv6) 兰州大学：http://mirror.lzu.edu.cn/ 厦门大学：http://mirrors.xmu.edu.cn/ 清华大学： http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6) http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only) http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only) 天津大学：http://mirror.tju.edu.cn/ 中国科学技术大学： http://mirrors.ustc.edu.cn/ (IPv4+IPv6) http://mirrors4.ustc.edu.cn/ http://mirrors6.ustc.edu.cn/ 东北大学： http://mirror.neu.edu.cn/ (IPv4 only) http://mirror.neu6.edu.cn/ (IPv6 only)

# [23.配置网易yum源](https://jshand.gitee.io/#/course/server/linux?id=_23配置网易yum源)

http://mirrors.163.com/.help/centos.html

首先备份/etc/yum.repos.d/CentOS-Base.repo

```bash
[root@localhost yum.repos.d]# ls
CentOS-Base.repo       CentOS-fasttrack.repo  CentOS-Vault.repo
CentOS-CR.repo         CentOS-Media.repo      CentOS-x86_64-kernel.repo
CentOS-Debuginfo.repo  CentOS-Sources.repo


[root@localhost yum.repos.d]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
[root@localhost yum.repos.d]# ls
CentOS-Base.repo.backup  CentOS-fasttrack.repo  CentOS-Vault.repo
CentOS-CR.repo           CentOS-Media.repo      CentOS-x86_64-kernel.repo
CentOS-Debuginfo.repo    CentOS-Sources.repo
[root@localhost yum.repos.d]# 


[root@localhost yum.repos.d]# wget http://mirrors.163.com/.help/CentOS7-Base-163.repo
--2021-05-27 10:36:39--  http://mirrors.163.com/.help/CentOS7-Base-163.repo
正在解析主机 mirrors.163.com (mirrors.163.com)... 139.215.129.21, 139.215.129.22
正在连接 mirrors.163.com (mirrors.163.com)|139.215.129.21|:80... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度：1572 (1.5K) [application/octet-stream]
正在保存至: “CentOS7-Base-163.repo”

100%[=============================================>] 1,572       --.-K/s 用时 0s      

2021-05-27 10:36:39 (67.2 MB/s) - 已保存 “CentOS7-Base-163.repo” [1572/1572])

[root@localhost yum.repos.d]# ls
CentOS7-Base-163.repo    CentOS-Debuginfo.repo  CentOS-Sources.repo
CentOS-Base.repo.backup  CentOS-fasttrack.repo  CentOS-Vault.repo
CentOS-CR.repo           CentOS-Media.repo      CentOS-x86_64-kernel.repo
[root@localhost yum.repos.d]# 
```

安装第三方的源

```bash
[root@localhost yum.repos.d]yum install epel-release
[root@localhost yum.repos.d]yum update
```

# [24.yum常用命令](https://jshand.gitee.io/#/course/server/linux?id=_24yum常用命令)

## [yum常用命令](https://jshand.gitee.io/#/course/server/linux?id=yum常用命令)

- 1.列出所有可更新的软件清单命令：yum check-update

- 1. 更新所有软件命令：yum update

- 1. 仅安装指定的软件命令：yum install

- 1. 仅更新指定的软件命令：yum update

- 列出所有可安裝的软件清单命令：yum list

- 1. 删除软件包命令：yum remove

- 1. 查找软件包命令：yum search

- 1. 清除缓存命令:

  - yum clean packages: 清除缓存目录下的软件包
  - yum clean headers: 清除缓存目录下的 headers
  - yum clean oldheaders: 清除缓存目录下旧的 headers
  - yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers

## [24.2安装nginx](https://jshand.gitee.io/#/course/server/linux?id=_242安装nginx)

```bash
[root@localhost ~]# yum install nginx
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * epel: mirrors.neusoft.edu.cn
正在解决依赖关系
There are unfinished transactions remaining. You might consider running yum-complete-transaction, or "yum-complete-transaction --cleanup-only" and "yum history redo last", first to finish them. If those don't work you'll have to try removing/installing packages by hand (maybe package-cleanup can help).
--> 正在检查事务
---> 软件包 nginx.x86_64.1.1.16.1-3.el7 将被 安装
--> 正在处理依赖关系 nginx-all-modules = 1:1.16.1-3.el7，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 nginx-filesystem = 1:1.16.1-3.el7，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 libcrypto.so.1.1(OPENSSL_1_1_0)(64bit)，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 libssl.so.1.1(OPENSSL_1_1_0)(64bit)，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 libssl.so.1.1(OPENSSL_1_1_1)(64bit)，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 nginx-filesystem，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 libcrypto.so.1.1()(64bit)，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在处理依赖关系 libssl.so.1.1()(64bit)，它被软件包 1:nginx-1.16.1-3.el7.x86_64 需要
--> 正在检查事务
---> 软件包 nginx-all-modules.noarch.1.1.16.1-3.el7 将被 安装
--> 正在处理依赖关系 nginx-mod-http-image-filter = 1:1.16.1-3.el7，它被软件包 1:nginx-all-modules-1.16.1-3.el7.noarch 需要
--> 正在处理依赖关系 nginx-mod-http-perl = 1:1.16.1-3.el7，它被软件包 1:nginx-all-modules-1.16.1-3.el7.noarch 需要
--> 正在处理依赖关系 nginx-mod-http-xslt-filter = 1:1.16.1-3.el7，它被软件包 1:nginx-all-modules-1.16.1-3.el7.noarch 需要
--> 正在处理依赖关系 nginx-mod-mail = 1:1.16.1-3.el7，它被软件包 1:nginx-all-modules-1.16.1-3.el7.noarch 需要
--> 正在处理依赖关系 nginx-mod-stream = 1:1.16.1-3.el7，它被软件包 1:nginx-all-modules-1.16.1-3.el7.noarch 需要
---> 软件包 nginx-filesystem.noarch.1.1.16.1-3.el7 将被 安装
---> 软件包 openssl11-libs.x86_64.1.1.1.1g-3.el7 将被 安装
--> 正在检查事务
---> 软件包 nginx-mod-http-image-filter.x86_64.1.1.16.1-3.el7 将被 安装
---> 软件包 nginx-mod-http-perl.x86_64.1.1.16.1-3.el7 将被 安装
---> 软件包 nginx-mod-http-xslt-filter.x86_64.1.1.16.1-3.el7 将被 安装
---> 软件包 nginx-mod-mail.x86_64.1.1.16.1-3.el7 将被 安装
---> 软件包 nginx-mod-stream.x86_64.1.1.16.1-3.el7 将被 安装
--> 解决依赖关系完成

依赖关系解决

=======================================================================================
 Package                           架构         版本                  源          大小
=======================================================================================
正在安装:
 nginx                             x86_64       1:1.16.1-3.el7        epel       563 k
为依赖而安装:
 nginx-all-modules                 noarch       1:1.16.1-3.el7        epel        20 k
 nginx-filesystem                  noarch       1:1.16.1-3.el7        epel        21 k
 nginx-mod-http-image-filter       x86_64       1:1.16.1-3.el7        epel        30 k
 nginx-mod-http-perl               x86_64       1:1.16.1-3.el7        epel        39 k
 nginx-mod-http-xslt-filter        x86_64       1:1.16.1-3.el7        epel        29 k
 nginx-mod-mail                    x86_64       1:1.16.1-3.el7        epel        57 k
 nginx-mod-stream                  x86_64       1:1.16.1-3.el7        epel        85 k
 openssl11-libs                    x86_64       1:1.1.1g-3.el7        epel       1.5 M

事务概要
=======================================================================================
安装  1 软件包 (+8 依赖软件包)

总下载量：2.3 M
安装大小：5.5 M
Is this ok [y/d/N]: y
Downloading packages:
(1/9): nginx-1.16.1-3.el7.x86_64.rpm                            | 563 kB  00:00:01     
(2/9): nginx-all-modules-1.16.1-3.el7.noarch.rpm                |  20 kB  00:00:00     
(3/9): nginx-filesystem-1.16.1-3.el7.noarch.rpm                 |  21 kB  00:00:00     
(4/9): nginx-mod-http-image-filter-1.16.1-3.el7.x86_64.rpm      |  30 kB  00:00:00     
(5/9): nginx-mod-http-perl-1.16.1-3.el7.x86_64.rpm              |  39 kB  00:00:00     
(6/9): nginx-mod-http-xslt-filter-1.16.1-3.el7.x86_64.rpm       |  29 kB  00:00:00     
(7/9): nginx-mod-mail-1.16.1-3.el7.x86_64.rpm                   |  57 kB  00:00:00     
(8/9): nginx-mod-stream-1.16.1-3.el7.x86_64.rpm                 |  85 kB  00:00:00     
(9/9): openssl11-libs-1.1.1g-3.el7.x86_64.rpm                   | 1.5 MB  00:00:02     
---------------------------------------------------------------------------------------
总计                                                      362 kB/s | 2.3 MB  00:06     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
警告：RPM 数据库已被非 yum 程序修改。

** 发现 2 个已存在的 RPM 数据库问题， 'yum check' 输出如下：
tagsoup-1.2.1-8.el7.noarch 有缺少的需求 jpackage-utils
tagsoup-1.2.1-8.el7.noarch 有缺少的需求 jpackage-utils >= ('0', '1.6', None)
  正在安装    : 1:openssl11-libs-1.1.1g-3.el7.x86_64                               1/9 
  正在安装    : 1:nginx-filesystem-1.16.1-3.el7.noarch                             2/9 
  正在安装    : 1:nginx-mod-mail-1.16.1-3.el7.x86_64                               3/9 
  正在安装    : 1:nginx-mod-http-perl-1.16.1-3.el7.x86_64                          4/9 
  正在安装    : 1:nginx-mod-http-xslt-filter-1.16.1-3.el7.x86_64                   5/9 
  正在安装    : 1:nginx-mod-http-image-filter-1.16.1-3.el7.x86_64                  6/9 
  正在安装    : 1:nginx-1.16.1-3.el7.x86_64                                        7/9 
  正在安装    : 1:nginx-mod-stream-1.16.1-3.el7.x86_64                             8/9 
  正在安装    : 1:nginx-all-modules-1.16.1-3.el7.noarch                            9/9 
  验证中      : 1:nginx-mod-stream-1.16.1-3.el7.x86_64                             1/9 
  验证中      : 1:nginx-mod-mail-1.16.1-3.el7.x86_64                               2/9 
  验证中      : 1:nginx-mod-http-perl-1.16.1-3.el7.x86_64                          3/9 
  验证中      : 1:nginx-1.16.1-3.el7.x86_64                                        4/9 
  验证中      : 1:nginx-filesystem-1.16.1-3.el7.noarch                             5/9 
  验证中      : 1:nginx-mod-http-xslt-filter-1.16.1-3.el7.x86_64                   6/9 
  验证中      : 1:nginx-all-modules-1.16.1-3.el7.noarch                            7/9 
  验证中      : 1:nginx-mod-http-image-filter-1.16.1-3.el7.x86_64                  8/9 
  验证中      : 1:openssl11-libs-1.1.1g-3.el7.x86_64                               9/9 

已安装:
  nginx.x86_64 1:1.16.1-3.el7                                                          

作为依赖被安装:
  nginx-all-modules.noarch 1:1.16.1-3.el7                                              
  nginx-filesystem.noarch 1:1.16.1-3.el7                                               
  nginx-mod-http-image-filter.x86_64 1:1.16.1-3.el7                                    
  nginx-mod-http-perl.x86_64 1:1.16.1-3.el7                                            
  nginx-mod-http-xslt-filter.x86_64 1:1.16.1-3.el7                                     
  nginx-mod-mail.x86_64 1:1.16.1-3.el7                                                 
  nginx-mod-stream.x86_64 1:1.16.1-3.el7                                               
  openssl11-libs.x86_64 1:1.1.1g-3.el7                                                 

完毕！
[root@localhost ~]# 
[root@localhost ~]# cd /etc/nginx/
[root@localhost nginx]# ls
conf.d                  koi-utf             scgi_params
default.d               koi-win             scgi_params.default
fastcgi.conf            mime.types          uwsgi_params
fastcgi.conf.default    mime.types.default  uwsgi_params.default
fastcgi_params          nginx.conf          win-utf
fastcgi_params.default  nginx.conf.default
[root@localhost nginx]# 
```

修改nginx的配置文件

```
vi /etc/nginx/nginx.conf
user  root;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {

    include mime.types;
    default_type application/octet-stream;
    #include /etc/nginx/reverse-proxy.conf;
    sendfile on;
    fastcgi_intercept_errors on;
    keepalive_timeout 65;
    gzip on;
    client_max_body_size 50m; #缓冲区代理缓冲用户端请求的最大字节数,可以理解为保存到本地再传给用户
    client_body_buffer_size 256k;
    client_header_timeout 3m;
    client_body_timeout 3m;
    send_timeout 3m;
    proxy_connect_timeout 300s; #nginx跟后端服务器连接超时时间(代理连接超时)
    proxy_read_timeout 300s; #连接成功后，后端服务器响应时间(代理接收超时)
    proxy_send_timeout 300s;
    proxy_buffer_size 64k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小
    proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
    proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）
    proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘
    proxy_ignore_client_abort on; #不允许代理端主动关闭连接

    server{
        listen 9999;
        server_name 127.0.0.1;



        location / {
            alias  /root/web/;
            index welcome.html;
        }


        access_log /root/web/access.log;
        error_log  /root/web/error.log;

    }

}
```

在/root/web/目录下创建一个欢迎页面

```html
<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Document</title>
 </head>
 <body>
    使用linux 发布的 nginx 服务 搭建  web服务器
 </body>
</html>
```

> 启动nginx

```
nginx  -c  /etc/nginx/nginx.conf
```

> 重新加载配置文件

```bash
nginx -s reload
```

![img](https://jshand.gitee.io/imgs/centos/2021-05-27_114308.png)

# [25 使用docker安装MySQL](https://jshand.gitee.io/#/course/server/linux?id=_25-使用docker安装mysql)

- 安装docker服务
- 拉取mysql的镜像

```bash
[root@zhangshun ~]# docker pull mysql
Using default tag: latest
latest: Pulling from library/mysql
69692152171a: Already exists 
1651b0be3df3: Pull complete 
951da7386bc8: Pull complete 
0f86c95aa242: Pull complete 
37ba2d8bd4fe: Pull complete 
6d278bb05e94: Pull complete 
497efbd93a3e: Pull complete 
f7fddf10c2c2: Pull complete 
16415d159dfb: Pull complete 
0e530ffc6b73: Pull complete 
b0a4a1a77178: Pull complete 
cd90f92aa9ef: Pull complete 
Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest


[root@zhangshun ~]# docker images
REPOSITORY       TAG       IMAGE ID       CREATED        SIZE
mysql            latest    c0cdc95609f1   2 weeks ago    556MB

[root@zhangshun ~]# docker run --name mysql2 -p 4306:3306  -e MYSQL_ROOT_PASSWORD=root -d  mysql:5.7  --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
b3e9b5f85855f27fd5af900741edd9e223c97962d30178e9954d0f3b1cbd58ea
[root@zhangshun ~]# docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES
b3e9b5f85855   mysql:5.7             "docker-entrypoint.s…"   12 seconds ago   Up 11 seconds   33060/tcp, 0.0.0.0:4306->3306/tcp, :::4306->3306/tcp                                       mysql2

[root@zhangshun ~]# 
```

打开mysql客户端进行测试

# [26 shell编程介绍](https://jshand.gitee.io/#/course/server/linux?id=_26-shell编程介绍)

Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。

Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。

Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

## [26.1. Shell 脚本](https://jshand.gitee.io/#/course/server/linux?id=_261-shell-脚本)

Shell 脚本（shell script），是一种为 shell 编写的脚本程序。

业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。

由于习惯的原因，简洁起见，本文出现的 "shell编程" 都是指 shell 脚本编程，不是指开发 shell 自身。

下面是一个编译SpringBoot项目并重新启动的脚本

```bash
#!/bin/bash
echo 'Start the program : supply-parent-0.0.1-SNAPSHOT.jar'
echo '-------Starting-------'


#切换到项目目录
cd /root/ifs-engineering/

#调用git命令拉取项目
git pull

#调用mvn命令清理并重新打包，忽略测试
mvn clean package -DskipTests


echo '关闭上一次的进行'
echo '-------Starting-------'

#查找上一次启动的进程号
pid=`ps -ef |grep java|grep ifs-module-1.0.jar|awk '{print $2}'`
echo '*旧的应用进程 pid:'$pid

#如果存在则使用kill命令杀进程
if [ -n "$pid" ]
then
        kill -9 $pid
fi

#后台启动 jar ，并添加环境变量，将输出重定向到 nohup.log中
nohup java -jar /root/ifs-engineering/01-ifs-module/target/ifs-module-1.0.jar\
 --db.ip=127.0.0.1\
 --db.un=root\
 --db.pa=123456\
 --server.port=9999\
 >nohup.log 2>&1 &

echo '*启动成功'

#查看启动日志
tail -f nohup.log
```

## [26.2. Shell 环境](https://jshand.gitee.io/#/course/server/linux?id=_262-shell-环境)

Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。

Linux 的 Shell 种类众多，常见的有：

- Bourne Shell（/usr/bin/sh或/bin/sh）
- Bourne Again Shell（/bin/bash）
- C Shell（/usr/bin/csh）
- K Shell（/usr/bin/ksh）
- Shell for Root（/sbin/sh）

在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 **#!/bin/sh**，它同样也可以改为 **#!/bin/bash**。

\#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。

\#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。

echo 命令用于向窗口输出文本。

## [26.3运行 Shell 脚本有两种方法：](https://jshand.gitee.io/#/course/server/linux?id=_263运行-shell-脚本有两种方法：)

**1、作为可执行程序**

将上面的代码保存为 test.sh，并 cd 到相应目录：

```bash
[root@zhangshun ~]#chmod +x ./test.sh  #使脚本具有执行权限

[root@zhangshun ~]#./test.sh  #执行脚本
```

注意，一定要写成 ./test.sh，而不是 **test.sh**，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。

**2、作为解释器参数**

这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：

```bash
[root@zhangshun ~]#/bin/sh test.sh
[root@zhangshun ~]#/bin/php test.php
```

# [27. Shell 变量](https://jshand.gitee.io/#/course/server/linux?id=_27-shell-变量)

定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：

```
your_name="jshand.com"
```

注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：

-  命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
-  中间不能有空格，可以使用下划线（_）。
-  不能使用标点符号。
-  不能使用bash里的关键字（可用help命令查看保留关键字）。

有效的 Shell 变量名示例如下：

```
RUNOOB
LD_LIBRARY_PATH
_var
var2
```

无效的变量命名：

```
?var=123
user*name=runoob
```

除了显式地直接赋值，还可以用语句给变量赋值，如：

```bash
for file in `ls /etc`
或
for file in $(ls /etc)
```

以上语句将 /etc 下目录的文件名循环出来。

------

## [27.1. 使用变量](https://jshand.gitee.io/#/course/server/linux?id=_271-使用变量)

使用一个定义过的变量，只要在变量名前面加美元符号即可，如：

```bash
your_name="qinjx"
echo $your_name
echo ${your_name}
```

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：

```bash
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
```

如果不给skill变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

推荐给所有变量加上花括号，这是个好的编程习惯。

已定义的变量，可以被重新定义，如：

```bash
your_name="tom"
echo $your_name
your_name="alibaba"
echo $your_name
```

这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符（$）。

## [27.2. 只读变量](https://jshand.gitee.io/#/course/server/linux?id=_272-只读变量)

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

下面的例子尝试更改只读变量，结果报错：

```bash
#!/bin/bash
myUrl="https://www.google.com"
readonly myUrl
myUrl="https://www.jshand.com"
```

运行脚本，结果如下：

```
/bin/sh: NAME: This variable is read only.
```

## [27.3. 删除变量](https://jshand.gitee.io/#/course/server/linux?id=_273-删除变量)

使用 unset 命令可以删除变量。语法：

```
unset variable_name
```

变量被删除后不能再次使用。unset 命令不能删除只读变量。

**实例**

```
#!/bin/sh
myUrl="https://www.jshand.com"
unset myUrl
echo $myUrl
```

以上实例执行将没有任何输出。

## [27.4. 变量类型](https://jshand.gitee.io/#/course/server/linux?id=_274-变量类型)

运行shell时，会同时存在三种变量：

- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

------

## [27.5. Shell 字符串](https://jshand.gitee.io/#/course/server/linux?id=_275-shell-字符串)

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。

### [1. 单引号](https://jshand.gitee.io/#/course/server/linux?id=_1-单引号)

```bash
str='this is a string'
```

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

### [2. 双引号](https://jshand.gitee.io/#/course/server/linux?id=_2-双引号)

```bash
your_name='jshand'
str="Hello, I know you are \"$your_name\"! \n"
echo -e $str
```

输出结果为：

```
Hello, I know you are "jshand"! 
```

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

### [3.拼接字符串](https://jshand.gitee.io/#/course/server/linux?id=_3拼接字符串)

```bash
your_name="jshand"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
```

输出结果为：

```bash
hello, jshand ! hello, jshand !
hello, jshand ! hello, ${your_name} !
```

### [4.获取字符串长度](https://jshand.gitee.io/#/course/server/linux?id=_4获取字符串长度)

```bash
[root@zhangshun ~]# string="abcd"
[root@zhangshun ~]# echo ${#string} #输出 4
4
[root@zhangshun ~]# 
```

### [5.提取子字符串](https://jshand.gitee.io/#/course/server/linux?id=_5提取子字符串)

以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：

```bash
[root@zhangshun ~]# string="jshand is a great site"
[root@zhangshun ~]# echo ${string:1:4} # 输出 unoo
shan
[root@zhangshun ~]# 
```

**注意**：第一个字符的索引值为 **0**。

### [6.查找子字符串](https://jshand.gitee.io/#/course/server/linux?id=_6查找子字符串)

查找字符 **t**或 **i** 的位置(哪个字母先出现就计算哪个)：

```bash
string="gitee is a great site"
echo `expr index "$string" st`  # 输出 2
```

**注意：** 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。

------

## [27.6. Shell 数组](https://jshand.gitee.io/#/course/server/linux?id=_276-shell-数组)

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。

类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

### [1. 定义数组](https://jshand.gitee.io/#/course/server/linux?id=_1-定义数组)

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：

```
数组名=(值1 值2 ... 值n)
```

例如：

```bash
array_name=(value0 value1 value2 value3)
```

或者

```bash
array_name=(
value0
value1
value2
value3
)
```

还可以单独定义数组的各个分量：

```bash
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
```

可以不使用连续的下标，而且下标的范围没有限制。

### [2. 读取数组](https://jshand.gitee.io/#/course/server/linux?id=_2-读取数组)

读取数组元素值的一般格式是：

```
${数组名[下标]}
```

例如：

```
valuen=${array_name[n]}
```

使用 @ 符号可以获取数组中的所有元素，例如：

```
echo ${array_name[@]}
```

### [3. 获取数组的长度](https://jshand.gitee.io/#/course/server/linux?id=_3-获取数组的长度)

获取数组长度的方法与获取字符串长度的方法相同，例如：

```bash
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```

------

## [27.7.Shell 注释](https://jshand.gitee.io/#/course/server/linux?id=_277shell-注释)

### [1.# 注释](https://jshand.gitee.io/#/course/server/linux?id=_1-注释)

以 # 开头的行就是注释，会被解释器忽略。

通过每一行加一个 **#** 号设置多行注释，像这样：

```bash
#--------------------------------------------
# 这是一个注释
# author：jshand
# site：jshand.gitee.io
# slogan：学的不仅是技术，更是梦想！
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 用户配置区 结束  #####
```

如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？

每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。

### [2. 多行注释](https://jshand.gitee.io/#/course/server/linux?id=_2-多行注释)

多行注释还可以使用以下格式：

```bash
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

EOF 也可以使用其他符号:

```bash
:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

# [28. Shell echo命令](https://jshand.gitee.io/#/course/server/linux?id=_28-shell-echo命令)

Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：

```bash
echo string
```

您可以使用echo实现更复杂的输出格式控制。

## [1.显示普通字符串:](https://jshand.gitee.io/#/course/server/linux?id=_1显示普通字符串)

```bash
echo "It is a test"
```

这里的双引号完全可以省略，以下命令与上面实例效果一致：

```bash
echo It is a test
```

## [2.显示转义字符](https://jshand.gitee.io/#/course/server/linux?id=_2显示转义字符)

```bash
echo "\"It is a test\""
```

结果将是:

> "It is a test"

同样，双引号也可以省略

## [3.显示变量](https://jshand.gitee.io/#/course/server/linux?id=_3显示变量)

read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

```bash
#!/bin/sh
read name 
echo "$name It is a test"
```

以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:

```bash
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出
```

## [4.显示换行](https://jshand.gitee.io/#/course/server/linux?id=_4显示换行)

```bash
echo -e "OK! \n" # -e 开启转义
echo "It is a test"
```

输出结果：

> OK!
>
> It is a test

## [5.显示不换行](https://jshand.gitee.io/#/course/server/linux?id=_5显示不换行)

```bash
#!/bin/sh
echo -e "OK! \c" # -e 开启转义 \c 不换行
echo "It is a test"
```

输出结果：

> OK! It is a test

### [6.显示结果定向至文件](https://jshand.gitee.io/#/course/server/linux?id=_6显示结果定向至文件)

```bash
echo "It is a test" > myfile
```

### [7.原样输出字符串，不进行转义或取变量(用单引号)](https://jshand.gitee.io/#/course/server/linux?id=_7原样输出字符串，不进行转义或取变量用单引号)

```bash
echo '$name\"'
```

输出结果：

> $name"

### [8.显示命令执行结果](https://jshand.gitee.io/#/course/server/linux?id=_8显示命令执行结果)

```bash
[root@zhangshun ~]# echo `date`
Thu May 27 18:22:04 CST 2021

[root@zhangshun ~]# date
Thu May 27 18:22:05 CST 2021
```

**注意：** 这里使用的是反引号 `, 而不是单引号 '。

结果将显示当前日期

# [29.Shell 基本运算符](https://jshand.gitee.io/#/course/server/linux?id=_29shell-基本运算符)

Shell 和其他编程语言一样，支持多种运算符，包括：

- 算数运算符
- 关系运算符
- 布尔运算符
- 字符串运算符
- 文件测试运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

例如，两个数相加(**注意使用的是反引号 ` 而不是单引号 '**)：

## [29.1. 实例](https://jshand.gitee.io/#/course/server/linux?id=_291-实例)

```bash
#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"
```

执行脚本，输出结果如下所示：

```
两数之和为 : 4
```

两点注意：

- 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
- 完整的表达式要被 ``包含，注意这个字符不是常用的单引号，在 Esc 键下边。

------

## [29.2 算术运算符](https://jshand.gitee.io/#/course/server/linux?id=_292-算术运算符)

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                       | 举例                         |
| ------ | ------------------------------------------ | ---------------------------- |
| +      | 加法                                       | `expr $a + $b` 结果为 30。   |
| -      | 减法                                       | expr $a - $b` 结果为 -10。   |
| *      | 乘法                                       | expr $a * $b` 结果为 200。   |
| /      | 除法                                       | expr $b / $a` 结果为 2。     |
| %      | 取余                                       | expr $b % $a` 结果为 0。     |
| =      | 赋                                         | a=$b 将把变量 b 的值赋给 a。 |
| ==     | 相等。用于比较两个数字，相同则返回 true。  | [ $a == $b ] 返回 false。    |
| !=     | 不相等。用于比较两个数字，不相同则返回 tru | != $b ] 返回 true。          |

**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。

### [实例](https://jshand.gitee.io/#/course/server/linux?id=实例)

算术运算符实例如下：

```bash
#!/bin/bash
# author: 张金山
# url: jshand.gitee.io

a=10
b=20

val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
then
   echo "a 等于 b"
fi
if [ $a != $b ]
then
   echo "a 不等于 b"
fi
```

执行脚本，输出结果如下所示：

```bash
a + b : 30
a - b : -10
a * b : 200
b / a : 2
b % a : 0
a 不等于 b
```

> **注意：**
>
> - 乘号(*)前边必须加反斜杠()才能实现乘法运算；
> - if...then...fi 是条件语句，后续将会讲解。
> - 在 MAC 中 shell 的 expr 语法是：**$((表达式))**，此处表达式中的 "*" 不需要转义符号 "" 。

------

## [29.3 关系运算符](https://jshand.gitee.io/#/course/server/linux?id=_293-关系运算符)

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                       |
| ------ | ----------------------------------------------------- | -------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |

### [实例](https://jshand.gitee.io/#/course/server/linux?id=实例-1)

关系运算符实例如下：

```bash
#!/bin/bash
# author: 张金山
# url: jshand.gitee.io

a=10
b=20

if [ $a -eq $b ]
then
   echo "$a -eq $b : a 等于 b"
else
   echo "$a -eq $b: a 不等于 b"
fi
if [ $a -ne $b ]
then
   echo "$a -ne $b: a 不等于 b"
else
   echo "$a -ne $b : a 等于 b"
fi
if [ $a -gt $b ]
then
   echo "$a -gt $b: a 大于 b"
else
   echo "$a -gt $b: a 不大于 b"
fi
if [ $a -lt $b ]
then
   echo "$a -lt $b: a 小于 b"
else
   echo "$a -lt $b: a 不小于 b"
fi
if [ $a -ge $b ]
then
   echo "$a -ge $b: a 大于或等于 b"
else
   echo "$a -ge $b: a 小于 b"
fi
if [ $a -le $b ]
then
   echo "$a -le $b: a 小于或等于 b"
else
   echo "$a -le $b: a 大于 b"
fi
```

执行脚本，输出结果如下所示：

```bash
10 -eq 20: a 不等于 b
10 -ne 20: a 不等于 b
10 -gt 20: a 不大于 b
10 -lt 20: a 小于 b
10 -ge 20: a 小于 b
10 -le 20: a 小于或等于 b
```

------

## [29.4. 布尔运算符](https://jshand.gitee.io/#/course/server/linux?id=_294-布尔运算符)

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                     |
| ------ | --------------------------------------------------- | ---------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |

### [实例](https://jshand.gitee.io/#/course/server/linux?id=实例-2)

布尔运算符实例如下：

```bash
#!/bin/bash
# author:张金山
# url:jshand.gitee.io

a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a == $b: a 等于 b"
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
   echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo "$a 小于 5 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 5 或 $b 大于 100 : 返回 false"
fi
```

执行脚本，输出结果如下所示：

```bash
10 != 20 : a 不等于 b
10 小于 100 且 20 大于 15 : 返回 true
10 小于 100 或 20 大于 100 : 返回 true
10 小于 5 或 20 大于 100 : 返回 false
```

------

## [29.5.逻辑运算符](https://jshand.gitee.io/#/course/server/linux?id=_295逻辑运算符)

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明       | 举例                                      |
| ------ | ---------- | ----------------------------------------- |
| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false |
| \|\|   | 逻辑的 OR  | [[ $a -lt 100 || $b -gt 100 ]] 返回 true  |

### [实例](https://jshand.gitee.io/#/course/server/linux?id=实例-3)

逻辑运算符实例如下：

```bash
#!/bin/bash
# author: 张金山
# url: jshand.gitee.io

a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a == $b: a 等于 b"
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
   echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo "$a 小于 5 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 5 或 $b 大于 100 : 返回 false"
fi
```

执行脚本，输出结果如下所示：

```
返回 false
返回 true
```

------

## [29.6.字符串运算符](https://jshand.gitee.io/#/course/server/linux?id=_296字符串运算符)

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                     |
| ------ | -------------------------------------------- | ------------------------ |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | [ $a ] 返回 true。       |

### [实例](https://jshand.gitee.io/#/course/server/linux?id=实例-4)

字符串运算符实例如下：

```bash
#!/bin/bash
# author: 张金山
# url: jshand.gitee.io

a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a 等于 b"
else
   echo "$a = $b: a 不等于 b"
fi
if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi
if [ -z $a ]
then
   echo "-z $a : 字符串长度为 0"
else
   echo "-z $a : 字符串长度不为 0"
fi
if [ -n "$a" ]
then
   echo "-n $a : 字符串长度不为 0"
else
   echo "-n $a : 字符串长度为 0"
fi
if [ $a ]
then
   echo "$a : 字符串不为空"
else
   echo "$a : 字符串为空"
fi
```

执行脚本，输出结果如下所示：

```bash
abc = efg: a 不等于 b
abc != efg : a 不等于 b
-z abc : 字符串长度不为 0
-n abc : 字符串长度不为 0
abc : 字符串不为空
```

------

## [29.7.文件测试运算符](https://jshand.gitee.io/#/course/server/linux?id=_297文件测试运算符)

文件测试运算符用于检测 Unix 文件的各种属性。

属性检测描述如下：

| 操作符  | 说明                                                         | 举例                      |
| ------- | ------------------------------------------------------------ | ------------------------- |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

其他检查符：

- **-S**: 判断某文件是否 socket。
- **-L**: 检测文件是否存在并且是一个符号链接。

### [实例](https://jshand.gitee.io/#/course/server/linux?id=实例-5)

变量 file 表示文件 **/var/www/jshand/test.sh**，它的大小为 100 字节，具有 **rwx** 权限。下面的代码，将检测该文件的各种属性：

```bash
#!/bin/bash
# author: 张金山
# url: jshand.gitee.io

file="/var/www/jshand/test.sh"
if [ -r $file ]
then
   echo "文件可读"
else
   echo "文件不可读"
fi
if [ -w $file ]
then
   echo "文件可写"
else
   echo "文件不可写"
fi
if [ -x $file ]
then
   echo "文件可执行"
else
   echo "文件不可执行"
fi
if [ -f $file ]
then
   echo "文件为普通文件"
else
   echo "文件为特殊文件"
fi
if [ -d $file ]
then
   echo "文件是个目录"
else
   echo "文件不是个目录"
fi
if [ -s $file ]
then
   echo "文件不为空"
else
   echo "文件为空"
fi
if [ -e $file ]
then
   echo "文件存在"
else
   echo "文件不存在"
fi
```

执行脚本，输出结果如下所示：

```bash
文件可读
文件可写
文件可执行
文件为普通文件
文件不是个目录
文件不为空
文件存在
```

# [30.test](https://jshand.gitee.io/#/course/server/linux?id=_30test)

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

使用man命令查看test命令

```bash
TEST(1)                                                                                  User Commands                                                                                  TEST(1)

NAME
       test - check file types and compare values

SYNOPSIS
       test EXPRESSION
       test

       [ EXPRESSION ]
       [ ]
       [ OPTION

DESCRIPTION
       Exit with the status determined by EXPRESSION.

       --help display this help and exit

       --version
              output version information and exit

       An omitted EXPRESSION defaults to false.  Otherwise, EXPRESSION is true or false and sets exit status.  It is one of:

       ( EXPRESSION )
              EXPRESSION is true

       ! EXPRESSION
              EXPRESSION is false

       EXPRESSION1 -a EXPRESSION2
              both EXPRESSION1 and EXPRESSION2 are true

       EXPRESSION1 -o EXPRESSION2
              either EXPRESSION1 or EXPRESSION2 is true

       -n STRING
              the length of STRING is nonzero

       STRING equivalent to -n STRING

       -z STRING
              the length of STRING is zero

       STRING1 = STRING2
              the strings are equal

       STRING1 != STRING2
              the strings are not equal

       INTEGER1 -eq INTEGER2
              INTEGER1 is equal to INTEGER2

       INTEGER1 -ge INTEGER2
              INTEGER1 is greater than or equal to INTEGER2

       INTEGER1 -gt INTEGER2
              INTEGER1 is greater than INTEGER2

       INTEGER1 -le INTEGER2
              INTEGER1 is less than or equal to INTEGER2

       INTEGER1 -lt INTEGER2
              INTEGER1 is less than INTEGER2

       INTEGER1 -ne INTEGER2
              INTEGER1 is not equal to INTEGER2

       FILE1 -ef FILE2
              FILE1 and FILE2 have the same device and inode numbers

       FILE1 -nt FILE2
              FILE1 is newer (modification date) than FILE2

       FILE1 -ot FILE2
              FILE1 is older than FILE2

       -b FILE
              FILE exists and is block special

       -c FILE
              FILE exists and is character special

       -d FILE
              FILE exists and is a directory

       -e FILE
              FILE exists

       -f FILE
              FILE exists and is a regular file

       -g FILE
              FILE exists and is set-group-ID

       -G FILE
              FILE exists and is owned by the effective group ID

       -h FILE
              FILE exists and is a symbolic link (same as -L)

       -k FILE
              FILE exists and has its sticky bit set

       -L FILE
              FILE exists and is a symbolic link (same as -h)

       -O FILE
              FILE exists and is owned by the effective user ID

       -p FILE
              FILE exists and is a named pipe

       -r FILE
              FILE exists and read permission is granted

       -s FILE
              FILE exists and has a size greater than zero

       -S FILE
              FILE exists and is a socket

       -t FD  file descriptor FD is opened on a terminal

       -u FILE
              FILE exists and its set-user-ID bit is set

       -w FILE
              FILE exists and write permission is granted

       -x FILE
              FILE exists and execute (or search) permission is granted

       Except  for -h and -L, all FILE-related tests dereference symbolic links.  Beware that parentheses need to be escaped (e.g., by backslashes) for shells.  INTEGER may also be -l STRING,
       which evaluates to the length of STRING.

       NOTE: [ honors the --help and --version options, but test does not.  test treats each of those as it treats any other nonempty STRING.

       NOTE: your shell may have its own version of test and/or [, which usually supersedes the version described here.  Please refer to your  shell's  documentation  for  details  about  the
       options it supports.

       GNU coreutils online help: <http://www.gnu.org/software/coreutils/> Report test translation bugs to <http://translationproject.org/team/>

AUTHOR
       Written by Kevin Braunsdorf and Matthew Bradburn.

COPYRIGHT
       Copyright © 2013 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
       This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

SEE ALSO
       The full documentation for test is maintained as a Texinfo manual.  If the info and test programs are properly installed at your site, the command

              info coreutils 'test invocation'

       should give you access to the complete manual.
```

## [1. 数值测试](https://jshand.gitee.io/#/course/server/linux?id=_1-数值测试)

| 参数 | 说明           |
| ---- | -------------- |
| -eq  | 等于则为真     |
| -ne  | 不等于则为真   |
| -gt  | 大于则为真     |
| -ge  | 大于等于则为真 |
| -lt  | 小于则为真     |
| -le  | 小于等于则为真 |

**实例**

```bash
num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
```

输出结果：

> 两个数相等！

代码中的 [] 执行基本的算数运算，如：

**实例**

```
#!/bin/bash

a=5
b=6

result=$[a+b] # 注意等号两边不能有空格
echo "result 为： $result"
```

**结果为**:

```bash
result 为： 11
```

------

## [2.字符串测试](https://jshand.gitee.io/#/course/server/linux?id=_2字符串测试)

| 参数      | 说明                     |
| --------- | ------------------------ |
| =         | 等于则为真               |
| !=        | 不相等则为真             |
| -z 字符串 | 字符串的长度为零则为真   |
| -n 字符串 | 字符串的长度不为零则为真 |

**实例**

```bash
num1="ru1noob"
num2="runoob"
if test $num1 = $num2
then
    echo '两个字符串相等!'
else
    echo '两个字符串不相等!'
fi
```

**输出结果**：

> 两个字符串不相等!

## [3.文件测试](https://jshand.gitee.io/#/course/server/linux?id=_3文件测试)

| 参数      | 说明                                 |
| --------- | ------------------------------------ |
| -e 文件名 | 如果文件存在则为真                   |
| -r 文件名 | 如果文件存在且可读则为真             |
| -w 文件名 | 如果文件存在且可写则为真             |
| -x 文件名 | 如果文件存在且可执行则为真           |
| -s 文件名 | 如果文件存在且至少有一个字符则为真   |
| -d 文件名 | 如果文件存在且为目录则为真           |
| -f 文件名 | 如果文件存在且为普通文件则为真       |
| -c 文件名 | 如果文件存在且为字符型特殊文件则为真 |
| -b 文件名 | 如果文件存在且为块特殊文件则为真     |

**实例**

```bash
cd /bin
if test -e ./bash
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi
```

**输出结果**：

> 文件已存在!

另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：

**实例**

```bash
cd /bin
if test -e ./notFile -o -e ./bash
then
    echo '至少有一个文件存在!'
else
    echo '两个文件都不存在'
fi
```

**输出结果**：

> 至少有一个文件存在!

# [31. printf 命令](https://jshand.gitee.io/#/course/server/linux?id=_31-printf-命令)

printf 命令模仿 C 程序库（library）里的 printf() 程序。

printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。

printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。

printf 命令的语法：

```
printf  format-string  [arguments...]
```

## [**1. 参数说明：**](https://jshand.gitee.io/#/course/server/linux?id=_1-参数说明：)

- **format-string:** 为格式控制字符串
  - `%d` - 将参数打印为十进制整数
  - `%f` - 将参数打印为浮点数
  - `%s` - 将参数打印为字符串
  - `%x` - 将参数打印为十六进制整数
  - `%o` - 将参数打印为八进制整数
- **arguments:** 为参数列表。

```bash
$ echo "Hello, Shell"
Hello, Shell
$ printf "Hello, Shell\n"
Hello, Shell
$
```

接下来,用一个脚本来体验printf 的强大功能

```bash
#!/bin/bash
# author:张金山
# url:jshand.gitee.io

printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543
printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876
```

%s %c %d %f 都是格式替代符，**％s** 输出一个字符串，**％d** 整型输出，**％c** 输出一个字符，**％f** 输出实数，以小数形式输出。

%-10s 指一个宽度为 10 个字符（**-** 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。

%-4.2f 指格式化为小数，其中 **.2** 指保留2位小数。

```bash
#!/bin/bash
# author:张金山
# url:jshand.gitee.io

# format-string为双引号
printf "%d %s\n" 1 "abc"

# 单引号与双引号效果一样
printf '%d %s\n' 1 "abc"

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf "%s\n" abc def

printf "%s %s %s\n" a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf "%s and %d \n"
```

执行脚本，输出结果如下所示：

```bash
1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0
```

## [2.printf 的转义序列](https://jshand.gitee.io/#/course/server/linux?id=_2printf-的转义序列)

| 序列  | 说明                                                         |
| ----- | ------------------------------------------------------------ |
| \a    | 警告字符，通常为ASCII的BEL字符                               |
| \b    | 后退                                                         |
| \c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |
| \f    | 换页（formfeed）                                             |
| \n    | 换行                                                         |
| \r    | 回车（Carriage return）                                      |
| \t    | 水平制表符                                                   |
| \v    | 垂直制表符                                                   |
| \     | 一个字面上的反斜杠字符                                       |
| \ddd  | 表示1到3位数八进制值的字符。仅在格式字符串中有效             |
| \0ddd | 表示1到3位的八进制值字符                                     |

# [32.let 命令](https://jshand.gitee.io/#/course/server/linux?id=_32let-命令)

# [33.Shell 流程控制](https://jshand.gitee.io/#/course/server/linux?id=_33shell-流程控制)

和 Java、PHP 等语言不一样，sh 的流程控制不可为空，如(以下为 PHP 流程控制写法)：

```java
/**
 * @author 张金山
 * @version 1.0
 * @date 2021/5/27 19:28
 */
public class TestShell {

    public static void main(String[] args){
        int age = 10;
        if(age ==10){
            System.out.println("年龄等于10");
        }else{
            //Java 中此处可为空
        }
    }
}
```

在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个 else。

## [if else](https://jshand.gitee.io/#/course/server/linux?id=if-else)

### [fi](https://jshand.gitee.io/#/course/server/linux?id=fi)

if 语句语法格式：

```bash
if condition
then
    command1 
    command2
    ...
    commandN 
fi
```

写成一行（适用于终端命令提示符）：

```bash
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi
```

末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的。

### [if else-if else](https://jshand.gitee.io/#/course/server/linux?id=if-else-if-else)

if else-if else 语法格式：

```bash
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

以下实例判断两个变量是否相等：

**实例**

```bash
a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

**输出结果**：

> a 小于 b

if else 语句经常与 test 命令结合使用，如下所示：

**实例**

```bash
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo '两个数字相等!'
else
    echo '两个数字不相等!'
fi
```

**输出结果**：

> 两个数字相等!

------

## [for 循环](https://jshand.gitee.io/#/course/server/linux?id=for-循环)

与其他编程语言类似，Shell支持for循环。

for循环一般格式为：

```bash
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

写成一行：

```
for var in item1 item2 ... itemN; do command1; command2… done;
```

当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。

in列表是可选的，如果不用它，for循环使用命令行的位置参数。

例如，顺序输出当前列表中的数字：

**实例**

```bash

```

**输出结果**：

> The value is: 1 The value is: 2 The value is: 3 The value is: 4 The value is: 5

顺序输出字符串中的字符：

```bash
#!/bin/bash

for str in This is a string
do
    echo $str
done
```

**输出结果**：

This is a string

------

## [while 语句](https://jshand.gitee.io/#/course/server/linux?id=while-语句)

while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：

```bash
while condition
do
    command
done
```

以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加 1。运行上述脚本，返回数字 1 到 5，然后终止。

**实例**

```bash
#!/bin/bash
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done
```

运行脚本，输出：

> 1 2 3 4 5

以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。

while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按结束循环。

**实例**

```bash
echo '按下 <CTRL-D> 退出'
echo -n '输入你最喜欢的网站名: '
while read FILM
do
    echo "是的！$FILM 是一个好网站"
done
```

运行脚本，输出类似下面：

```
按下 <CTRL-D> 退出
输入你最喜欢的网站名:菜鸟教程
是的！菜鸟教程 是一个好网站
```

**关于CTRL+D、CTRL+Z、CTRL+C的区别**

1、Ctrl+C比较暴力。ctrl-c 是发送 SIGINT 信号，终止一个进程。就是发送Terminal到当前的程序，比如你正在运行一个查找功能，文件正在查找中，Ctrl+C就会强制结束当前的这个进程。

2、Ctrl+Z是发送SIGSTOP信号，挂起一个进程把当前的程序挂起。暂停执行这个程序，比如你正在mysql终端中，需要出来搞点其他的文件操作，又不想退出mysql终端（因为下次还得输入用户名密码进入，挺麻烦），于是可以ctrl+z将mysql挂起，然后进行其他操作，然后输入fg回车后就可以回来，当然可以挂起好多进程到后台，然后fg 加编号就能把挂起的进程返回到前台。当然，配合bg和fg命令进行前后台切换会非常方便。

例如:当你vi一个文件是,如果需要用shell执行别的操作,但是你又不打算关闭vi,因为你得存盘推出,你可以简单的按下ctrl+z,shell会将vi进程挂起~,当你结束了那个shell操作之后,你可以用fg命令继续vi你的文件。

3、Ctrl+D 不是发送信号，而是表示一个特殊的二进制值，表示 EOF。是发送一个exit信号，没有那么强烈，类似ctrl+C的操作，比如你从管理员root退回到你的普通用户就可以这么用。

### [无限循环](https://jshand.gitee.io/#/course/server/linux?id=无限循环)

无限循环语法格式：

```bash
while :
do
    command
done
```

或者

```bash
while true
do
    command
done
```

或者

```bash
for (( ; ; ))
```

------

## [until 循环](https://jshand.gitee.io/#/course/server/linux?id=until-循环)

until 循环执行一系列命令直至条件为 true 时停止。

until 循环与 while 循环在处理方式上刚好相反。

一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。

until 语法格式:

```
until condition
do
    command
done
```

condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。

以下实例我们使用 until 命令来输出 0 ~ 9 的数字：

**实例**

```bash
#!/bin/bash

a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
```

运行结果：

输出结果为：

> 0 1 2 3 4 5 6 7 8 9

## [case ... esac](https://jshand.gitee.io/#/course/server/linux?id=case-esac)

**case ... esac** 为多选择语句，与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。

可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。

**case ... esac** 语法格式如下：

```bash
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
```

case 工作方式如上所示，取值后面必须为单词 **in**，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。

下面的脚本提示输入 1 到 4，与每一种模式进行匹配：

**实例**

```bash
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

输入不同的内容，会有不同的结果，例如：

> 输入 1 到 4 之间的数字: 你输入的数字为: 3 你选择了 3

下面的脚本匹配字符串：

**实例**

```bash
#!/bin/sh

site="jshand"

case "$site" in
   "jshand") echo "金山老师的笔记"
   ;;
   "google") echo "Google 搜索"
   ;;
   "taobao") echo "淘宝网"
   ;;
esac
```

输出结果为：

> 金山老师的笔记

------

## [跳出循环](https://jshand.gitee.io/#/course/server/linux?id=跳出循环)

在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。

### [break命令](https://jshand.gitee.io/#/course/server/linux?id=break命令)

break命令允许跳出所有循环（终止执行后面的所有循环）。

下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。

**实例**

```bash
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
            break
        ;;
    esac
done
```

**执行以上代码**，输出结果为：

> 输入 1 到 5 之间的数字:3 你输入的数字为 3! 输入 1 到 5 之间的数字:7 你输入的数字不是 1 到 5 之间的! 游戏结束

### [continue](https://jshand.gitee.io/#/course/server/linux?id=continue)

continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

对上面的例子进行修改：

**实例**

```bash
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "游戏结束"
        ;;
    esac
done
```

行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 **echo "游戏结束"** 永远不会被执行。

# [34.Shell 函数](https://jshand.gitee.io/#/course/server/linux?id=_34shell-函数)

linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。

shell中函数的定义格式如下：

> **[** **function** **]** funname **[()]**
>
> **{**
>
> action;
>
> **[\****return** int;**]**
>
> **}**

说明：

- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

下面的例子定义了一个函数并进行调用：

**实例**

```bash
#!/bin/bash
# author:金山
# url: jshand.gitee.io

demoFun(){
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"
```

**输出结果**：

> -----函数开始执行----- 这是我的第一个 shell 函数! -----函数执行完毕-----

下面定义一个带有return语句的函数：

**实例**

```bash
#!/bin/bash
# author:金山
# url: jshand.gitee.io

funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
```

**输出类似下面**：

> 这个函数会对输入的两个数字进行相加运算... 输入第一个数字: 1 输入第二个数字: 2 两个数字分别为 1 和 2 ! 输入的两个数字之和为 3 !

函数返回值在调用该函数后通过 $? 来获得。

注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

------

## [函数参数](https://jshand.gitee.io/#/course/server/linux?id=函数参数)

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

带参数的函数示例：

**实例**

```bash
#!/bin/bash
# author:金山
# url: jshand.gitee.io

funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"

}

funWithParam 1 2 3 4 5 6 7 8 9 34 73
```

**输出结果**：

> 第一个参数为 1 ! 第二个参数为 2 ! 第十个参数为 10 ! 第十个参数为 34 ! 第十一个参数为 73 ! 参数总数有 11 个! 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !

注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| $#       | 传递到脚本或函数的参数个数                                   |
| $*       | 以一个单字符串显示所有向脚本传递的参数                       |
| $$       | 脚本运行的当前进程ID号                                       |
| $!       | 后台运行的最后一个进程的ID号                                 |
| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |
| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |
| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

# [35.Shell 输入/输出重定向](https://jshand.gitee.io/#/course/server/linux?id=_35shell-输入输出重定向)

大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

重定向命令列表如下：

| 命令            | 说明                                               |
| --------------- | -------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

> 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。

------

## [1.输出重定向](https://jshand.gitee.io/#/course/server/linux?id=_1输出重定向)

重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:

```
command1 > file1
```

上面这个命令执行command1然后将输出的内容存入file1。

注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。

**实例**

执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):

```bash
[root@zhangshun ~]# who >> users
```

执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。

你可以使用 cat 命令查看文件内容：

```bash
root     pts/0        2021-05-27 19:54 (1.62.163.124)
[root@zhangshun ~]# 
```

输出重定向会覆盖文件内容，请看下面的例子：

```bash
[root@zhangshun ~]# echo "金山老师的笔记: jshand.gitee.io" > users

[root@zhangshun ~]# cat users
金山老师的笔记: jshand.gitee.io

[root@zhangshun ~]# 
```

如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：

```bash
[root@zhangshun ~]# echo "金山老师的笔记: jshand.gitee.io" >> users

[root@zhangshun ~]# cat users
金山老师的笔记: jshand.gitee.io
金山老师的笔记: jshand.gitee.io

[root@zhangshun ~]# 
```

------

## [2. 输入重定向](https://jshand.gitee.io/#/course/server/linux?id=_2-输入重定向)

和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：

```
command1 < file1
```

这样，本来需要从键盘获取输入的命令会转移到文件读取内容。

注意：输出重定向是大于号(>)，输入重定向是小于号(<)。

**实例**

接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

```bash
[root@zhangshun ~]# wc -l users 
2 users

[root@zhangshun ~]# 
```

也可以将输入重定向到 users 文件：

```bash
[root@zhangshun ~]# wc -l <users
2 
[root@zhangshun ~]# 
```

注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。

```
command1 < infile > outfile
```

同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。

### [重定向深入讲解](https://jshand.gitee.io/#/course/server/linux?id=重定向深入讲解)

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

-  标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
-  标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
-  标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。

默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。

如果希望 stderr 重定向到 file，可以这样写：

```
$ command 2>file
```

如果希望 stderr 追加到 file 文件末尾，可以这样写：

```
$ command 2>>file
```

**2** 表示标准错误文件(stderr)。

如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：

```
$ command > file 2>&1

或者

$ command >> file 2>&1
```

如果希望对 stdin 和 stdout 都重定向，可以这样写：

```
$ command < file1 >file2
```

command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。

------

## [Here Document](https://jshand.gitee.io/#/course/server/linux?id=here-document)

Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。

它的基本的形式如下：

```
command << delimiter
    document
delimiter
```

它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。

> 注意：
>
> - 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
> - 开始的delimiter前后的空格会被忽略掉。

**实例**

在命令行中通过 wc -l 命令计算 Here Document 的行数：

```bash
$ wc -l << EOF
    欢迎来到
    金山讲堂
    www.runoob.com
EOF
3          # 输出结果为 3 行
$
```

我们也可以将 Here Document 用在脚本中，例如：

```
#!/bin/bash
# author:金山
# url: jshand.gitee.io

cat << EOF
欢迎来到
金山讲堂
www.runoob.com
EOF
```

执行以上脚本，输出结果：

```
欢迎来到
金山讲堂
www.runoob.com
```

------

## [/dev/null 文件](https://jshand.gitee.io/#/course/server/linux?id=devnull-文件)

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

```bash
$ command > /dev/null
```

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

```bash
$ command > /dev/null 2>&1
```

> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
>
> 这里的 **2** 和 **>** 之间不可以有空格，**2>** 是一体的时候才表示错误输出。

# [36.Shell 文件包含](https://jshand.gitee.io/#/course/server/linux?id=_36shell-文件包含)

和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：

```
. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
```

**实例**

创建两个 shell 脚本文件。

test1.sh 代码如下：

```bash
#!/bin/bash
# author:金山
# url:jshand.gitee.io

url="jshand.gitee.io"
```

test2.sh 代码如下：

```bash
#!/bin/bash
# author:金山
# url:jshand.gitee.io

#使用 . 号来引用test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh

echo "金山老师笔记地址：$url"
```

接下来，我们为 test2.sh 添加可执行权限并执行：

> $ chmod +x test2.sh $ ./test2.sh 金山老师笔记地址：jshand.gitee.io

> **注：**被包含的文件 test1.sh 不需要可执行权限。

# [附录：](https://jshand.gitee.io/#/course/server/linux?id=附录：)

linux 常用环境查看

查看文件系统格式

```bash
 cat /etc/fstab
```