# [1. MySql介绍](https://jshand.gitee.io/#/course/03-dbms/index?id=_1-mysql介绍)

## [1.1 什么是数据库？](https://jshand.gitee.io/#/course/03-dbms/index?id=_11-什么是数据库？)

数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。

每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。

我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。

所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。

RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：

- 1.数据以表格的形式出现
- 2.每行为各种记录名称
- 3.每列为记录名称所对应的数据域
- 4.许多的行和列组成一张表单
- 5.若干的表单组成database

------

## [1.2 RDBMS 术语](https://jshand.gitee.io/#/course/03-dbms/index?id=_12-rdbms-术语)

在我们开始学习MySQL 数据库前，让我们先了解下RDBMS的一些术语：

- **数据库:** 数据库是一些关联表的集合。
- **数据表:** 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
- **列:** 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。
- **行：**一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。
- **冗余**：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
- **外键：**外键用于关联两个表。
- **复合键**：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。
- **索引：**使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。
- **参照完整性:** 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。

## [1.3 mysql介绍](https://jshand.gitee.io/#/course/03-dbms/index?id=_13-mysql介绍)

MySQL 为关系型数据库(Relational Database Management System), 这种所谓的"关系型"可以理解为"表格"的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格:

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_192902.png)

- 表头(header): 每一列的名称;
- 列(col): 具有相同数据类型的数据的集合;
- 行(row): 每一行用来描述某条记录的具体信息;
- 值(value): 行的具体信息, 每个值必须与该列的数据类型相同;
- **键(key)**: 键的值在当前列中具有唯一性。

MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。

- MySQL 是开源的，目前隶属于 Oracle 旗下产品。
- MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
- MySQL 使用标准的 SQL 数据语言形式。
- MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。
- MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。
- MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。

### [1.3.1 系统架构](https://jshand.gitee.io/#/course/03-dbms/index?id=_131-系统架构)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_192901.png)

# [2. MySql的安装](https://jshand.gitee.io/#/course/03-dbms/index?id=_2-mysql的安装)

本篇已window 7 x64系统,mysql 5.7.31 版本为例来安装MySql。

## [2.1 下载](https://jshand.gitee.io/#/course/03-dbms/index?id=_21-下载)

访问[官网 download页面](https://downloads.mysql.com/archives/community/)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_194459.png)

## [2.2 解压](https://jshand.gitee.io/#/course/03-dbms/index?id=_22-解压)

将免安装压缩包解压到 D:\Program Files 目录，如下图所示：

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_150245.png)

## [2.3 添加到系统服务](https://jshand.gitee.io/#/course/03-dbms/index?id=_23-添加到系统服务)

将MySQL添加到系统服务中，使mysql开机启动。

以管理员的身份打开cmd并切换到 mysql的bin目录

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_150512.png)

注册为windows系统服务

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_151108.png)

```powershell
D:\>d:

D:\>cd "D:\Program Files\mysql-5.7.18-winx64\bin"

D:\Program Files\mysql-5.7.18-winx64\bin>mysqld.exe --install
```

如果出现缺少dll文件，

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_0853-1.png)

> Win7出现缺失MSVCR120.dll文件。 下载MSVCR120.dll 32和64位后放入根据系统相应位数放入C:\Windows\System32 C:\Windows\SysWOW64 应用程序无法正常启动0xc000007b 重新修复DirectX，还是报 应用程序无法正常启动0xc000007b问题

> 进入Microsoft 官网 https://www.microsoft.com/zh-CN/download/details.aspx?id=40784

## [2.4 验证mysql](https://jshand.gitee.io/#/course/03-dbms/index?id=_24-验证mysql)

启动mysql服务`services.msc`

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_150654.png)

打开服务，右键【MySQL】点击启动

![2020-11-08_151219](https://jshand.gitee.io/imgs/mysql/2020-11-08_151219.png)

使用命令行切换到bin目录 使用mysql客户端登录,显示当前数据库实例

![img](https://jshand.gitee.io/imgs/mysql/2020-11-08_151330.png)

```shell
>mysql -uroot -p
密码是 root
```

> ps: MySQL5.7之后，初始密码不在默认为空，而是随机生成的密码。

请参考文章，查找初始密码: [连接](https://www.cnblogs.com/mlgjb/p/8783497.html)

# [3. MySQL服务器的连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_3-mysql服务器的连接)

## [3.1 二进制的形式](https://jshand.gitee.io/#/course/03-dbms/index?id=_31-二进制的形式)

使用bin目录中的mysql.exe客户端，连接服务器

mysq -u root -p

```
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
```

上述错误，需要指定密码

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_095616.png)

## [3.2 图形界面](https://jshand.gitee.io/#/course/03-dbms/index?id=_32-图形界面)

Nacivate、SqlYog、[DataGrip](https://www.jetbrains.com/datagrip/)

课程使用 ：SqlYog

### [3.2.1使用SqlYOG创建连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_321使用sqlyog创建连接)

![2020-11-09_100305](https://jshand.gitee.io/imgs/mysql/2020-11-09_100305.png)

![2020-11-09_100407](https://jshand.gitee.io/imgs/mysql/2020-11-09_100407.png)

# [4.创建数据库](https://jshand.gitee.io/#/course/03-dbms/index?id=_4创建数据库)

CREATE DATABASE java1;

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_105915.png)

## [4.1 数据库的范式](https://jshand.gitee.io/#/course/03-dbms/index?id=_41-数据库的范式)

第一范式：•数据库表的每一行都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。•表的每一行包含一个实例的信息。•如果一个关系模型R的所有属性都是不可分的基本数据项，则R是第一范式的关系

第二范式：•要求数据库表中的每个实例或行必须是唯一的。为实现区分，通常需要为表加一个列，以存储各个实例的唯一标识（即主键）。•实体的属性完全依赖于主关键字：–所谓完全依赖指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。•如果关系模式R（U，F）中的所有非主属性都完全依赖于任意一个候选关键字，则称关系R 是属于第二范式的。

第三范式：•一个数据库表中不包含已在其他表中已包含的非主关键字信息。例如存在一个部门信息表，其中每个部门有部门编号DEPT_ID、部门名称、部门简介等信息。那么在员工信息表中列出的部门编号DEPT_ID后，就不能再有关于部门的其他信息，否则就会造成数据冗余。•如果关系模式R（U，F）中的所有非主属性对任何候选关键字都不存在传递信赖，则称关系R是属于第三范式的

## [4.2 表结构](https://jshand.gitee.io/#/course/03-dbms/index?id=_42-表结构)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_155529.png)

# [5.删除数据库](https://jshand.gitee.io/#/course/03-dbms/index?id=_5删除数据库)

```sql
DROP DATABASE USER;
```

# [6.选择数据库](https://jshand.gitee.io/#/course/03-dbms/index?id=_6选择数据库)

```
USE ssm
```

# [7.数据类型](https://jshand.gitee.io/#/course/03-dbms/index?id=_7数据类型)

MySQL中定义数据字段的类型对你数据库的优化是非常重要的。

MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。

## [7.1 数值类型](https://jshand.gitee.io/#/course/03-dbms/index?id=_71-数值类型)

MySQL支持所有标准SQL数值数据类型。

这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。

关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。

BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。

作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| ------------ | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |
| TINYINT      | 1 byte                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

## [7.2 日期和时间类型](https://jshand.gitee.io/#/course/03-dbms/index?id=_72-日期和时间类型)

表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。

每个时间类型有一个有效值范围和一个"零"值，当指定不合法的MySQL不能表示的值时使用"零"值。

TIMESTAMP类型有专有的自动更新特性，将在后面描述。

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| --------- | ------------- | ------------------------------------------------------------ | ------------------- | ------------------------ |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038 结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |

## [7.3 字符串类型](https://jshand.gitee.io/#/course/03-dbms/index?id=_73-字符串类型)

字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型

| 类型       | 大小                  | 用途                            |
| ---------- | --------------------- | ------------------------------- |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

> **注意**：

char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。

有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。

# [8.创建表](https://jshand.gitee.io/#/course/03-dbms/index?id=_8创建表)

使用create语句创建数据库

> 语法

| CREATE TABLE语句创建表，语法结构如下： create table 表名( 字段名1 数据类型 [约束条件], … [其他约束条件], [其他约束条件] )其他选项（例如存储引擎、字符集等选项） | | ------------------------------------------------------------ | | | | |

创建表的时候涉及到数据库引擎,[参考](https://www.jianshu.com/p/4bb9f78b4f6d)

> 实例 ： 需求创建用户表

```sql
CREATE DATABASE /*!32312 IF NOT EXISTS*/`java1` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `java1`;

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `username` varchar(50) DEFAULT NULL,
  `nickname` varchar(100) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `telephone` varchar(20) DEFAULT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `status` varchar(5) DEFAULT '1' COMMENT '0 删除的，1 正常',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

AUTO_INCREMENT 作为int主键列的修饰，自增。

COMMENT 给列添加注释

## [8.2 复制表](https://jshand.gitee.io/#/course/03-dbms/index?id=_82-复制表)

> --只存在结构，没有数据

```
create table user_bak  like user ; 
```

> -- 使用结构和数据创建表

```
CREATE TABLE user_bak_data SELECT * FROM USER
```

# [9.删除表](https://jshand.gitee.io/#/course/03-dbms/index?id=_9删除表)

> 语法:
>
> drop table 表名

> 实例

```
DROP TABLE IF EXISTS  user; 
```

# [10.插入数据](https://jshand.gitee.io/#/course/03-dbms/index?id=_10插入数据)

> 语法:
>
> INSERT INTO table [(column [, column...])] VALUES (value [, value...]);

> 实例

```js
INSERT INTO USER
    (username,nickname,birthday,telephone)

VALUE('admin','管理员','2000-01-02','17745125669');
insert  into `user`
(`id`,`username`,`nickname`,`birthday`,`telephone`,`create_time`,`status`) 
values
(1,'admin','管理员','2000-01-02','17745125669','2020-11-09 11:36:10','1'),
(2,'jshand','金山','2002-01-02','17745125669','2020-11-09 11:38:42','1'),
(3,'jshand1','金山','2002-01-02','17745125669','2020-11-09 11:38:48','1'),
(4,'jshand2','金山','2002-01-02','17745125669','2020-11-09 11:38:51','1'),
(5,'jshand4','金山','2002-01-02','17745125669','2020-11-09 11:38:56','1'),
(6,'jshand5','金山','2002-01-02','17745125669','2020-11-09 11:38:59','1'),
(7,'jshand6','金山','2002-01-02','17745125669','2020-11-09 11:38:59','1'),
(8,'jshand7','金山','2002-01-02','17745125669','2020-11-09 11:39:00','1'),
(9,'jshand8','金山','2002-01-02','17745125669','2020-11-09 11:39:00','1');
```

# [11.查询数据](https://jshand.gitee.io/#/course/03-dbms/index?id=_11查询数据)

select 列的字段 from 表名

```
SELECT    id,   username,   nickname,   birthday,   telephone,   create_time,   STATUS  FROM   USER
```

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_114148.png)

> 开发时，查询时列的枚举可以使用* 代替
>
> 不建议再程序中使用

```
SELECT   *  FROM  USER
```

## [11.1 基本用法](https://jshand.gitee.io/#/course/03-dbms/index?id=_111-基本用法)

```
SELECT     [DISTINCT]{*|column|expression [alias],...}
FROM    table;
```

> DISTINCT 去除重复

```
SELECT DISTINCT deptno FROM emp 
```

> \* 查询所有列

```
select *  from emp 
```

> column

```
SELECT ename ,sal  FROM emp 
```

> 表达式、别名

```
SELECT ename , sal , (sal+100)  别名  FROM emp 
```

## [11.2 运算符](https://jshand.gitee.io/#/course/03-dbms/index?id=_112-运算符)

### [11.2.1算术运算符](https://jshand.gitee.io/#/course/03-dbms/index?id=_1121算术运算符)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_164950.png)

算术运算符优先级 乘除优先于加减 相同优先权的表达式按照从左至右的顺序依次计算 括弧可以提高优先权，并使表达式的描述更为清晰

![img](https://jshand.gitee.io/imgs/mysql/2020-11-09_155014.png)

### [11.2.2 null运算](https://jshand.gitee.io/#/course/03-dbms/index?id=_1122-null运算)

空值NULL 空值是指一种无效的、未赋值、未知的或不可用的值。 空值不同于零或者空格。

```
select * from emp where comm is null
```

# [12.删除数据](https://jshand.gitee.io/#/course/03-dbms/index?id=_12删除数据)

## [12.1 DELETE](https://jshand.gitee.io/#/course/03-dbms/index?id=_121-delete)

> delete from 表名字 [ WHERE id = 8]

```sql
-- 整张表清除数据
DELETE FROM USER 
-- 可以使用where条件限定删除的范围
delete from user where id = 8
```

## [12.2 TRUNCATE](https://jshand.gitee.io/#/course/03-dbms/index?id=_122-truncate)

> TRUNCATE 表名

跟delete 的区别: 不会记录日志。

# [13. 更新数据](https://jshand.gitee.io/#/course/03-dbms/index?id=_13-更新数据)

> 语法
>
> update 表名
>
>  set 列名 1= 列的value 1，列名 2= 列的value 2
>
> [where id = ? ]

> 实例

```sql
update  user  
    set  nickname ='刘备1' ,
         telephone ='18404075932'
where id = 5
```

# [14.基本操作练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_14基本操作练习)

现有数据结构

```sql
CREATE TABLE `dept` (
  `deptno` int(2) NOT NULL,
  `dname` varchar(14) DEFAULT NULL,
  `loc` varchar(13) DEFAULT NULL,
  PRIMARY KEY (`deptno`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


insert  into `dept`(`deptno`,`dname`,`loc`) values (10,'ACCOUNTING','NEW YORK'),(20,'RESEARCH','DALLAS'),(30,'SALES','CHICAGO'),(40,'OPERATIONS','BOSTON');


CREATE TABLE `emp` (
  `empno` int(4) NOT NULL,
  `ename` varchar(10) DEFAULT NULL,
  `job` varchar(9) DEFAULT NULL,
  `mgr` int(4) DEFAULT NULL,
  `hiredate` date DEFAULT NULL,
  `sal` decimal(7,2) DEFAULT NULL,
  `comm` decimal(7,2) DEFAULT NULL,
  `deptno` int(2) DEFAULT NULL,
  PRIMARY KEY (`empno`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


insert  into `emp`(`empno`,`ename`,`job`,`mgr`,`hiredate`,`sal`,`comm`,`deptno`) values (1,'dog','code',7369,'2018-06-05','5000.00','5000.00',10),(7369,'SMITH','CLERK',7902,'1980-12-17','800.00',NULL,20),(7499,'ALLEN','SALESMAN',7698,'1981-02-20','1600.00','300.00',30),(7521,'WARD','SALESMAN',7698,'1981-02-22','1250.00','500.00',30),(7566,'JONES','MANAGER',7839,'1981-04-02','2975.00',NULL,20),(7654,'MARTIN','SALESMAN',7698,'1981-09-28','1250.00','1400.00',30),(7698,'BLAKE','MANAGER',7839,'1981-05-01','2850.00',NULL,30),(7788,'SCOTT','ANALYST',7566,'1987-04-19','3000.00',NULL,20),(7839,'KING','PRESIDENT',NULL,'1981-11-17','5000.00',NULL,10),(7844,'TURNER','SALESMAN',7698,'1981-09-08','1500.00','0.00',30),(7876,'ADAMS','CLERK',7788,'1987-05-23','1100.00',NULL,20),(7900,'JAMES','CLERK',7698,'1981-12-03','950.00',NULL,30),(7902,'FORD','ANALYST',7566,'1981-12-03','3000.00',NULL,20),(7934,'MILLER','CLERK',7782,'1982-01-23','1300.00',NULL,10);
```

> -- 题目1.通过子查询的方式创建一个表dept10,该表保存10号部门的员工数据。

```sql
CREATE TABLE dept10 
 SELECT 

  * FROM
    emp 
    WHERE deptno = 10 ;
```

> -- 创建与dept表相同表结构的表dtest，将dept表中部门编号在40之前的信息插入该表。

```sql
CREATE TABLE dtest  SELECT 

  * FROM
    dept 
    WHERE deptno <40 ;
```

> -- 创建与emp表结构相同的表empl，并将其部门编号为前30号的员工信息复制到empl表。

```sql
CREATE TABLE empl  SELECT 

  * FROM
    emp 
    WHERE deptno <30 ;
```

> -- 向部门表新增一个部门，部门编号为50，部门名称为HR，工作地点为SY。

```sql
INSERT INTO dept  VALUES(50,'HR','SY')
```

> -- 向员工表中新增一个员工，员工编号为8888，姓名为BOB， 岗位为CLERK，经理为号7788，入职日期为1985-03-03，薪资3000，奖金和部门为空

```sql
INSERT INTO `java1`.`emp` (
  `empno`,
  `ename`,
  `job`,
  `mgr`,
  `hiredate`,
  `sal`
) 
VALUES
  (
    '8888',
    'BOB',
    'CLERK',
    '7788',
    '1985-03-03',
    '3000'

  ) ;
```

> -- 把emp表中入职日期大于1982年1月1日之前的员工信息复制到emp_back表中

```sql
CREATE TABLE emp_back  SELECT 

  * FROM
    emp 
    WHERE hiredate < STR_TO_DATE('1982-01-01' , '%Y-%m-%d' )
```

> -- 修改工作地点在NEW YORK或CHICAGO的员工工资，工资增加500

```sql
SELECT * FROM emp 
WHERE deptno IN (
  SELECT deptno FROM dept WHERE loc ='NEW YORK' OR loc ='CHICAGO'
)


UPDATE  emp
SET sal = sal +500
WHERE deptno IN (
  SELECT deptno FROM dept WHERE loc ='NEW YORK' OR loc ='CHICAGO';
)
```

> -- 删除经理编号为7566的员工记录

```sql
 DELETE FROM  emp WHERE mgr = 7566;
```

# [15. 简单查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_15-简单查询)

可以跟在 select、update、delete语句后面进行条件限定，使用where条件

## [15.1 where条件语法](https://jshand.gitee.io/#/course/03-dbms/index?id=_151-where条件语法)

> 比较操作符

SELECT * FROM emp WHERE sal >3000

> BETWEEN...AND..

SELECT * FROM emp WHERE sal BETWEEN 3000 AND 3500

> IN（ 集合列表）

SELECT * FROM emp WHERE deptno = 10 OR deptno = 20

SELECT * FROM emp WHERE deptno IN (10,20)

> LIKE % 匹配0到多个字符， _ 有且仅有一个
>
> SELECT * FROM emp WHERE ename LIKE 'S____' SELECT * FROM emp WHERE ename LIKE 'K%'

> IS NULL

SELECT * FROM emp WHERE comm IS NULL

> LIKE 子句
>
> LIKE运算符 %与*组合使用 %代表任意字符 ，* 有且仅有一个

```
SELECT    ename
 FROM     emp
 WHERE    ename LIKE '_L%';
```

如果需要将"_"或者是"%"转义，可以使用escape 指定转义字符

SELECT * FROM emp WHERE ename LIKE '@_%' ESCAPE '@';

## [15.2 逻辑运算](https://jshand.gitee.io/#/course/03-dbms/index?id=_152-逻辑运算)

AND 逻辑与，用来连接多个条件表达式。如果每个条件表达式的结果都为TRUE，整个表达式的结果才为TRUE。

OR 逻辑或，用来连接多个条件表达式。只要有1个条件表达式的结果为TRUE，整个表达式的结果就为TRUE

NOT 逻辑非，用来对条件表达式取反。TRUE取反为FALSE，FALSE取反为TRUE。

```sql
SELECT * FROM emp WHERE ename NOT LIKE '@_%' ESCAPE '@';
```

## [15.3 条件语句练习1](https://jshand.gitee.io/#/course/03-dbms/index?id=_153-条件语句练习1)

> -- 1.查询职位为SALESMAN的员工编号、职位、入职日期。 SELECT * FROM emp WHERE job ='SALESMAN' ;

> --2.查询1985年12月31日之前入职的员工姓名及入职日期。 SELECT * FROM emp WHERE hiredate < '1985-12-21';

> -- 3.查询部门编号不在10部门的员工姓名、部门编号。 SELECT ename ,deptno FROM emp WHERE deptno <> 10;

> -- 4查询入职日期在82年至85年的员工姓名，入职日期。 SELECT ename,hiredate FROM emp WHERE hiredate BETWEEN '1982-01-01' AND '1985-12-31'

> -- 5 查询月薪在3000到5000的员工姓名，月薪。 SELECT ename,sal FROM emp WHERE sal BETWEEN 3000 AND 5000

> -- 查询部门编号为10或者20的员工姓名，部门编号。 SELECT ename ,deptno FROM emp WHERE deptno =10 OR deptno =20; SELECT ename ,deptno FROM emp WHERE deptno IN (10,20);

> -- 查询经理编号为7902, 7566, 7788的员工姓名，经理编号。 SELECT ename,mgr FROM emp WHERE mgr IN (7902,7566,7788);

## [15.4 条件语句练习2](https://jshand.gitee.io/#/course/03-dbms/index?id=_154-条件语句练习2)

> 1.查询工资超过2000并且职位是MANAGER,或者职位是SALESMAN的员工姓名、职位、工资
>
> 2.查询工资超过2000并且职位是 MANAGER或SALESMAN的员工姓名、职位、工资。
>
> 3.查询部门在10或者20，并且工资在3000到5000之间的员工姓名、部门、工资。
>
> 4.查询入职日期在81年，并且职位不是SALES开头的员工姓名、入职日期、职位。
>
> 5.查询职位为SALESMAN或MANAGER，部门编号为10或者20，姓名包含J的员工姓名、职位、部门编号。

```sql
-- 1.查询工资超过2000并且职位是MANAGER,或者职位是SALESMAN的员工姓名、职位、工资
SELECT 
  ename 姓名,
  job 职位,
  sal 工资 
FROM
  emp 
WHERE (

    sal>2000 AND job ='MANAGER'
  ) 
  OR (job ='SALESMAN' )



-- 2.查询工资超过2000并且职位是 MANAGER或SALESMAN的员工姓名、职位、工资。
SELECT 
  ename 姓名,
  job 职位,
  sal 工资 
FROM
  emp 
WHERE   sal>2000 AND ( job ='MANAGER' OR job ='SALESMAN' );



-- 3.查询部门在10或者20，并且工资在3000到5000之间的员工姓名、部门、工资。
SELECT 
  ename 姓名,
  deptno 部门,
  sal 工资 
FROM
  emp 
  WHERE deptno IN(10,20) AND sal BETWEEN 3000 AND 5000 ;


-- 4.查询入职日期在81年，并且职位不是SALES开头的员工姓名、入职日期、职位。
SELECT 
  ename 姓名,
  hiredate 入职日期,
  job 职位
FROM
  emp
  WHERE (hiredate BETWEEN '1981-01-01' AND '1981-12-31' ) AND  job NOT LIKE 'SALES%' 

-- 5.查询    职位为SALESMAN或MANAGER，部门编号为10或者20，姓名包含J的员工姓名、职位、部门编号。
SELECT 
  ename 姓名,
  job 职位,
  deptno 部门 
FROM
  emp 
WHERE (job IN ('SALESMAN','MANAGER')) 
  AND (deptno IN (10,20)) 
  AND (ename LIKE '%J%')
```

## [15.5.排序](https://jshand.gitee.io/#/course/03-dbms/index?id=_155排序)

ORDER BY子句

> SELECT [DISTINCT] { * | 列名 |表达式 [别名][,...]} FROM 表名 [WHERE 条件] [ORDER BY {列名|表达式|列别名|列序号} [ASC|DESC],…];

> 可以按照列名、表达式、列别名、结果集的列序号排序 ASC: 升序，默认值 DESC: 降序 ORDER BY 子句必须写在SELECT语句的最后

```sql
-- 列名
SELECT * FROM emp  ORDER BY mgr

-- 列名
SELECT * FROM emp  ORDER BY 2

-- 表达式
SELECT t.empno/3,  t.*   FROM emp t   ORDER BY t.empno/3

-- 别名
SELECT empno eno  FROM emp   ORDER BY eno

-- asc 默认升序，desc降序 ,多个排序条件组合
SELECT mgr,sal, empno,ename,job  FROM emp   ORDER BY mgr,sal DESC
```

### [15.5.1 排序练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_1551-排序练习)

> 1.查询部门在20或30的员工姓名，部门编号，并按照工资升序排序。 2.查询工资在2000-3000之间，部门不在10号的员工姓名，部门编号，工资，并按照部门升序，工资降序排序。 3.查询入职日期在82年至83年之间，职位以SALES或者MAN开头的员工姓名，入职日期，职位，并按照入职日期降序排序。

```sql
-- .查询部门在20或30的员工姓名，部门编号，并按照工资升序排序。
SELECT ename,deptno,sal FROM emp  WHERE deptno IN (20,30) ORDER BY sal ASC;


-- 查询工资在2000-3000之间，部门不在10号的员工姓名，部门编号，工资，并按照部门升序，工资降序排序。

SELECT ename,deptno,sal FROM emp  WHERE sal BETWEEN 2000 AND 3000 AND  deptno <>10

 ORDER BY deptno ASC ,sal DESC;

 -- 查询入职日期在82年至83年之间，
 -- 职位以SALES或者MAN开头的员工姓名，入职日期，职位，并按照入职日期降序排序。
SELECT 
  ename,
  hiredate,
  job 
FROM
  emp 
WHERE (
    hiredate BETWEEN '1981-01-01' 
    AND '1983-12-31'
  ) 
  AND (job LIKE 'SALES%' 
    OR job LIKE 'CL%')

 ORDER BY hiredate DESC;
```

## [15.6 限制记录的行数](https://jshand.gitee.io/#/course/03-dbms/index?id=_156-限制记录的行数)

imit 语句限定查询条数, 常用语分页

> 使用select语句时，经常要返回前几条或者中间某几行记录，可以使用关键字limit。语法格式如下： select 字段列表 from 数据源 limit [start,]length; 说明： 1．limit接受一个或两个整数参数。start表示从第几行记录开始输出，length表示输出的记录行数。 2．表中第一行记录的start值为0(不是 1)。

```
-- 10
SELECT * FROM emp LIMIT 10;


SELECT * FROM emp ; 

15


-- 每页显示行数 pageCount  10 
-- 页号  pageNum   
-- 总条数  total  15 
-- 总页数  total%pageCount ==0 ?   total/pageCount     : (total/pageCount)+1

-- start  (pageNum -1) * pageCount
-- length  pageCount

/**      (pageNum -1) * pageCount    pageCount
     pageNum   start               length
    1      0               10
    2     10              10
    3        20              10
    4        30              10    
*/     
-- 每5条显示一页
-- 第一页   
SELECT * FROM  emp LIMIT 0 ,5 ;
-- 第二页   
SELECT * FROM  emp LIMIT 5 ,5 ;
-- 第三页   
SELECT * FROM  emp LIMIT 10 ,5 ;
-- 第四页  没有数据  
SELECT * FROM  emp LIMIT 15 ,5 ;
```

# [16.函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_16函数)

## [16.1 函数介绍](https://jshand.gitee.io/#/course/03-dbms/index?id=_161-函数介绍)

MySQL提供了很多功能强大、方便易用的函数，在进行数据库管理以及数据的查询和操作时，帮助我们提高对数据库的管理效率

1. 单行函数
2. 多行函数

## [16.2 单行行数](https://jshand.gitee.io/#/course/03-dbms/index?id=_162-单行行数)

单行函数对单行操作 每行返回一个结果 有可能返回值与原参数数据类型不一致 单行函数可以写在SELECT、WHERE、ORDER BY子句中 有些函数没有参数，有些函数包括一个或多个参数 函数可以嵌套

> 语法: 函数名[(参数1，参数2,…)] 其中的参数可以是以下之一： 变量 列名 表达式

## [16.3数学函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_163数学函数)

ABS(x):返回x的绝对值;

SQRT(x)：返回非负数x的平方根;

PI():返回圆周率;

MOD(x,y)或%:返回x被y除的余数;

CEIL(x)、CEILING(x)：返回大于或者等于x的最小整数值；

FLOOR(x)：返回小于或者等于x的最大整数值;

ROUND(x,y):返回保留小数点后面y位，四舍五入的整数；

TRUNCATE(x,y):返回被舍弃的小数点后y位的数字x；

RAND()：每次产生不同的随机数；

SIGN(x)：返回参数的符号；

POW(x,y)和POWER(x,y)： 返回x的y次乘方的结果值；

EXP(x)：返回以e为底的x乘方后的值；

LOG(x)：返回x的自然对数，x相对于基数e的对数；

LOG10(x)：返回x的基数为10的对数；

RADIANS(x)：将参数x由角度转化为弧度；

DEGREES(x)：将参数x由弧度转化为度。

SIN(x)：返回x正弦，其中x为弧度值；

ASIN(x)返回x的反正弦，即正弦为x的值；

COS(x)：返回x的余弦；

ACOS(x)：返回x反余弦

TAN(x)：返回x的正切；

ATAN(x)返回x的反正切；

```sql
-- 1 数学运算
-- ABS(x):返回x的绝对值;
SELECT  ABS(100) , ABS(-100) 
-- Oracle  不查询表数据 select * from dual  


-- SQRT(x)：返回非负数x的平方根;

SELECT  SQRT(4),SQRT(16)


-- PI():返回圆周率;
SELECT PI()

-- MOD(x,y)或%:返回x被y除的余数;

SELECT MOD(10,3) AS mody ,10%3 AS '%Y'



-- CEIL(x)、CEILING(x)：返回大于或者等于x的最小整数值；
SELECT  CEIL(3.1),CEIL(3.2),CEIL(3.3),CEIL(3.4),CEIL(3.5),CEIL(3)

-- FLOOR(x)：返回小于或者等于x的最大整数值;
SELECT  FLOOR(3.1),FLOOR(3.2),FLOOR(3.3),FLOOR(3.4),FLOOR(3.5),FLOOR(3)


-- ROUND(x,y):返回保留小数点后面y位，四舍五入的整数；
SELECT ROUND(10.4546,3), ROUND(10.4543,3);

-- TRUNCATE(x,y):返回被舍弃的小数点后y位的数字x； 截断
SELECT TRUNCATE(10.4546,3), TRUNCATE(10.4543,3);


-- RAND()：每次产生不同的随机数； 产生0到1之间的随机数小数 double
SELECT  RAND() ,RAND() ,RAND() ,RAND() ;

-- SIGN(x)：返回参数的符号；
SELECT SIGN(-10),SIGN(10),SIGN(0),SIGN(-0) ;



-- POW(x,y)和POWER(x,y)： 返回x的y次乘方的结果值；
SELECT POW(2,2),POW(2,3),POW(2,4);



-- EXP(x)：返回以e为底的x乘方后的值；
SELECT  EXP(2) ,EXP(3) ;

-- LOG(x)：返回x的自然对数，x相对于基数e的对数；
SELECT LOG(10)
/**
LOG10(x)：返回x的基数为10的对数；

RADIANS(x)：将参数x由角度转化为弧度；

DEGREES(x)：将参数x由弧度转化为度。

SIN(x)：返回x正弦，其中x为弧度值；

ASIN(x)返回x的反正弦，即正弦为x的值；

COS(x)：返回x的余弦；

ACOS(x)：返回x反余弦

TAN(x)：返回x的正切；

ATAN(x)返回x的反正切；;
*/
```

### [16.3.1 练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_1631-练习)

> 1.写一个查询，分别计算100.456 四舍五入到小数点后第2位，第1位，整数位的值。 2.写一个查询，分别计算100.456 从小数点后第2位，第1位，整数位截断的值。

## [16.4 字符串函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_164-字符串函数)

> CHAR_LENGTH(str)：返回字符串str的所包含字符个数;
>
> LENGTH(str):返回字符串str的长度；
>
> CONCAT(s1,s2,...)： 字符串连接；
>
> CONCAT_WS(x,s1,s2,…)：字符串连接, x是其它参数的分隔符;
>
> INSERT(s1,x,len,s2) ：返回字符串s1，s1中插入字符串s2；
>
> LOWER (str)|LCASE (str)：将字符串全部转换成小写字母；
>
> UPPER(str)|UCASE(str)：将字符串全部转换成大写字母；
>
> LEFT(s,n)：返回最左边指定长度的字符；
>
> RIGHT(s,n)：返回最右边指定长度的字符；
>
> LPAD(s1,len,s2)| RPAD(s1,len,s2) ：填充字符串函数；
>
> TRIM(s1 FROM s)|LTRIM(s）|RTRIM(s):删除空格函数
>
> REPEAT(s,n)：重复生成字符串函数；
>
> SPACE(n)：返回一个由n个空格组成的字符串；
>
> REPLACE（s，s1，s2）：字符串替换函数；
>
> STRCMP(s1,s2)：比较字符串大小函数；
>
> SUBSTRING(s,n,len)：获取子串函数；
>
> LOCATE(str1,str)|POSITION(str1 IN str)|INSTR(str, str1)：匹配子串开始位置函数;
>
> REVERSE(s)：将字符串s反转；
>
> ELT(N,字符串1,字符串2,字符串3,…)：返回指定位置函数;

```sql
-- CHAR_LENGTH(str)：返回字符串str的所包含字符个数;

SELECT ename, CHAR_LENGTH(ename) FROM emp;

-- LENGTH(str):返回字符串str的长度；
-- utf 8 
SELECT ename, LENGTH(ename), LENGTH('中国'), CHAR_LENGTH('中国')FROM emp;

-- CONCAT(s1,s2,...)： 字符串连接；

SELECT empno,ename,job ,  CONCAT(empno,'--',ename,'--',job ) AS info  FROM emp;

-- CONCAT_WS(x,s1,s2,…)：字符串连接, x是其它参数的分隔符;
SELECT empno,ename,job ,  CONCAT_WS('--&--',empno,ename,job ) AS info  FROM emp;


-- INSERT(s1,x,len,s2) ：返回字符串s1，s1中插入字符串s2；
-- s1: abcdef 原始字符串
-- x:   1 position  开始插入新字符串的位置
-- len  3 len 覆盖几位(插入几位)
-- s2 : mnoqrs 标识使用次此字符串插入
SELECT INSERT('abcdef',3,2,'-mnopqrs-'),  INSERT('abcdef',5,1,'-mnopqrs-');

  -- LOWER (str)|LCASE (str)：将字符串全部转换成小写字母；

  -- UPPER(str)|UCASE(str)：将字符串全部转换成大写字母；

  SELECT ename ,LOWER(ename) ,UPPER(ename) , LOWER('I Am Jshand My Age 18') ,UPPER('I Am Jshand My Age 18'), LOWER('中国') FROM emp  ;

  -- LEFT(s,n)：返回最左边指定长度的字符；

  -- RIGHT(s,n)：返回最右边指定长度的字符；

  -- LPAD(s1,len,s2)| RPAD(s1,len,s2) ：填充字符串函数；

  SELECT ename 名字 ,
    LEFT(ename,3) 名字开头3个字母 ,RIGHT(ename,4) 名末尾4个字母,RIGHT(ename,5) 名末尾5个字母 , 

    LPAD(ename,10,'*') 名字开头10个字母    ,RPAD(ename,10,'*') 名字开头10个字母

    FROM emp 




 --  TRIM(s1 FROM s)|LTRIM(s）|RTRIM(s):删除空格函数
 SELECT 
 TRIM(LEADING '，' FROM '，，barxxx'),
 TRIM(LEADING ' '  FROM  '  abc def  ' )



SELECT CHAR_LENGTH('  abc def  ' ) len ,
    CONCAT('-','  abc def  ' ,'-') str  ,
    CONCAT('-',TRIM('  abc def  ' ),'-') TRIM ,
    CONCAT('-' , TRIM(LEADING ' '  FROM  '  abc def  ' )  ,'-') lead ,
    CONCAT('-',LTRIM('  abc def  ' ),'-') LTRIM,
    CONCAT('-',RTRIM('  abc def  ' ),'-') LTRIM


 -- REPEAT(s,n)：重复生成字符串函数；
SELECT REPEAT("abc-",3) 


-- SPACE(n)：返回一个由n个空格组成的字符串；
  SELECT  CONCAT('start-',SPACE(10),'-end')

 -- REPLACE（s，s1，s2）：字符串替换函数；
SELECT 'my name is xxx '   ,REPLACE('my name is xxx ','m','M')



-- STRCMP(s1,s2)：比较字符串大小函数；
-- a b c d e f g h i j k --ASCII   (compare java) 
SELECT STRCMP('abc','abe'), STRCMP('bbc','abe'),  STRCMP('abe','abc'),STRCMP('abc','abc')


-- SUBSTRING(s,n,len)：获取子串函数；
SELECT   'abcdef' ,
    SUBSTRING('abcdef',3),
    SUBSTRING('abcdef',3,4)


-- LOCATE(str1,str)|POSITION(str1 IN str)|INSTR(str, str1)：匹配子串开始位置函数;
-- mysql 单引号   Java 定义sql  String sql = “   select ‘’  ”
SELECT POSITION("cd" IN "abcdef") AS MatchPosition; 

SELECT 'abcdef' ,
    LOCATE('cd','abcdef') ,
    LOCATE('cd','abcdef',1) ,
    LOCATE('cd','abcdef',2) ,
    LOCATE('cd','abcdef',3) ,
     LOCATE('cd','abcdef',5) ,
     POSITION('cd' IN 'abcdef'),
    INSTR('abcdef','cd')


  -- REVERSE(s)：将字符串s反转
  SELECT  'abcdef' ,REVERSE('abcdef')




-- ELT(N,字符串1,字符串2,字符串3,…)：返回指定位置字符串函数;

SELECT ELT(3,'这','是','一a','个','测','试');
```

### [16.4.1 练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_1641-练习)

1. 显示所有员工姓名的前三个字符
2. 显示正好为5个字符的员工的姓名，工资，部门号
3. 写一个查询,用首字母大写，其它字母小写显示雇员的 ename，显示名字的长度，并给每列一个适当的标签，条件是满足所有雇员名字的开始字母是J、A 或 M 的雇员，并对查询结果按雇员的ename升序排序。（提示：使用length、substr）
4. 查询员工姓名中中包含大写或小写字母A的员工姓名。 显示所有员工的姓名,用a替换所有"A"
5. 查询部门编号为10或20，入职日期在81年5月1日之后，并且姓名中包含大写字母A的员工姓名，员工姓名长度
6. 查询每个职工的编号,姓名，工资 要求将查询到的数据按照一定的格式合并成一个字符串. 前10位：编号,不足部分用*填充,左对齐 中间10位：姓名，不足部分用*填充,左对齐 后10位：工资，不足部分用*填充,右对齐

```sql
-- 1. 显示所有员工姓名的前三个字符
SELECT ename , SUBSTRING(ename,1,3) FROM emp


-- 2. 显示正好为5个字符的员工的姓名，工资，部门号
SELECT ename , sal  工资, deptno  部门号 ,LENGTH(ename) FROM emp WHERE LENGTH(ename) = 5

-- 3. 写一个查询,
-- 用首字母大写，其它字母小写显示雇员的 ename，
-- 显示名字的长度，
-- 并给每列一个适当的标签，
SELECT 
  ename 名字,
  CONCAT(
    UPPER(SUBSTRING(ename, 1, 1)),
    LOWER(SUBSTRING(ename, 2))
  ) 名字2,
  UPPER(SUBSTRING(ename, 1, 1)) FIRST,
  LOWER(SUBSTRING(ename, 2)) other,
  LENGTH(ename) 名字长度 
FROM
  emp 
  WHERE UPPER(SUBSTRING(ename, 1, 1)) IN ('J','A','M')
  ORDER BY ename



-- 4. 查询员工姓名中中包含大写或小写字母A的员工姓名。
-- 显示所有员工的姓名,用a替换所有"A"
SELECT ename , REPLACE(ename,'A','a') FROM emp WHERE LOWER(ename) LIKE '%a%'


-- 5. 查询部门编号为10或20，入职日期在81年5月1日之后，并且姓名中包含大写字母A的员工姓名，
-- 员工姓名长度
SELECT * FROM emp  WHERE deptno IN (10,20) AND hiredate > '1981-05-01' AND ename LIKE '%A%' 


-- 6. 查询每个职工的编号,姓名，工资
   要求将查询到的数据按照一定的格式合并成一个字符串.

   前10位：编号,不足部分用\*填充,左对齐
   中间10位：姓名，不足部分用\*填充,左对齐
   后10位：工资，不足部分用\*填充,右对齐

SELECT 
CONCAT( 
  LPAD(empno,10,'*') ,
  RPAD(ename ,10,'*') ,
  RPAD(sal,10,'*')  ) 
FROM
  emp ;
```

## [16.5 日期和时间函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_165-日期和时间函数)

CURDATE()和CURRENT_DATE() ：获取当前日期函数;

NOW()：返回服务器的当前日期和时间；

CURTIME(）：返回当前时间，只包含时分秒；

UTC_DATE(）：返回世界标准时间日期函数；

UTC_TIME()：返回世界标准时间函数；

TIMEDIFF(expr1, expr2)：返回两个日期相减相差的时间数；

DATEDIFF(expr1, expr2)：返回两个日期相减相差的天数；

DATE_ADD(date,INTERVAL expr type):日期加上一个时间间隔值；

DATE_SUB(date,INTERVAL expr type):日期减去一个时间间隔值；

DATE(date)、TIME(date)、YEAR（date）：选取日期时间的各个部分：

EXTRACT(unit FROM date)：从日期中抽取出某个单独的部分或组合；

DAYOFWEEK(date) 、DAYOFMONTH(date) 、DAYOFYEAR(date):返回日期在一周、一月、一年中是第几天

DAYNAME、MONTHNAME：返回日期的星期和月份名称；

DATE_FORMAT(date,format)：格式化日期；

TIME_FORMATE(time,formate）：格式化时间；

```sql
CURDATE()和CURRENT_DATE() ：获取当前日期函数;
NOW()：返回服务器的当前日期和时间；
CURTIME(）：返回当前时间，只包含时分秒；

SELECT NOW() , CURDATE() ,CURTIME()
UTC_DATE(）：返回世界标准时间日期函数；
UTC_TIME()：返回世界标准时间函数；


-- UTC_DATE
SELECT UTC_DATE() ,UTC_TIME() 

-- TIMEDIFF(expr1, expr2)：返回两个日期相减相差的时间数；
-- DATEDIFF(expr1, expr2)：返回两个日期相减相差的天数；

SELECT  DATEDIFF('2020-11-10','2020-10-10')
SELECT  TIMEDIFF('15:05:01','16:05:01')

-- DATE_ADD(date,INTERVAL expr type):日期加上一个时间间隔值；
-- select DATE_ADD(now(),'INTERVAL  1 Day')

SELECT NOW(), DATE_ADD(NOW(),INTERVAL 2 DAY), DATE_ADD(NOW(),INTERVAL 2 YEAR)


-- DATE_FORMAT 
SELECT  DATE_FORMAT(NOW(),'%Y')
```

## [16.6 流程控制函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_166-流程控制函数)

IF(表达式？ true（<>0 <> null） ，false)

SELECT sal , IF(sal>=3000,'高薪','码农') FROM emp ORDER BY sal

CASE 分支

```sql
SELECT sal ,CASE sal 
    WHEN 800 THEN '第一档'
    WHEN 2000 THEN '第2档'
    WHEN 4000 THEN '第3档'
    ELSE '中间的薪水'
      END 
     FROM emp  ORDER BY sal;


SELECT sal ,CASE  
    WHEN sal>=800 AND sal<2000 THEN '第一档'
    WHEN sal>=2000 AND sal<4000  THEN '第2档'
    ELSE '第3档'
      END 
     FROM emp  ORDER BY sal;
```

> IFNULL IFNULL(expr1,expr2)，如果expr1的值为null，则返回expr2的值，如果expr1的值不为null，则返回expr1的值。

```
SELECT ename ,sal, comm , IFNULL(comm,0) FROM emp
```

> NULLIF(expr1,expr2)，如果expr1=expr2成立，那么返回值为null，否则返回值为expr1的值。

```
SELECT ename ,sal, comm , IFNULL(comm,0) ,NULLIF(comm,0) ,  FROM emp
```

## [16.7 其他函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_167-其他函数)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_090210.png)

```sql
SELECT DATABASE(),VERSION(),USER();

-- *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B
SELECT PASSWORD('root');


-- *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B
SELECT * FROM mysql.user ;

-- Md5
SELECT MD5('root');

SELECT LENGTH('900150983cd24fb0d6963f7d28e17f72')
```

# [17.高级查询(多表连接)](https://jshand.gitee.io/#/course/03-dbms/index?id=_17高级查询多表连接)

## [17.1 多表连接介绍](https://jshand.gitee.io/#/course/03-dbms/index?id=_171-多表连接介绍)

什么是连接 连接是在多个表之间通过一定的连接条件，使表之间发生关联，进而能从多个表之间获取数据。 语法为：

> SELECT table1.column, table2.column FROM table1, table2 WHERE table1.column1 = table2.column2;

> 在 WHERE子句中书写连接条件。 如果在多个表中出现相同的列名，则需要使用表名作为来自该表的列名的前缀。 N个表相连时，至少需要N－1个连接条件。

## [17.2连接类型](https://jshand.gitee.io/#/course/03-dbms/index?id=_172连接类型)

1.  等值连接
2. 非等值连接

> 笛卡尔积是： 第一个表中的所有行和第二个表中的所有行都发生连接。 笛卡尔积在下列情况产生： 连接条件被省略 连接条件是无效的 为了避免笛卡尔积的产生，通常需要在WHERE子句中包含一个有效的连接条件。

## [17.3 等值连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_173-等值连接)

1. 限制歧义列名
2. 使用表的别名

> 在用到多个表时可以使用表名作前缀来限定列； 通过使用表前缀可以提高性能； 通过使用列的别名可以区分来自不同表但是名字相同的列；

练习

> -- 1.写一个查询，显示所有员工姓名，部门编号，部门名称。 SELECT e.ename 员工姓名, d.deptno 部门编号 , d.dname 部门名称。 FROM emp e ,dept d WHERE e.`deptno` = d.`deptno`
>
> -- 2.写一个查询，显示所有工作在CHICAGO并且奖金不为空的员工姓名，工作地点，奖金 SELECT e.ename 员工姓名, d.loc 工作地点 , e.comm 奖金 FROM emp e ,dept d WHERE e.`deptno` = d.`deptno` AND d.loc ='CHICAGO' AND e.comm IS NOT NULL
>
> -- 3.写一个查询，显示所有姓名中含有A字符的员工姓名，工作地点。 SELECT e.ename 员工姓名, d.loc 工作地点 FROM emp e ,dept d WHERE e.`deptno` = d.`deptno` AND e.`ename` LIKE '%A%';

## [17.4 多表连接的写法](https://jshand.gitee.io/#/course/03-dbms/index?id=_174-多表连接的写法)

1.分析要查询的列都来自于哪些表，构成FROM子句;

2.分析这些表之间的关联关系，如果表之间没有直接关联关系，而是通过另一个中间表关联，则也要在FROM子句中补充中间关联表;

3.接下来在WHERE子句中补充表之间的关联关系，通常N个表，至少要有N-1个关联关系;

4.分析是否还有其它限制条件，补充到WHERE子句的表关联关系之后，作为限制条件;

5.根据用户想要显示的信息，补充SELECT子句。

6.分析是否有排序要求，如果排序要求中还涉及到其它表，则也要进行第2步补充排序字段所在的表，并且添加表之间的关联关系;

## [17.5 自身连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_175-自身连接)

也叫自连接，是一个表通过某种条件和本身进行连接的一种方式，就如同多个表连接一样。

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_095436.png)

> 自身连接练习
>
> 有如下菜单表，请查询所有子菜单项目的名称，url ，创建时间，以及上级菜单的名称

```sql
CREATE TABLE `menu` (
  `menu_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '菜单id',
  `menu_name` varchar(100) DEFAULT NULL COMMENT '菜单名称',
  `url` varchar(100) DEFAULT NULL COMMENT '菜单url',
  `parent_id` int(11) DEFAULT NULL COMMENT '上级菜单id',
  `active` int(11) DEFAULT '1' COMMENT '是否有效，1 有效，0 失效',
  `createtime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4;



insert  into `menu`(`menu_id`,`menu_name`,`url`,`parent_id`,`active`,`createtime`) values (1,'MySQL介绍','/course/03-dbms/index?id=_1-mysql介绍',NULL,1,'2021-08-25 11:19:48'),(2,'rdbms-术语','/course/03-dbms/index?id=_12-rdbms-术语',1,1,'2021-08-25 11:20:21'),(3,'mysql介绍','/course/03-dbms/index?id=_13-mysql介绍',1,1,'2021-08-25 11:20:46'),(4,'mysql的安装','/course/03-dbms/index?id=_2-mysql的安装',NULL,1,'2021-08-25 11:21:24'),(5,'下载','/course/03-dbms/index?id=_21-下载',4,1,'2021-08-25 11:21:34'),(6,'解压','/course/03-dbms/index?id=_22-解压',4,1,'2021-08-25 11:21:46'),(7,'添加到系统服务','/course/03-dbms/index?id=_23-添加到系统服务',4,1,'2021-08-25 11:22:00');
```

> 答案：

```sql
select 
  m.`menu_name`,
  m.`url`,
  m.`createtime`,

  pm.`menu_name` 
from
  menu m,
  menu pm 
where m.`parent_id` = pm.`menu_id` 
```

## [17.6 ANSI SQL](https://jshand.gitee.io/#/course/03-dbms/index?id=_176-ansi-sql)

ANSI SQL：1999标准的连接语法 mysql 除了上述自己的连接语法外，同时支持美国国家标准协会（ANSI）的SQL：1999标准的连接语法。

### [17.6.1 交叉连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_1761-交叉连接)

> cross join

```sql
SELECT * FROM emp , dept ;

SELECT * FROM emp CROSS JOIN dept;
```

### [17.6.2 自然连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_1762-自然连接)

自然连接是对两个表之间相同名字和数据类型的列进行的等值连接； 如果两个表之间相同名称的列的数据类型不同，则会产生错误； 使用NATURAL JOIN子句来完成。

```sql
SELECT * FROM emp , dept  WHERE emp.`deptno` = dept.`deptno`

SELECT * FROM emp NATURAL JOIN dept
```

### [17.6.3 USING子句](https://jshand.gitee.io/#/course/03-dbms/index?id=_1763-using子句)

自然连接是使用所有名称和数据类型相匹配的列作为连接条件，而USING子句可以指定用某个或某几个相同名字和数据类型的列作为连接条件。

```sql
SELECT     e.ename,e.ename,e.sal,deptno,d.loc 
FROM       emp e JOIN dept d USING (deptno) 
```

> 使用USING子句创建连接时，应注意以下几点： 如果有若干个列名称相同但数据类型不同，自然连接子句可以用USING子句来替换，以指定产生等值连接的列。 如果有多于一个列都匹配的情况，使用USING子句只能指定其中的一列。 USING子句中的用到的列不能使用表名和别名作为前缀。 NATURAL JOIN子句和USING子句是相互排斥的，不能同时使用。

### [17.6.4 on 子句](https://jshand.gitee.io/#/course/03-dbms/index?id=_1764-on-子句)

自然连接条件基本上是具有相同列名的表之间的等值连接； 如果要指定任意连接条件,或指定要连接的列，则可以使用ON子句； 用ON将连接条件和其它检索条件分隔开，其它检索条件写在WHERE子句； ON子句可以提高代码的可读性。

```sql
SELECT * FROM emp JOIN dept ON emp.`deptno` = dept.`deptno`
```

### [inner join](https://jshand.gitee.io/#/course/03-dbms/index?id=inner-join)

```sql
 SELECT 
  w.*,
  mgr.ename 
FROM
    emp w 
  INNER JOIN 
    emp mgr 
 ON w.mgr = mgr.empno 
```

### [17.6.5 外连接](https://jshand.gitee.io/#/course/03-dbms/index?id=_1765-外连接)

在多表连接时，可以使用外部连接来查看哪些行,按照连接条件没有被匹配上。 左外连接以FROM子句中的左边表为基表，该表所有行数据按照连接条件无论是否与右边表能匹配上，都会被显示出来。 右外连接以FROM子句中的右边表为基表，该表所有行数据按照连接条件无论是否与左边表能匹配上，都会被显示出来

> 左外连接

查询所有雇员姓名，部门编号，部门名称，包括没有部门的员工也要显示出来

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_094434.png)

> 右外连接

查询所有雇员姓名，部门编号，部门名称，包括没有员工的部门也要显示出来

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_094542.png)

## [17.8.练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_178练习)

> 使用SQL-99写法，完成如下练习

1. 创建一个员工表和部门表的交叉连接。
2. 使用自然连接，显示入职日期在80年5月1日之后的员工姓名，部门名称，入职日期
3. 使用USING子句，显示工作在CHICAGO的员工姓名，部门名称，工作地点
4. 使用ON子句，显示工作在CHICAGO的员工姓名，部门名称，工作地点，薪资等级
5. 使用左连接，查询每个员工的姓名，经理姓名，没有经理的King也要显示出来。
6. 使用右连接，查询每个员工的姓名，经理姓名，没有经理的King也要显示出来。
7. 显示员工SMITH的姓名，部门名称，直接上级名称
8. 显示员工姓名，部门名称，工资，工资级别，要求工资级别大于4级。
9. 显示员工KING和FORD管理的员工姓名及其经理姓名。
10. 显示员工姓名，参加工作时间，经理名，参加工作时间，要求参加时间比经理早。

> 答案：

```sql
-- 1创建一个员工表和部门表的交叉连接。
SELECT 
  * 
FROM
  emp 
  CROSS JOIN dept 

-- 2 使用自然连接，显示入职日期在80年5月1日之后的员工姓名，部门名称，入职日期
SELECT 
  ename 员工姓名,
  dname 部门名称,
  hiredate 入职日期 
FROM
  emp NATURAL 
  JOIN dept 
WHERE hiredate > '1980-05-01' 

-- 3 使用USING子句，显示工作在CHICAGO的员工姓名，部门名称，工作地点
SELECT 
  ename 员工姓名,
  dname 部门名称,
  loc 工作地点 
FROM
  emp 
  JOIN dept USING (deptno) 
WHERE loc = 'CHICAGO' 

-- 4 使用ON子句，显示工作在CHICAGO的员工姓名，部门名称，工作地点，薪资等级

SELECT 
  ename 员工姓名,
  dname 部门名称,
  loc 工作地点 ,
  sal 
FROM
  emp 
  JOIN dept ON emp.deptno = dept.deptno
WHERE loc = 'CHICAGO' 

-- 5 使用左连接，查询每个员工的姓名，经理姓名，没有经理的King也要显示出来。

SELECT 
  e1.ename 员工的姓名,
  e2.ename 经理姓名 
FROM
  emp e1 
  LEFT JOIN emp e2 
    ON e1.mgr = e2.empno ;


-- 5 使用右连接，查询每个员工的姓名，经理姓名，没有经理的King也要显示出来。
SELECT 
  e1.ename 经理姓名 ,
  e2.ename 员工的姓名
FROM
  emp e1 
  RIGHT JOIN emp e2 
    ON e1.empno = e2.mgr ;


-- 6显示员工SMITH的姓名，部门名称，直接上级名称
SELECT 
  e1.ename,d.dname,e2.ename
FROM
  emp e1 
  INNER JOIN dept d 
    ON e1.deptno = d.deptno 
  INNER JOIN emp e2 
    ON e1.mgr = e2.empno 
  WHERE e1.ename ='SMITH'


-- 7 显示员工姓名，部门名称，工资，工资级别，要求工资级别大于3级。
SELECT ename,dname,sal,
(CASE WHEN sal<1000 THEN '第1级'
     WHEN sal>=1000 AND sal<2000 THEN  '第2级'
     WHEN sal>=2000 AND sal<3000 THEN  '第3级'
     ELSE '第4级'
     END) LEVEL
FROM emp  JOIN dept ON emp.deptno = dept.deptno



-- 8 显示员工KING和FORD管理的员工姓名。

SELECT 
  mgr.ename '领导的姓名',
  employee.ename '员工的姓名' 
FROM
  emp mgr 
  JOIN emp employee 
    ON mgr.empno = employee.mgr 
ORDER BY mgr.ename 



-- 9 显示员工姓名，参加工作时间，经理名，参加工作时间，要求参加时间比经理早。
SELECT 
employee.ename '员工的姓名' ,
employee.hiredate ,
  mgr.ename '领导的姓名',
  mgr.hiredate 

FROM emp employee

  JOIN   emp mgr 
    ON employee.mgr = mgr.empno 
    WHERE employee.hiredate < mgr.hiredate 
ORDER BY employee.ename 
```

# [18 高级查询(分组函数)](https://jshand.gitee.io/#/course/03-dbms/index?id=_18-高级查询分组函数)

## [18.1分组函数概述](https://jshand.gitee.io/#/course/03-dbms/index?id=_181分组函数概述)

请思考如下问题？ 查询所有员工的每个月工资总和，平均工资？ 查询工资最高和最低的工资是多少？ 查询公司的总人数？ 查询有奖金的总人数？

分组函数是对数据行的集合进行操作并按组给出一个结果，这个结果可直接输出，或者用来做判断条件

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_101950.png)

## [18.1 为什么使用分组函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_181-为什么使用分组函数)

单行函数和分组函数区别

分组函数是对表中一组记录进行操作，每组只返回一个结果，即首先要对表记录进行分组，然后再进行操作汇总，每组返回一个结果，分组时可能是整个表分为一组，也可能根据条件分成多组。 分组函数常用到以下五个函数：

1. MIN
2. MAX
3. SUM
4. AVG
5. COUNT

## [18.2 分组函数](https://jshand.gitee.io/#/course/03-dbms/index?id=_182-分组函数)

> MIN函数和MAX函数
>
> MIN和MAX函数主要是返回每组的最小值和最大值。
>
> MIN([DISTINCT|ALL] column|expression)
>
> MAX([DISTINCT|ALL] column|expression)
>
> MIN和MAX可以用于任何数据类型
>
> 查询入职日期最早和最晚的日期

> SUM函数和AVG函数
>
> SUM和AVG函数分别返回每组的总和及平均值。
>
> SUM([DISTINCT|ALL] column|expression)
>
> AVG([DISTINCT|ALL] column|expression)
>
> SUM和AVG函数都是只能够对数值类型的列或表达式操作。

> 需求1：员工中工资最小(min)的值,最大max,求平均工资avg，求总工资sum（）

```
SELECT 
  MAX(sal) 最高工资,
  MIN(sal) 最低工资,
  AVG(sal) 平均工资,
  SUM(sal) 总工资 
FROM
  emp 
```

> COUNT函数
>
> COUNT函数的主要功能是返回满足条件的每组记录条数。
>
> COUNT( *|{[DISTINCT|ALL] column|expression})

> 组函数中DISTINCT
>
> DISTINCT会消除重复记录后再使用组函数

```sql
-- 总条数 15  count(*) 15 , COUNT(1)
SELECT COUNT(*) FROM emp 
-- 配合分页查询 ，查询总条数
SELECT COUNT(1) FROM emp 
```

> 除了COUNT（*）,count(常量) 之外，其它所有分组函数都会忽略列中的空值，然后再进行计算 null值不会计算
>
> 在分组函数中使用IFNULL函数，IFNULL 函数可以使分组函数强制包含含有空值的记录

### [18.2.1 练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_1821-练习)

1. 查询部门20的员工，每个月的工资总和及平均工资。

2. 查询工作在CHICAGO的员工人数，最高工资及最低工资。

3. 查询员工表中一共有几种岗位类型。

   答案

```sql
-- 1. 查询部门20的员工，每个月的工资总和及平均工资。

SELECT SUM(sal) 工资总和,AVG(sal) 平均工资 FROM emp WHERE deptno = 20



-- 2. 查询工作在CHICAGO的员工人数，最高工资及最低工资。
SELECT 
COUNT(1) 人数 ,
  MAX(sal) 最高工资,
  MIN(sal) 最低工资 
FROM
  emp 
  JOIN dept 
    ON emp.deptno = dept.deptno 
WHERE loc = 'CHICAGO' 


-- 3. 查询员工表中一共有几种岗位类型。
SELECT COUNT(DISTINCT job) FROM emp 
```

## [18.3 GROUP BY子句](https://jshand.gitee.io/#/course/03-dbms/index?id=_183-group-by子句)

通过 GROUP BY 子句可将表中满足WHERE条件的记录按照指定的列划分成若干个小组 其中GROUP BY子句指定要分组的列,

> 查询每个部门的编号，平均工资,最大工资、最小工资，部门人数

```sql
SELECT deptno , MAX(sal) ,MIN(sal),AVG(sal) ,COUNT(1)  FROM emp GROUP BY deptno 
```

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_111153.png)

GROUP BY 可以使用多个字段进行分组

```sql
 SELECT   deptno, job, SUM(sal)
 FROM     emp
GROUP BY deptno, job;
```

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_111215.png)

### [18.3.1 group by 练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_1831-group-by-练习)

1. 查询每个部门的部门编号，部门名称，部门人数，最高工资，最低工资，工资总和，平均工资。
2. 查询每个部门，每个岗位的部门编号，部门名称，岗位名称，部门人数，最高工资，最低工资，工资总和，平均工资。
3. 查询每个经理所管理的人数，经理编号，经理姓名，要求包括没有经理的人员信息。

```sql
-- 1. 查询每个部门的部门编号，部门名称，部门人数，最高工资，最低工资，工资总和，平均工资。


select 
  dept.deptno,
  dname,
  count(1) 部门人数,
  max(sal) 最高工资,
  min(sal) 最低工资,
  sum(sal) 工资总和,
  avg(sal)  平均工资
from
  emp 
  join dept 
    on emp.`deptno` = dept.`deptno` 
group by dept.deptno ,dname  




-- 2. 查询每个部门，每个岗位的部门编号，部门名称，岗位名称及对应的人数、最高工资、最低工资、工资总和、平均工资。
SELECT 
  dept.deptno,
  dname,
  job,
  COUNT(1) 部门人数,
  MAX(sal) 最高工资,
  MIN(sal) 最低工资,
  SUM(sal) 工资总和,
  AVG(sal)  平均工资
FROM
  emp 
  JOIN dept 
    ON emp.`deptno` = dept.`deptno` 
GROUP BY dept.deptno,   dname  ,job


-- 3. 查询每个经理所管理的人数，经理编号，经理姓名，要求包括没有经理的人员信息。
select mgr.empno , mgr.ename , count(1) 人数  from emp mgr left join emp e1  on mgr.empno =  e1.mgr
group by mgr.empno 
```

## [18.4 HAVING子句](https://jshand.gitee.io/#/course/03-dbms/index?id=_184-having子句)

使用 HAVING 子句限制组 记录已经分组. 使用过组函数. 与 HAVING 子句匹配的结果才输出

```sql
-- 按照部门分组，每个部门自高工资大于4000的部门的最高工资
SELECT 
  deptno,
  MAX(sal) 
FROM
  emp 
GROUP BY deptno 
HAVING MAX(sal) > 4000 
```

## [18.5 SELECT语句执行过程](https://jshand.gitee.io/#/course/03-dbms/index?id=_185-select语句执行过程)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_115554.png)

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_114936.png)

1. 在基础表上过滤， where条件生效，针对的 是单行数据过滤
2. 在过滤之后的数据上分组，group by
3. 可以在分组的基础上，过滤 having 子句生效
4. 枚举select 中的字段
5. order by子句生效，针对查询结果排序

## [18.7 练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_187-练习)

1. 查询部门人数大于2的部门编号，部门名称，部门人数。
2. 查询部门平均工资大于2000，且人数大于2的部门编号，部门名称，部门人数，部门平均工资，并按照部门人数升序排序。

> 答案:

```sql
-- 1.查询部门人数大于2的部门编号，部门名称，部门人数。
SELECT 
  dept.deptno,
  dname,
  COUNT(1) 
FROM
  dept,
  emp 
WHERE dept.deptno = emp.deptno 
GROUP BY dept.deptno,
  dname 
HAVING COUNT(1) > 3 

-- 2.查询部门平均工资大于2000，且人数大于2的部门编号，部门名称，部门人数，部门平均工资，
-- 并按照部门人数升序排序。

SELECT 
  dept.deptno,
  dname,
  COUNT(1) ,
  AVG(sal)
FROM
  dept,
  emp 
WHERE dept.deptno = emp.deptno 
GROUP BY dept.deptno,
  dname 
HAVING COUNT(1) > 3  AND AVG(sal) > 2000 
```

## [18.6 子查询概述](https://jshand.gitee.io/#/course/03-dbms/index?id=_186-子查询概述)

子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从 [MySQL](http://c.biancheng.net/mysql/) 4.1 开始引入，在 SELECT 子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。

子查询中常用的操作符有 ANY（SOME）、ALL、IN 和 EXISTS。

子查询可以添加到 SELECT、UPDATE 和 DELETE 语句中，而且可以进行多层嵌套。子查询也可以使用比较运算符，如“<”、“<=”、“>”、“>=”、“！=”等。

### [子查询中常用的运算符](https://jshand.gitee.io/#/course/03-dbms/index?id=子查询中常用的运算符)

#### [1) IN子查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_1-in子查询)

结合关键字 IN 所使用的子查询主要用于判断一个给定值是否存在于子查询的结果集中。其语法格式为：

<表达式> [NOT] IN <子查询>

语法说明如下。

- `<表达式>`：用于指定表达式。当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。
- `<子查询>`：用于指定子查询。这里的子查询只能返回一列数据。对于比较复杂的查询要求，可以使用 SELECT 语句实现子查询的多层嵌套。

#### [2) 比较运算符子查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_2-比较运算符子查询)

比较运算符所使用的子查询主要用于对表达式的值和子查询返回的值进行比较运算。其语法格式为：

<表达式> {= | < | > | >= | <= | <=> | < > | != } { ALL | SOME | ANY} <子查询>

语法说明如下。

- `<子查询>`：用于指定子查询。
- `<表达式>`：用于指定要进行比较的表达式。
- `ALL`、`SOME` 和 `ANY`：可选项。用于指定对比较运算的限制。其中，关键字 ALL 用于指定表达式需要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较关系时，会返回 TRUE，否则返回 FALSE；关键字 SOME 和 ANY 是同义词，表示表达式只要与子查询结果集中的某个值满足比较关系，就返回 TRUE，否则返回 FALSE。

#### [3) EXIST子查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_3-exist子查询)

关键字 EXIST 所使用的子查询主要用于判断子查询的结果集是否为空。其语法格式为：

EXIST <子查询>

若子查询的结果集不为空，则返回 TRUE；否则返回 FALSE。

子查询可以嵌于以下SQL子句中：

1. WHERE子句
2. HAVING子句
3. FROM子句

## [18.7单行子查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_187单行子查询)

子查询只返回一行一列 使用单行运算符

![img](https://jshand.gitee.io/imgs/mysql/2020-11-11_144300.png)

> 练习
>
> 1.查询入职日期最早的员工姓名，入职日期
>
> 2.查询工资比SMITH工资高并且工作地点在CHICAGO的员工姓名，工资，部门名称
>
> 3.查询入职日期比20部门入职日期最早的员工还要早的员工姓名，入职日期
>
> 4.查询部门人数大于所有部门平均人数的的部门编号，部门名称，部门人数

> 答案：

```sql
-- 1.查询入职日期最早的员工姓名，入职日期
SELECT ename 员工姓名 ,hiredate 入职日期 FROM  emp WHERE hiredate = (SELECT MIN(hiredate) FROM emp  )


-- 2.查询工资比MARTIN工资高并且工作地点在CHICAGO的员工姓名，工资，部门名称
SELECT 
  * 
FROM
  emp 
  INNER JOIN dept 
    ON emp.deptno = dept.deptno 
WHERE sal > (SELECT sal FROM emp WHERE ename ='MARTIN')
  AND loc = 'CHICAGO' 


-- 3.查询入职日期比30部门入职日期最早的员工还要早的员工姓名，入职日期
SELECT 
  ename 员工姓名,
  hiredate 入职日期 
FROM
  emp 
WHERE hiredate < 
  (SELECT 
    MIN(hiredate) 
  FROM
    emp 
  WHERE deptno = 30)

-- 4.查询部门人数大于所有部门平均人数的的部门编号，部门名称，部门人数
SELECT 
  dept.deptno  ,dname  ,COUNT(1)
FROM
  emp 
  INNER JOIN dept 
    ON emp.deptno = dept.deptno 
    GROUP BY   dept.deptno  ,dname 
    HAVING COUNT(1) > (   SELECT COUNT(deptno)/COUNT(DISTINCT deptno) FROM emp     )  
```

## [18.8多行子查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_188多行子查询)

多行子查询 子查询返回记录的条数 可以是一条或多条。 和多行子查询进行比较时，需要使用多行操作符，多行操作符包括： IN ANY ALL

> IN操作符和以前介绍的功能一致，判断是否与子查询的任意一个返回值相同。

> ANY的使用 ANY：表示和子查询的任意一行结果进行比较，有一个满足条件即可。 < ANY：表示小于子查询结果集中的任意一个，即小于最大值就可以。
>
> ANY：表示大于子查询结果集中的任意一个，即大于最小值就可以。
>
> = ANY：表示等于子查询结果中的任意一个，即等于谁都可以，相当于IN。

> ALL的使用 ALL：表示和子查询的所有行结果进行比较，每一行必须都满足条件。
>
> < ALL:表示小于子查询结果集中的所有行，即小于最小值。
>
> > ALL:表示大于子查询结果集中的所有行，即大于最大值。
>
> = ALL :表示等于子查询结果集中的所有行,即等于所有值，通常无意义。

> 练习

1. 查询入职日期比10部门任意一个员工晚的员工姓名、入职日期，不包括10部门员工
2. 查询入职日期比20部门所有员工晚的员工姓名、入职日期，不包括10部门员工
3. 查询职位和10部门任意一个员工职位相同的员工姓名，职位，不包括10部门员工

> 答案:

```sql
-- 1.查询入职日期比10部门任意一个员工晚的员工姓名、入职日期，不包括10部门员工

SELECT 
  * 
FROM
  emp 
WHERE deptno <> 10 
  AND hiredate > ANY 
  (SELECT 
    hiredate 
  FROM
    emp 
  WHERE deptno = 10)


-- 2.查询入职日期比20部门所有员工晚的员工姓名、入职日期，不包括20部门员工
SELECT 
  * 
FROM
  emp 
WHERE deptno <> 20 
  AND hiredate > ALL 
  (SELECT 
    hiredate 
  FROM
    emp 
  WHERE deptno = 20)

-- 3.查询职位和10部门任意一个员工职位相同的员工姓名，职位，不包括10部门员工

SELECT 
  ename, job  
FROM
  emp 
WHERE deptno <> 10 
AND job = ANY (SELECT job  FROM emp WHERE deptno = 10 )
```

## [18.9 在FROM子句中使用子查询](https://jshand.gitee.io/#/course/03-dbms/index?id=_189-在from子句中使用子查询)

> 查询比自己部门平均工资高的员工姓名，工资，部门编号，部门平均工资

```sql
SELECT 
  ename,
  sal,
  emp.deptno,
  b.salavg 
FROM
  emp,
  (SELECT 
    deptno,
    AVG(sal) salavg 
  FROM
    emp 
  GROUP BY deptno) b 
WHERE emp.deptno = b.deptno 
  AND emp.sal > b.salavg 
```

## [18.10. exists not Exists](https://jshand.gitee.io/#/course/03-dbms/index?id=_1810-exists-not-exists)

> 查询存在 SELEMAN职位的部门编号、名称、所在地

## [18.11 练习](https://jshand.gitee.io/#/course/03-dbms/index?id=_1811-练习)

```sql
CREATE TABLE `detail` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `pname` varchar(100) DEFAULT NULL COMMENT '商品名称',
  `price` decimal(6,2) DEFAULT NULL COMMENT '单价',
  `count` int(11) DEFAULT NULL COMMENT '数量',
  `amount` decimal(6,2) DEFAULT NULL COMMENT '商品总金额',
  `order_num` varchar(100) DEFAULT NULL COMMENT '订单编号',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4;


insert  into `detail`(`id`,`pname`,`price`,`count`,`amount`,`order_num`) values (1,'苹果手机','5000.05',1,'5000.05','T00001'),(2,'通讯话费','100.00',2,'200.00','T00001'),(3,'富士苹果','5.00',3,'15.00','T00002'),(4,'华为手机','4000.00',2,'8000.00','T00002'),(5,'红牛饮料','5.00',10,'50.00','T00003');


DROP TABLE IF EXISTS `myorder`;

CREATE TABLE `myorder` (
  `order_num` varchar(100) NOT NULL COMMENT '订单号',
  `ctime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '下单时间',
  `amount` decimal(6,2) DEFAULT NULL COMMENT '订单总金额',
  PRIMARY KEY (`order_num`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;


insert  into `myorder`(`order_num`,`ctime`,`amount`) values ('T00001','2021-08-26 15:14:53','100.02'),('T00002','2021-08-26 15:14:56','5000.80'),('T00003','2021-08-26 15:15:01','300.20'),('T00004','2021-08-26 15:15:09','500.90'),('T00005','2021-08-26 15:15:35','0.00');
```

# [19.视图](https://jshand.gitee.io/#/course/03-dbms/index?id=_19视图)

## [视图概述](https://jshand.gitee.io/#/course/03-dbms/index?id=视图概述)

> 限制其它用户对数据库表的访问,因为视图可以有选择性的显示数据库表的一部分； 容易实现复杂的查询； 对于相同的数据可以产生不同的视图；

## [视图分类](https://jshand.gitee.io/#/course/03-dbms/index?id=视图分类)

视图分为简单视图和复杂视图，最基本差别在DML操作上

## [创建试图](https://jshand.gitee.io/#/course/03-dbms/index?id=创建试图)

```sql
create view 查询语句

CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] 
VIEW view_name [(column_list)] 
AS select_statement
 [WITH [CASCADED | LOCAL] CHECK OPTION]
```

OR REPLACE：如果所创建的视图已经存在，该选项表示修改原视图的定义；

view_name ：视图的名称；

column_list ：列名，列名的数量必须和视图所对应查询语句的列数量相等；

select_statement ：一条完整的SELECT语句；

WITH CHECK OPTION：一个约束条件，通过视图所插入或修改的数据行必须满足视图所定义的查询；

ALGORITHM子句是可选的，它表示使用何种算法来处理视图。此外，它并不属于标准SQL的一部分，而是MySQL对标准SQL进行的功能扩展。ALGORITHM可以设置三个值：MERGE、TEMPTABLE或UNDEFINED。如果没有ALGORITHM子句，则默认值为UNDEFINED(未定义的)。

对于MERGE，会将引用视图的语句的文本与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。 对于TEMPTABLE，视图的结果将被置于临时表中，然后使用它执行语句。 对于UNDEFINED，MySQL将选择所要使用的算法。如果可能，它倾向于MERGE而不是TEMPTABLE，这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。 [WITH [CASCADED | LOCAL] CHECK OPTION]是可选的。该选项中的CASCADED为默认值，LOCAL CHECK OPTION用于在可更新视图中防止插入或更新行，此选项一般不使用。

示例：

> 表请参考，18.11章节

```sql
CREATE  OR REPLACE VIEW  v_queryorder (a,b) AS
SELECT 
  myorder.order_num,
  SUM(COUNT) 
FROM
  detail 
  INNER JOIN myorder 
    ON detail.order_num = myorder.order_num 
GROUP BY myorder.order_num ;
SELECT  *  FROM v_queryorder;
```

> 例：创建一个视图v_emp10，通过该视图只能查看10号部门的员工编号，员工姓名，职位。

```sql
-- 例：创建一个视图v_emp10，通过该视图只能查看10号部门的员工编号，员工姓名，职位。
CREATE OR REPLACE VIEW v_emp10 (NO, NAME, WORK) AS 
SELECT 
  empno,
  ename,
  job 
FROM
  emp 
WHERE deptno = 10 ;
DESC v_emp10
Field    Type        Null    Key    Default    Extra
no        int(4)        NO        \N    
name    varchar(10)    YES        \N    
work    varchar(9)    YES        \N    
```

## [创建试图练习](https://jshand.gitee.io/#/course/03-dbms/index?id=创建试图练习)

1.创建一个视图，通过该视图可以查询到工资在2000-5000内并且姓名中包含有A的员工编号，姓名，工资。

2.通过上述创建的视图查询数据

```sql
/***

1.创建一个视图，通过该视图可以查询到工资在2000-5000内并且姓名中包含有A的员工编号，姓名，工资。

2.通过上述创建的视图查询数据
**/
CREATE OR REPLACE VIEW  emp_sal (eno,NAME,salary)  AS 
SELECT empno ,ename ,sal FROM emp WHERE sal BETWEEN 2000 AND  5000 AND ename LIKE '%A%'

SELECT * FROM emp_sal;
```

## [复杂试图的创建](https://jshand.gitee.io/#/course/03-dbms/index?id=复杂试图的创建)

创建视图时，在子查询中使用列的别名

例：创建一个视图，通过该视图可以查看每个部门的名称，最低工资，最高工资，平均工资

> 复杂试图的创建练习

1.创建一个视图，通过该视图可以查询到工作在NEW YORK和CHICAGO的员工编号，姓名，部门编号，入职日期。

2.创建一个视图，通过该视图可以查询到每个部门的部门名称及最低工资。

3.通过如上视图，查询每个部门工资最低的员工姓名及部门名称

## [修改试图](https://jshand.gitee.io/#/course/03-dbms/index?id=修改试图)

用 CREATE OR REPLACE VIEW子句修改视图empvu10，为每个列添加别名。

CREATE VIEW子句中别名的顺序必须和内部查询中的列的顺序一一对应。

## [视图上执行DML操作](https://jshand.gitee.io/#/course/03-dbms/index?id=视图上执行dml操作)

在简单视图上可以执行 DML 操作；

您可以通过视图删除基表中数据，只要视图中不出现以下情况：

- Group 函数；
- GROUP BY 子句；
- DISTINCT 关键字；

您可以通过视图修改基表中数据，只要视图中不出现以下情况：

- GROUP函数、
- GROUP BY子句，
- DISTINCT关键字；
- 使用表达式定义的列；

您可以通过视图向基表插入数据，只要视图中不出现以下情况：

- GROUP函数、GROUP BY子句，DISTINCT关键字；
- 使用表达式定义的列；
- 基表中未在视图中选择的其它列定义为非空并且没有默认值；

如果要确保在视图上执行的DML操作仅限于一定的范围，便可使用WITH CHECK OPTION子句；

在视图中任何修改部门编号的操作都会失败，因为这违反了 WITH CHECK OPTION约束。

## [删除试图](https://jshand.gitee.io/#/course/03-dbms/index?id=删除试图)

删除视图并不会删除数据，因为视图是基于数据库中的基表的虚表。

```sql
DROP VIEW view;
```

# [20.索引](https://jshand.gitee.io/#/course/03-dbms/index?id=_20索引)

## [索引简介](https://jshand.gitee.io/#/course/03-dbms/index?id=索引简介)

索引是一种特殊的数据库结构，可以用来快速查询数据库表中的特定记录。索引是提高数据库性能的重要方式。MySQL中，所有的数据类型都可以被索引。

索引由数据库表中一列或多列组合而成，其作用是提高对表中数据的【查询】速度。

索引是创建在表上的，是对数据库表中一列或多列的值进行【排序】的一种结构。

索引可以提高查询的速度。通过索引，查询数据时可以【不必读完记录的所有信息】，而只是查询索引列。

索引的优点是可以提高检索数据的速度，这是创建索引的最主要的原因；对于有依赖关系的子表和父表之间的联合查询时，可以提高查询速度；使用分组和排序子句进行数据查询时，同样可以显著节省查询中分组和排序的时间。

索引的缺点是创建和维护索引需要耗费时间，耗费时间的数量随着数据量的增加而增加；索引需要占用物理空间，每一个索引要占一定的物理空间；增加、删除和修改数据时，要动态的维护索引，造成数据的维护速度【降低】了。

## [索引分类](https://jshand.gitee.io/#/course/03-dbms/index?id=索引分类)

- 普通索引
- 惟一性索引
- 全文索引
- 单列索引
- 多列索引
- 空间索引

## [创建索引](https://jshand.gitee.io/#/course/03-dbms/index?id=创建索引)

创建索引是指在某个表的一列或多列上建立一个索引，以便提高对表的访问速度。创建索引有三种方式，这三种方式分别是：

- 创建表的时候创建索引
- 在已经存在的表上创建索引
- 使用ALTER TABLE语句来创建索引

### [创建表的时候创建索引](https://jshand.gitee.io/#/course/03-dbms/index?id=创建表的时候创建索引)

创建表的时候可以直接创建索引，这种方式最简单、方便。其基本形式如下： CREATE TABLE 表名 ( 属性名 数据类型 [完整性约束条件], 属性名 数据类型 [完整性约束条件], … 属性名 数据类型 [UNIQUE | FULLTEXT | SPATIAL] INDEX | KEY [别名](属性名1 [(长度)] [ASC | DESC]) );

```sql
--普通索引
Create table index1(
 Id int,
 Name varchar(20),
 Sex boolean,
 Index(id)
);
创建唯一性索引
Create table index2(
 Id int unique,
 Name varchar(20),
 Unique index index2_id(id asc)
);
```

> 创建全文索引只能创建在char,varchar或text类型的字段上，而且，现在只有MyISAM存储引擎支持全文索引。

```sql
Create table index3(
  Id int,
  Info varchar(20),
  Fulltext index index3_info(info)
)engine=myisam;
```

> 创建单列索引

```sql
Create table index4(
 Id int,
 Subject varchar(30),
 Index index4_st(subject(10))
);
```

> 创建多列索引

```sql
Create table index5(
  Id int,
  Name varchar(20),
  Sex char(4),
  Index index5_ns(name,sex)
);
```

使用多列索引时一定要特别注意，只有使用了索引中的第一个字段时才会触发索引。如果没有使用索引中的第一个字段，那么这个多列索引就不会起作用。

> 创建空间索引

```sql
Create table index6(
 Id int,
 Space geometry not null,
 Spatial index index6_sp(space)
)engine=myisam;
```

> 创建空间索引时，表的存储引擎必须是myisam类型，而且索引字段必须有非空约束。空间数据类型包括geometry,point,linestring和polygon类型等。平时很少用到。

### [在已经存在的表上创建索引](https://jshand.gitee.io/#/course/03-dbms/index?id=在已经存在的表上创建索引)

在已经存在的表上，可以直接为表上的一个或几个字段创建索引。基本形式如下： CREATE [ UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (属性名 [ (长度) ] [ ASC | DESC] ); 创建普通索引 创建惟一性索引 创建全文索引 创建单列索引 创建多列索引 创建空间索引

```sql
CREATE TABLE t_index7(
  Id INT PRIMARY KEY,
  NAME VARCHAR(20)
);

CREATE UNIQUE INDEX  uname_constant ON t_index7(`NAME`) 
```

### [用ALTER TABLE语句来创建索引](https://jshand.gitee.io/#/course/03-dbms/index?id=用alter-table语句来创建索引)

在已经存在的表上，可以通过ALTER TABLE语句直接为表上的一个或几个字段创建索引。基本形式如下： ALTER TABLE 表名 ADD [ UNIQUE | FULLTEXT | SPATIAL ] INDEX
索引名（属性名 [ (长度) ] [ ASC | DESC]）; 其中的参数与上面的两种方式的参数是一样的 创建普通索引 创建惟一性索引 创建全文索引 创建单列索引 创建多列索引 创建空间索引

## [删除索引](https://jshand.gitee.io/#/course/03-dbms/index?id=删除索引)

删除索引是指将表中已经存在的索引删除掉。一些不再使用的索引会降低表的更新速度，影响数据库的性能。对于这样的索引，应该将其删除。 对应已经存在的索引，可以通过DROP语句来删除索引。基本形式如下： DROP INDEX 索引名 ON 表名 ;

## [索引的设计原则](https://jshand.gitee.io/#/course/03-dbms/index?id=索引的设计原则)

为了使索引的使用效率更高，在创建索引的时候必须考虑在哪些字段上创建索引和创建什么类型的索引。索引的设计原则如下： 选择惟一性索引 为经常需要排序、分组和联合操作的字段建立索引 为常作为查询条件的字段建立索引 限制索引的数目 尽量使用数据量少的索引 尽量使用前缀来索引 删除不再使用或者很少使用的索引

# [21.使用alter语句修改表结构](https://jshand.gitee.io/#/course/03-dbms/index?id=_21使用alter语句修改表结构)

```sql
CREATE TABLE t_index8(
  Id INT ,
  NAME VARCHAR(20),
  address VARCHAR(100)
);
-- INDEX  关键字标识 索引 
ALTER  TABLE  t_index8  ADD   UNIQUE   INDEX    uname_alter(NAME(20) ) ;

-- 添加address 字段
SELECT * FROM t_index8;

-- 1 备份数据 生成insert 语句
-- 2 删除表
-- 3 重新创建表（带着新增的字段）
DROP TABLE t_index8;

CREATE TABLE t_index8(
  Id INT ,
  NAME VARCHAR(20),
  address VARCHAR(100)
);

-- 使用之前备份的sql 还原数据
INSERT  INTO `t_index8`(`Id`,`NAME`) VALUES (1,'aaa'),(2,'bbb'),(3,'ccc'),(4,'ddd'),(5,'eee');

-- 使用alter 语句添加字段 , ctime datetime
ALTER  TABLE  t_index8  ADD  COLUMN    ctime DATETIME  ;


SELECT * FROM t_index8


-- 将address 修改成 int
ALTER  TABLE  t_index8  MODIFY  COLUMN    address INT  ;
```

# [22.数据库权限](https://jshand.gitee.io/#/course/03-dbms/index?id=_22数据库权限)

通过网络连接服务器的客户对MySQL数据库的访问由权限表内容来控制。这些表位于MySQL数据库中，并在第1次安装MySQL的过程中初始化。权限表共有6个表：user、db、host、tables_priv、 columns_priv和procs_priv。 当MySQL服务启动时，会首先读取MySQL中的权限表，并将表中的数据装入内存。当用户进行存取操作时，MySQL会根据这些表中的数据做相应的权限控制。

- IP :访问数据库ip地址
- 用户 :访问数据库的用户
- 数据库： 访问哪个数据库
- 表的权限: (查询、修改、插入、杉树)
- 字段
- 存储过程的权限

```
-- 系统权限表
SELECT * FROM USER ;
SELECT * FROM db;
SELECT * FROM columns_priv;
SELECT * FROM tables_priv;
SELECT * FROM procs_priv;
```

## [权限的执行机制](https://jshand.gitee.io/#/course/03-dbms/index?id=权限的执行机制)

为了确保数据库的安全性与完整性，系统并不希望每个用户可以执行所有的数据库操作。当MySQL允许一个用户执行各种操作时，它将首先核实用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。 MySQL的访问控制分为两个阶段： 连接核实阶段 请求核实阶段

### [连接核实阶段](https://jshand.gitee.io/#/course/03-dbms/index?id=连接核实阶段)

当用户试图连接MySQL服务器时，服务器基于用户提供的信息来验证用户身份，如果不能通过身份验证，服务器会完全拒绝该用户的访问。如果能够通过身份验证，则服务器接受连接，然后进入第2个阶段等待用户请求。 MySQL使用user表中的3个字段（Host、User和Password）进行身份检查，服务器只有在用户提供主机名、用户名和密码并与user表中对应的字段值完全匹配时才接受连接。新版本中Password字段名改为authentication_string。

### [请求核实阶段](https://jshand.gitee.io/#/course/03-dbms/index?id=请求核实阶段)

一旦连接得到许可，服务器进入请求核实阶段。在这一阶段，MySQL服务器对当前用户的每个操作都进行权限检查，判断用户是否有足够的权限来执行它。用户的权限保存在user、db、host、tables_priv或columns_priv权限表中。 在MySQL权限表的结构中，user表在最顶层，是全局级的。下面是db表和host表，它们是数据库层级的。最后才是tables_priv表和columns_priv表，它们是表级和列级的。低等级的表只能从高等级的表得到必要的范围或权限。 确认权限时，MySQL首先检查user表，如果指定的权限没有在user表中被授权，MySQL服务器将检查db表和host表，在该层级的SELECT权限允许用户查看指定数据库的所有表的数据。如果在该层级没有找到限定的权限，则MySQL继续检查tables_priv表以及columns_priv表。如果所有权限表都检查完毕，依旧没有找到允许的权限操作，MySQL服务器将返回错误信息，用户操作不能执行，操作失败。

![img](https://jshand.gitee.io/imgs/mysql/2021-08-27_145926.png)

## [用户创建](https://jshand.gitee.io/#/course/03-dbms/index?id=用户创建)

创建新用户

使用CREATE USER语句创建新用户。 执行CREATE USER或GRANT语句时，服务器会有相应的用户权限表，添加或修改用户及其权限。 CREATE USER语句的基本语法格式如下。

CREATE USER user [IDENTIFIED BY [PASSWORD]'password'] [,user[IDENTIFIED BY [PASSWORD]'password']][,…];

```sql
-- 创建数据库用户  -- 数据库中保存的密码 *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B 
CREATE USER myuser IDENTIFIED  BY 'root';

SELECT * FROM USER;

CREATE USER myuser2@'192.168.0.102' IDENTIFIED  BY 'root';

CREATE USER myuser3@'%' IDENTIFIED  BY 'root';
```

## [使用grant语句创建用户并授权](https://jshand.gitee.io/#/course/03-dbms/index?id=使用grant语句创建用户并授权)

创建新用户 使用GRANT语句创建新用户。 GRANT语句不仅可创建新用户，还可以在创建的同时对用户授权。GRANT语句还可以指定用户的其他特点，如安全连接、限制使用服务器资源等。使用GRANT语句创建新用户时必须有GRANT权限。 其基本语法格式如下。 GRANT priv_type ON database.table TO user [IDENTIFIED BY [PASSWORD] 'password'] [, user [IDENTIFIED BY [PASSWORD] 'password']] [,…] [WITH GRANT OPTION];

```

```

## [删除用户](https://jshand.gitee.io/#/course/03-dbms/index?id=删除用户)

```
-- 删除用户
--  myuser2  只有  192.168.0.102 
-- DROP USER 'myuser2' 会报错  Operation DROP USER failed for 'myuser2'@'%'
DROP USER 'myuser2'@'192.168.0.102';

--  针对不用ip 可以设置不同密码
CREATE USER myuser5@'192.168.0.102' IDENTIFIED  BY 'root1';
CREATE USER myuser5@'192.168.0.103' IDENTIFIED  BY 'root2';
```

## [修改用户](https://jshand.gitee.io/#/course/03-dbms/index?id=修改用户)

```sql
修改用户名
使用RENAME USER语句修改用户。
基本语法格式如下。
RENAME USER old_user TO new_user,
                [, old_user TO new_user] [,…];
将用户haha的名字分别修改为haha2。
mysql> rename user haha@localhost to haha2@localhost;
```

## [修改密码](https://jshand.gitee.io/#/course/03-dbms/index?id=修改密码)

```sql
修改密码
使用SET语句修改密码。
基本语法格式如下。
SET  PASSWORD [FOR user]= PASSWORD('newpassword');
将用户king的密码修改为queen1。
SET PASSWORD FOR ‘king’@‘localhost’ =PASSWORD(‘queen1');
将root用户的密码修改为123456。
    SET PASSWORD =PASSWORD('123456');
```

## [收回权限](https://jshand.gitee.io/#/course/03-dbms/index?id=收回权限)

```sql
收回所有权限。其基本语法如下。
REVOKE ALL PRIVILEGES,GRANT OPTION
FROM 'username'@'hostname'[,'username'@'hostname'][,…n];

使用REVOKE语句收回grantUser用户的的所有权限，包括GRANT权限。
    mysql> revoke all privileges,grant option from grantUser@localhost;
```

## [查看权限](https://jshand.gitee.io/#/course/03-dbms/index?id=查看权限)