# 数据结构与算法

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第一章-基本数据结构)第一章 基本数据结构

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、线性表)一、线性表

线性表是最常用且最简单的一种数据结构，它是n个数据元素的有限序列，他是【紧凑连续的存储】，因此可以通过索引随机访问。

实现线性表的方式一般有两种：

- 一种是使用**数组**存储线性表的元素，即用一组**连续的存储单元**依次存储线性表的数据元素。
- 一种是使用**链表**存储线性表的元素，链表的存储单元可以是连续的，也可以是不连续的。

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_1、数组)1、数组

![image-20220318151617656](https://www.ydlclass.com/doc21xnv/assets/image-20220318151617656.da371a96.png)

更多的内容在这里看：https://ydlclass.com/doc21xnv/javase/array

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_2、链表)2、链表

![image-20220318151536158](https://www.ydlclass.com/doc21xnv/assets/image-20220318151536158.872d0fc0.png)

更多的内容在这里看：https://ydlclass.com/doc21xnv/javase/OOP/#_11%E3%80%81%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7%E9%93%BE%E8%A1%A8

单向链表的节点的抽象：

```kotlin
class Node<E> {
    E item;
    Node<E> next;

    //构造函数
    Node(E element) {
       this.item = element;
       this.next = null;
   }
}
```

双向链表的节点的抽象：

```java
class Node<E> {

    E item;
    Node<E> next;
    Node<E> prev;

    //构造函数
    Node(E element) {
       this.item = element;
       this.next = null;
       this.prev = null;
   }
}
```

**循环链表**：主要是链表的最后一个节点指向第一个节点，整体构成一个链环。

![image-20220318151827555](https://www.ydlclass.com/doc21xnv/assets/image-20220318151827555.3f220d95.png)

**双向链表**：主要是节点中包含两个指针部分，一个指向前驱元，一个指向后继元，JDK中LinkedList集合类的实现就是双向链表。

![image-20220318151730507](https://www.ydlclass.com/doc21xnv/assets/image-20220318151730507.d5c0bd70.png)

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#二、栈与队列)二、栈与队列

栈（Stack）和队列（Queue）是两种操作受限的线性表。

这种受限表现在：

- 栈的插入和删除操作只允许在表的尾端进行（在栈中成为“栈顶”），满足“FILO：First In Last Out”；
- 队列只允许在表尾插入数据元素，在表头删除数据元素,满足“First In First Out”。

java基础中讲过，此处不在多做讲解：

https://ydlclass.com/doc21xnv/javase/OOP/#_12%E3%80%81%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#三、树)三、树

![image-20220318151445436](https://www.ydlclass.com/doc21xnv/assets/image-20220318151445436.ebf8d6dd.png)

更多的内容在这里看：https://ydlclass.com/doc21xnv/javase/tree

链式的树可以使用如下的节点类实现：

```cpp
class TreeNode<E> {

    E element;
    TreeNode<E> left;
    TreeNode<E> right;

    public TreeNode(E e) {
        element = e;
    }
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#四、图论)四、图论

![image-20220322173955465](https://www.ydlclass.com/doc21xnv/assets/image-20220322173955465.698a4da3.png)

**基本知识：**

- 图是一种比【线性表和树】更为复杂的数据结构。
- 在线性表中，数据元素之间仅有线性关系，在树形结构中，数据元素之间有着明显的层次关系，而在图形结构中，**节点之间的关系可以是任意的**，图中任意两个数据元素之间都可能相关。
- 图（Graph）是一种复杂的非线性结构，在图结构中，每个元素都可以有零个或多个前驱，也可以有零个或多个后继，也就是说，元素之间的关系是任意的。
- 图是由节点和边组成，边是节点之间的连线

**在图中需要注意的是：**

- 线性表中我们把数据元素叫元素，树中将数据元素叫结点，**在图中数据元素，我们则称之为顶点（Vertex）**。
- 线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，**在图中不允许没有顶点**（有穷非空性）。
- 线性表中的各元素是线性关系，树中的各元素是层次关系，而**图中各顶点的关系是用边来表示**（边集可以为空）。

**分类：**

- 无向图：无向图是由顶点和边构成。
- 有向图：有向图是由顶点和有向边构成。
- 完全图：如果任意两个顶点之间都存在边叫完全图，有向的边叫**有向完全图**。邻接节点

![image-20220322173602095](https://www.ydlclass.com/doc21xnv/assets/image-20220322173602095.15360849.png)

- 简单图：如果无重复的边或者顶点到自身的边叫简单图。

![image-20220322173747017](https://www.ydlclass.com/doc21xnv/assets/image-20220322173747017.6e32b8c0.png)

在面向对象的语言中我们可以对节点进行如下的抽象：

- 本节点保存的数据
- 相邻节点，这里和二叉树的抽象有些不同，二叉树中因为子节点的数量是已知的，所以可以抽象左子节点和右子节点，图我们可以使用【相邻节点】
- 因为图可能会存在【环】，在遍历的过程中可能因为环的存在，产生死循环，所以需要一个标识位，用来记录当前节点的访问状态。

```java
public class Vertex<T> {
    // 保存相应的数据
    T data;
    // 相邻节点，可以是一个也可以是多个
    List<Vertex<T>> neighborList;
    // 是否被访问，用于遍历
    boolean visited;

    public Vertex(T data){
        this.data = data;
        neighborList = new ArrayList<Vertex<T>>();
        visited = false;
    }
}
```

对于图而言，我们常用的遍历方式有bfs和dfs两种：

bfs：宽度优先搜索算法（又称广度优先搜索），英文Breadth First Search。广度优先搜索会优先访问当前顶点的所有邻接结点。

dfs：深度优先搜索算法，英文Depth First Search。深度优先搜索会优先顺延访问当前节点分支进行访问，直到不能深入，每个节点只访问一次。

![image-20220321143721092](https://www.ydlclass.com/doc21xnv/assets/image-20220321143721092.2b1bd7b2.png)

对于广度优先和深度有限遍历的思考：

1、每一个节点只能获取一个节点所有的邻接节点：

对于广度优先的策略，是优先遍历当前【顶点】的

代码实现如下：

```java
public class Graph {


    /**
     * 定义顶点的抽象
     * @param <T>
     */
    public static class Vertex<T>{
        // 要保存的数据
        private T t;
        // 其他和我管理的邻接节点
        private List<Vertex<T>> neighborList;

        private boolean visited = false;

        public Vertex(T t) {
            this.t = t;
        }
    }

    // bfs 广度优先算法
    public static <T> void bfs(Vertex<T> vertex){
        // 1、定义一个临时存储的空间，使用队列
        Queue<Vertex<T>> queue = new ArrayBlockingQueue<>(8);
        // 2、增加一个用来保存已经遍历过的数据的集合
        HashSet<Vertex<T>> mome = new HashSet<>(8);
        // 3、将第一个顶点放入队列
        queue.add(vertex);

        while (!queue.isEmpty()){
            // 将第一个元素拿出来
            Vertex<T> temp = queue.poll();
            // 进行操作
            if (!mome.contains(temp)){
                System.out.println(temp.t);
                mome.add(temp);
            }
            // 将他所有的邻接节点放进去
            if(temp.neighborList != null){
                queue.addAll(temp.neighborList);
            }
        }

    }


    // dfs 深度优先遍历
    public static <T> void dfs(Vertex<T> vertex){
        // 1、定义一个临时存储的空间
        Stack<Vertex<T>> stack = new Stack<>();
        // 2、将第一个顶点放入栈中
        stack.push(vertex);
        while (!stack.isEmpty()){
            // 3、将栈顶的元素取出
            Vertex<T> temp = stack.pop();
            // 4、执行操作
            if(!temp.visited){
                System.out.println(temp.t);
                temp.visited = true;
            }
            // 5、将邻接节点压栈
            if(temp.neighborList != null){
                stack.addAll(temp.neighborList);
            }
        }

    }


    public static void main(String[] args) {
        Vertex<Integer> vertex1 = new Vertex<>(1);
        Vertex<Integer> vertex2 = new Vertex<>(2);
        Vertex<Integer> vertex3 = new Vertex<>(3);
        Vertex<Integer> vertex4 = new Vertex<>(4);
        Vertex<Integer> vertex5 = new Vertex<>(5);
        Vertex<Integer> vertex6 = new Vertex<>(6);
        Vertex<Integer> vertex7 = new Vertex<>(7);

        vertex1.neighborList = List.of(vertex2,vertex3,vertex4);
        vertex2.neighborList = List.of(vertex3,vertex6);
        vertex3.neighborList = List.of(vertex5,vertex6);
        vertex5.neighborList = List.of(vertex6,vertex7);
        vertex6.neighborList = List.of(vertex7);

        bfs(vertex1);
        System.out.println("---------------");
        dfs(vertex1);

    }

}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#五、时间复杂度和空间复杂度)五、时间复杂度和空间复杂度

在计算机科学中，算法的【时间复杂度】是一个函数，它描述了该算法的运行时间。时间复杂度常用【大O表示法】，使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值**大小趋近无穷时**的情况。【空间复杂度】是指执行这个算法所需要的内存空间。算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度。

以下是几个常见的时间复杂度比较，我们可以直观的感受：

| n     | n^2              | nlogn（2是底） |
| ----- | ---------------- | -------------- |
| 1万   | 一亿             | 13万           |
| 100万 | 1万亿（一万倍）  | 2千万          |
| 1亿   | 1 亿亿（一亿呗） | 26亿           |

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第二章-递归)第二章 递归

学习递归之前，我们可以首先思考一下“递推”这个概念？

人的思想是更适合【递推】而不是【递归】

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、斐波那契数列)一、斐波那契数列

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_1、递推)1、递推

我们举一个小例子，给出下列的一组数据，我问大家第10个数字是多少？

```text
1，1，2，3，5，8....
```

正常人的思维肯定是，从前边的数据总结规律，然后从前向后，也就是“自低向上”寻求解决问题的思路，这个过程就是**【递推】**的过程，代码如下：

```java
// 我们传入的n是从1开始计算的，第五个
private static int fibonacci1(int n) {
    // 创建一个数组，用来存放结果
    int[] result = new int[n];
    result[0] = result[1] = 1;
    // 从第三项开始递推，知道第n-1
    for(int i = 2 ; i <= n-1 ; i++){
        result[i] = result[i-1] + result[i-2];
    }
    return result[n-1];
}
```

时间复杂度：O(n)

空间复杂度：O(n)

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_2、递归)2、递归

递归的思路恰恰是相反的，递归的思路是要明确，我们要计算第九个，只要知道第7个和第8个就可以了，以此类推，想要知道第7个就只需要知道第6个和第5个就可以了，一直进行推算直到需要知道第一个和第二个为止。

其实我们可以给这个递推过程推导出一个方程如下，我们可以把他解释为”状态转移方程“

$$ f(n)=\begin{cases} 1,n=1,2\ f(n-1)+f(n-2),n>2 \end{cases} $$ 我们甚至可以画出如下的图形：

![image-20220307164419643](https://www.ydlclass.com/doc21xnv/assets/image-20220307164419643.5958f7fc.png)

我们可以专门定义一个函数`fibonacci2(int n)`，这个函数就是用来求第n个斐波那契数列的值的函数，代码如下：

```java
private static int fibonacci2(int n) {
    if (n == 1 || n == 2)
        return 1;
    return fibonacci1(n - 1) + fibonacci1(n - 2);
}
```

```text
f(n) = f(n-1) + f(n-2) = f(n-2) + f(n-3) + f(n-3) + f(n-4)，每一项都裂变出两项，最终得出结论：O(2^n)
```

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_3、重复子问题)3、重复子问题

我们再一次看看上边的图，会发现一个问题，很多的计算都是重复的，不多说，仅仅是上图中的内容，f(7)出现了3次，f(8)出现了两次，大量的计算是很消耗资源的，那有没有什么办法防止这些重复的计算呢？

我们可以使用一个备忘录，进行存储，每次计算完成之后将结果保存在一个数组（集合）中，代码如下：

```java
// 使用一个数组memo进行保存，memo的下标代表第几个，值就是结果
private static int fibonacci2(int[] memo,int n) {
    // 如果存在就直接返回
    if (memo[n] > 0){
        return memo[n];
    }
    if (n == 0 || n == 1){
        memo[n] = 1;
    } else {
        memo[n] = fibonacci2(memo,n-1) + fibonacci2(memo,n-2);
    }
    return memo[n];
}
```

时间复杂度 O(n)，每一次计算的结果都进行保存，相当于计算n个结果。

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_4、性能)4、性能

我们比较一下三种方法的性能：

```java
public static void main(String[] args) {
    long start = System.currentTimeMillis();
    System.out.println(fibonacci1(40));
    long end = System.currentTimeMillis();
    System.out.println(end - start);

    start = System.currentTimeMillis();
    System.out.println(fibonacci2(new int[40],40));
    end = System.currentTimeMillis();
    System.out.println(end - start);

    start = System.currentTimeMillis();
    System.out.println(fibonacci3(40));
    end = System.currentTimeMillis();
    System.out.println(end - start);
}
```

![image-20220310154118651](https://www.ydlclass.com/doc21xnv/assets/image-20220310154118651.77559f49.png)

我们会发现，当有了【备忘录】之后，性能得到了大幅度的提升，这就是所谓的【空间换时间】。

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#二、抢5游戏)二、抢5游戏

两个人先从【数字1或2】中选择一个，然后，另一个人在这个基础上选择加1或者加2，正好加到5为止，如果是你怎么能保证这个游戏必赢呢？

这个问题很简单，我们把各种情况列出来，总能找到答案，因为一共就只有五个数字。

那换一个数字呢，比如20，你会发现，从递推的角度去思考很难得出答案，我先说2 然后...后面有非常多中情况 ，规则虽然很简单，但是这个思路确实不太行得通。此时递归的思路就来了，递归的思路是这个样子的：

1、我要是最后必须喊20，就必须让对手喊19或18。

2、我只要喊17，就可以让对手喊19或18，至于要倒数第二次喊17就行。

3、一次类推，只要我想喊17，上一次就必须是14，在上一次我就是11，以此类推 8 ，5，2

4、最后的结论就是只要我先喊2，然后依次5，8，11，14，17，20，我就必胜。

而这个思想就是一个递归的思想，递归的思想有两个明显的妙用，

第一是，只要解决了上一步的问题就能解决下一步的问题，一依次类推就能解决全部的问题。

第二是，推倒的过程是相同的，是可以复制的

但是，使用递归一定要注意，过程相同，单要有结束条件。

**规律：**倒着数，每次减3，最后的结果是2或1时停止：

我们可以看一个代码：

```java
public class Game {

    public static void main(String[] args) {
        List<Integer> five = getFive(20, new ArrayList<>());
        System.out.println(five);
    }

    private static List<Integer> getFive(int num,List<Integer> res){
        if (num > 0) {
            res.add(num);
            getFive(num - 3, res);
        }
        return res;
    }
}
```

结果：

![image-20220309171845842](https://www.ydlclass.com/doc21xnv/assets/image-20220309171845842.9471c30f.png)

**作业：**那我们的斐波那契数列呢？怎么用递归处理的？

想要求出第n个位置的值，只需要求出n-1和n-2的值，相加即可，公式如下：f(n)=f(n-1)+f(n-2)。

```java
public long fibonacci(long number) {
    if ((number == 0) || (number == 1))
        return number;
    else
        return fibonacci(number - 1) + fibonacci(number - 2);
}
```

再来思考，怎么通过递归实现一个阶乘，5的阶乘就是5*4！

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#三、上台阶的问题)三、上台阶的问题

一个人上台阶，每次只能上1个或2个台阶，问，有多少种情况可以上到第20个台阶？这个问题其实是，斐波那契数列有很多应用，比如上台阶问题：

前提条件是每次只能上一个或两个台阶，

1、我们要上第20个台阶不外乎就是从第十八个或者第十九个台阶上，也就意味着上第十八个台阶的方式的数量+上第19个台阶的数量之和。

说的简单一点就是，我有x种情况可以上到第18个台阶，我有y种情况可以上到第19个台阶，那么上到第20个台阶的情况就有x+y种。

公式还是：f(n)=f(n-1)+f(n-2)

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#四、汉诺塔)四、汉诺塔

传说越南河内有一个寺庙，寺庙里有三根柱子，憎侣之间传言如果按照某个规定将64个盘子全部移动另外的柱子上，世界末日也就到了。事实证明，如果僧侣每一秒移动一个，大概需要5800亿年，当然这只是一个传说，这也是汉诺塔（Hanoi就是河内的意思）。

汉诺塔问题的描述：有三个柱子A、B、C，现在有n个盘子，需要从A柱转移到C柱，需要满足一下条件：

1. 每次只能移动一个盘子
2. 任何时候**小盘子不能放在大盘子**下边
3. B柱可以用来零时存放盘子，但是依然要满足**小盘子不能放在大盘子下边**的条件

![image-20220310102738545](https://www.ydlclass.com/doc21xnv/assets/image-20220310102738545.394f0510.png)

其实，这个游戏我们小时候都玩过，如果只有三个盘子这个游戏是很简单的，但是盘子数量一旦多起来就不是很好处理了：

我们以三个盘子为例，我们不妨简单的玩一下：

第一步：

![image-20220310103137650](https://www.ydlclass.com/doc21xnv/assets/image-20220310103137650.6bc1f6d2.png)

第二步：

![image-20220310103158455](https://www.ydlclass.com/doc21xnv/assets/image-20220310103158455.4cb9db07.png)

第三步：

![image-20220310103214672](https://www.ydlclass.com/doc21xnv/assets/image-20220310103214672.11259ee5.png)

第四步：

![image-20220310103233502](https://www.ydlclass.com/doc21xnv/assets/image-20220310103233502.ef5222ec.png)

第五步：

![image-20220310103303158](https://www.ydlclass.com/doc21xnv/assets/image-20220310103303158.277fb03b.png)

第六步：

![image-20220310103333109](https://www.ydlclass.com/doc21xnv/assets/image-20220310103333109.187e15b6.png)

第七步：

![image-20220310103508618](https://www.ydlclass.com/doc21xnv/assets/image-20220310103508618.5f247be7.png)

对于三个盘子的汉诺塔来说，还是比较简答的，但是盘子的数量如果增加一杯呢？

如果从递推的角度去思考这个问题，一定要理性的分析一下这个过程中的规律，才能下结论。

但是如果思维反转，用递归来思考呢？

1、我们要实现64个盘子的汉诺塔，那么要让63个的变成一个什么样子呢？

我们要做的就是将前63个移动到B柱，将第64个从A移动到C，此时最大号的盘子就转移成功了：

![image-20220310112055537](https://www.ydlclass.com/doc21xnv/assets/image-20220310112055537.e465f306.png)

然后我们再将B柱的所有盘子移动到C柱就好了。

![image-20220311172410117](https://www.ydlclass.com/doc21xnv/assets/image-20220311172410117.e2a30d7f.png)

通过这个问题，我们巧妙的将大的问题抽象成一个统一可复制的算法，而计算机最大的优势就在于快速的做出大量的重复性问题。

```java
public class Hanoi {

    public static void main(String[] args) {
        hanoi(3,'A','B','C');
    }

    /**
     * 解决n层汉诺塔问题的方法
     * @param num 盘子的数量
     * @param from 第1根柱子
     * @param temp 第2根柱子
     * @param to 第3根柱子
     */
    public static void hanoi(int num,char from, char temp,char to){
        if(num < 1){
            System.out.println("您输入的数字不合法！");
        }
        if (num == 1){
            System.out.println("将【"+ num +"】个盘子从【"+from+"】转移到【"+to+"】");
        } else {
            //要解决n层汉诺塔的问题，可以将n个盘子分解成（n-1） 1
            // 1、先处理n-1个盘子的汉诺塔问题，从from转移到temp，
            hanoi(num-1,from,to,temp);
            // 2、挪动盘子
            System.out.println("将【"+ num +"】个盘子从【"+from+"】转移到【"+to+"】");
            // 3、再处理一次n-1个盘子的汉诺塔问题，从temp转移到to，
            hanoi(num-1,temp,from,to);
        }

    }

}
```

**注：时间复杂度的计算**

用递归来解决汉诺塔问题是非常方便的选择，最后我们来分析一下汉诺塔问题的时间复杂度。 我们很容易得到汉诺塔问题的递推公式，64层汉诺塔，需要将63层的汉诺塔在A和B之间转换两次+最大的盘子移动一次： $$ f(n)=\begin{cases} 1,n=1\ 2f(n-1)+1,n>1 \end{cases} \ $$

```text
计算过程： f(n)=2f(n-1)+1 = 2*（2f(n-2)+1） + 1 = 2*2f(n-2) + 3  = 2^（n-1） + (1 + 3 + 7 + ...) = 2^n - 1
```

舍掉常数项，所以汉诺塔问题的时间复杂度为O(2^n);

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#五、树和图的遍历)五、树和图的遍历

树的遍历，其实本质也是一种深度优先遍历：

```java
public class RecursiveBinaryTree {

    public static class Node {
        public int value;
        public Node left;
        public Node right;

        public Node(int v) {
            value = v;
        }
    }


    // 先序打印所有节点
    public static void Preorder(Node root) {
        if (root == null) {
            return;
        }
        System.out.println(root.value);
        Preorder(root.left);
        Preorder(root.right);
    }

    public static void Inorder(Node root) {
        if (root == null) {
            return;
        }
        Inorder(root.left);
        System.out.println(root.value);
        Inorder(root.right);
    }

    public static void Postorder(Node root) {
        if (root == null) {
            return;
        }
        Postorder(root.left);
        Postorder(root.right);
        System.out.println(root.value);
    }

    public static void main(String[] args) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);


        Preorder(root);
        System.out.println("====先序遍历====");
        Inorder(root);
        System.out.println("====中序遍历====");
        Postorder(root);
        System.out.println("====后续遍历====");

    }

}
```

使用递归，对图进行深度优先遍历，他的结构和之前的栈可能有些不同：

```java
// 使用递归遍历图
public static <T> void recursive(Vertex<T> vertex){
    // 拿到顶点进行遍历操作
    if(!vertex.visited){
        System.out.println(vertex.t);
        vertex.visited = true;
    }
    // 看看当前的顶点时候有邻接节点，如果有执行相同错做
    if(vertex.neighborList != null){
        for (Vertex<T> tVertex : vertex.neighborList) {
            recursive(tVertex);
        }
    }
}
```

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第三章-多指针算法)第三章 多指针算法

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、链表反转)一、链表反转

公用代码：

```java
public class ReverseLink {
    public static void main(String[] args) {
     
    }

    // 遍历的方法
    public static void print(Node<Integer> head) {
        Node<Integer> current = head;
        while (current != null) {
            System.out.println(current.t);
            current = current.next;
        }
    }

    private static class Node<T> {
        private T t;
        private Node<T> next = null;

        public Node(T t) {
            this.t = t;
        }
    }


    private static Node<Integer> buildLink() {
        Node<Integer> head = new Node<>(1);
        Node<Integer> node2 = new Node<>(2);
        Node<Integer> node3 = new Node<>(3);
        Node<Integer> node4 = new Node<>(4);
        Node<Integer> node5 = new Node<>(5);

        head.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;
        return head;
    }

}
```

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_1、迭代反转链表)1、迭代反转链表

链表翻转最大的问题就是，对于单链表而言，引用一旦指向新的节点，就会于之前关联的节点失去联系，所以我们可以使用三个引用临时保存需要操作的节点：

![image-20220328174600417](https://www.ydlclass.com/doc21xnv/assets/image-20220328174600417.d87dc1f5.png)

- 第一个和第二个引用用来进行反转操作
- 第三个引用用来保存后边的节点，防止关联失效

![image-20220328175005067](https://www.ydlclass.com/doc21xnv/assets/image-20220328175005067.7b5b3818.png)

- 以后每一步操作，只需要将三个临时节点统一向后移动即可，这就是一个遍历的过程

![image-20220329110443263](https://www.ydlclass.com/doc21xnv/assets/image-20220329110443263.8b6d7746.png)

代码如下：

```java
// 采用单个指针的方式，迭代进行逆转
public static Node<Integer> reverseLink(Node<Integer> head) {

    if (head == null || head.next == null) {
        return head;
    }

    // 定义三个引用，分别代表当前节点，以及他的前后节点
    Node<Integer> prevNode = null;
    Node<Integer> current = head;
    Node<Integer> nextNode = head.next;

    // 先进行一个翻转翻转
    current.next = prevNode;

    while (nextNode != null) {

        // 三个指针,统一移动
        prevNode = current;
        current = nextNode;
        nextNode = current.next;

        // 翻转
        current.next = prevNode;

        // 确定到达尾部，定义新的头结点
        if (nextNode == null) {
            head = current;
        }
    }
    return head;
}
```

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_2、递归反转)2、递归反转

递归翻转的思路和之前的思路恰好相反，递归往往都是这个样子

![image-20220328175436958](https://www.ydlclass.com/doc21xnv/assets/image-20220328175436958.d7f85c25.png)

我们使用递归将后续的节点成功反转：

![image-20220328175713503](https://www.ydlclass.com/doc21xnv/assets/image-20220328175713503.c3ffa242.png)

接下来只需要将A和B反转即可：

```java
// 递归遍历链表
public static Node<Integer> recursiveReverseLink(Node<Integer> head) {

    if (head == null || head.next == null) {
        return head;
    }

    // 上边的A和B的反转，node是反转后的头节点
    Node<Integer> node = recursiveReverseLink(head.next);
    head.next.next = head;
    head.next = null;

    return node;

}
```

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_3、头插法反转)3、头插法反转

头插法的思路比较简单，就是从头开始遍历，每次摘下一个节点，然后使用头插法，拼接成一个新的链表：

![image-20220328180658524](https://www.ydlclass.com/doc21xnv/assets/image-20220328180658524.8b76efd8.png)

```java
// 使用头插法
public static Node<Integer> headInsertReverseLink(Node<Integer> head) {

    if (head == null || head.next == null) {
        return head;
    }

    // newHead表示的是新建的链表的头结点
    Node<Integer> newHead = null, temp;

    while (head != null) {
        // 临时节点指向head
        temp = head;
        // head后移，相当于将头结点摘除了
        head = head.next;
        temp.next = newHead;
        newHead = temp;
    }

    return newHead;
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#二、双指针-快慢指针)二、双指针-快慢指针

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_1、寻找单向无环链表的中点)1、寻找单向无环链表的中点

![image-20220328213356511](https://www.ydlclass.com/doc21xnv/assets/image-20220328213356511.679835b1.png)

```java
public static Node findMiddle(Node head){
    Node fast = head,slow = head;
    while (fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_2、判断单向链表是否有环及找环入口)2、判断单向链表是否有环及找环入口

**题目：**给定一个单向的链表，判断该链表是否有换，如果不存在换返回null，如果存在，则返回链表开始入环的第一个节点。

说明：不允许修改给定的链表。如下图：应该返回C这个节点。

![image-20220329152835340](https://www.ydlclass.com/doc21xnv/assets/image-20220329152835340.2b208d8c.png)

**判断有没有环思路：**我们同样使用快慢指针，fast 与slow，一旦fast追上slow就说明存在环。

寻找换的入口，是一个比较麻烦的事情，我们有基本的数学推导如下，这里有个一直条件，fast一旦追上slow说明fast比slow正好快了一圈：

如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 $$ a+(b+c)+b=a+2b+c $$ ![image-20220329155838691](https://www.ydlclass.com/doc21xnv/assets/image-20220329155838691.52bbf5c4.png)

根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有

$$ a+2b+c=2(a+b)⟹a=c $$ 有了这个等量关系，我们会发现：在我们的题目中，从相遇点到入环点的距离，恰好等于从链表头部到入环点的距离。

因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和slow 每次向后移动一个位置。最终，它们会在入环点相遇。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#三、双指针-左右指针)三、双指针-左右指针

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_1、两数之和)1、两数之和

输入一个【有序数组】和一个目标值，找到数组中的两个数相加等于目标值，输出两个数字的下标：

![image-20220328214852970](https://www.ydlclass.com/doc21xnv/assets/image-20220328214852970.c8bb6af1.png)

```java
public int[] twoSum(int[] nums,int target){
    int left = 0,right = nums.length -1;
    while (left < right){
        int sum = nums[left] + nums[right];
        if(sum == target){
            return new int[]{left+1,right+1};
        } else if(sum < target){
            left++;
        } else if (sum > target){
            right--;
        }
    }
    return new int[]{-1,-1};
}
```

#### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#_2、二分查找)2、二分查找

给定一个有序数组，和一个目标值，找出目标值出现的位置，返回下标，找不到则返回-1：

![image-20220329203351412](https://www.ydlclass.com/doc21xnv/assets/image-20220329203351412.2f344fde.png)

```java
public static int binarySearch(int[] nums,int target){
    int left = 0,right = nums.length -1;
    while (left <= right){
        int middle = (left + right)/2;
        if(nums[middle] == target){
            return middle;
        } else if(nums[middle] < target){
            left = middle+1;
        } else if (nums[middle] > target){
            right = middle -1;
        }
    }
    return -1;
}
```

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第四章-动态规划)第四章 动态规划

动态规划（Dynamic Programming）相关问题的一般形式是求最值，比如最长递增子序列等，动态规划的核心问题是【穷举】。因为在求最值的过程中，我们需要求出一系列可行的值，再从可行值之中选择出目标答案。

动态规划的【穷举】中，会产生很多很多重复计算，所以，我们可能需要一个“备忘录”保存重复计算的结果，同时，我们需要一个DP table来优化穷举的过程，记录子问题的结果，这块内容我们在递归篇章的斐波那契数列中见到过。

动态规划的三要素如下：

1、重叠子问题，子问题的就算方式大致相同。

2、复合最优子结构，问题的最优解包含子问题的最优解。反过来说就是,我们可以通过子问题的最优解,推导出问题的最优解。

3、状态转移方程，怎么从子问题最优解推倒当前问题的最优解。

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、最长递增子序列)一、最长递增子序列

**题目**：给定一个无序的序列，求解它的【最长递增子序列】的长度。方法签名如下：`int lengthOfLIS(int[] nums)`

**注意**：【子序列】和【子串】是不一样的，【子序列】是可以不连续的，但是子串必须是连续的。

**举例**： nums[] = {3,·1,4,1,5,9,2,6,5} 的最长递增子序列长度为4，结果返回4即可，此时的为子序列：1,4,5,9。

在使用【动态规划】方案解决该问题的时候，我们需要首先思考的是，怎么去设计一个dp数组，用来存放各个子问题的结果：

在这道题中，我们想：

1. 【宏观问题】是这个数组中存在的【最长子序列】
2. 将其拆分成【子问题】就是，枚举出【从零到每一个位置】的最长递增序列，这也是我们所需要定义的一个dp数组。
3. dp数组保存了所有的计算结果，最后在dp数组中找最值就可以了。

![image-20220316164811772](https://www.ydlclass.com/doc21xnv/assets/image-20220316164811772.f3e05ea0.png)

因此，我们需要抽离一个共有的方法，就是【查找子序列】

```java
/**
 * @author itnanls(微信)
 * 我们的服务： 一路陪跑，顺利就业
 */
public class LengthOfLIS {

    public static void main(String[] args) {
        int i = lengthOfLIS(new int[]{1, 4, 2, 4, 6, 7, 8,4,23});
        System.out.println(i);
    }


    public static int lengthOfLIS(int[] nums){
        if(nums.length <= 0){
            return 0;
        }
        int[] dp = new int[nums.length];

        // 对给定数组进行逐一遍历，确定每个位置上的最长递增子序列
        for (int i = 0; i < nums.length; i++) {
            // 先给dp数据当前位置初始化，因为最短的长度就是1
            dp[i] = 1;
            // 确定当前的长度时，需要对前边已经计算的结果进行扫描
            for (int j = 0; j < i; j++){
                // 如果遇到比前边某一个位置的数字大，说明在之前的位置上，递增序列会被延长
                if(nums[i] > nums[j]){
                    // 同时比较当前位置和最大子序列的长度，目的是取最大值
                    if(dp[i] < dp[j] +1){
                        dp[i] = dp[j] + 1;
                    }
                }
            }

        }
        Arrays.sort(dp);
        return dp[dp.length-1];
    }
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#二、找零钱)二、找零钱

**题目**：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

```text
// coins 中是可选硬币面值，amount 是目标金额
int coinChange(int[] coins, int amount);
```

比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

你认为计算机应该如何解决这个问题？显然，就是把所有肯能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。

首先，这个问题是【动态规划问题】，因为它具有【最优子结构】的。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？

回到凑零钱问题，为什么说它符合最优子结构呢？

还是上边的题目，我们想知道总金额11需要最少几枚硬币，只需知道总结额为 10，9，6（总额减去一枚硬币面额的值）这几种情况下所需要的硬币的数量，然后找一个小的加1即可，这个过程是可以进行递归处理的，如下图：

![image-20220307180314908](https://www.ydlclass.com/doc21xnv/assets/image-20220307180314908.4d761bf3.png)

- **重叠子问题**，当总额为0，1......amount时，分别最多需要多少枚硬币，因为当amount=0，时结果必为0。
- 他符合最优子结构，子问题amount的最大值就是我们要的结果。
- 状态转移方程如下：

$$ f(n)=\begin{cases} 0,n=0\ -1,n<0 \min(f(n-coin))+1,n>0 \end{cases} $$

```java
    /**
     * 计算出能组成总金额的最少硬币数量
     * @param coins    给定的硬币的面额
     * @param amount   给定的总金额
     * @return         最少的硬币数量
     */
    public static int coinChange(int[] coins, int amount){
        if(amount == 0) return 0;
        if(amount < 0) return -1;

        // 核心：
        // 1、求总金额为16的结果 【1，3，5】
        // 2、【1】找到15的最优解+1   ---- 【3】找到13的最优解+1  ----- 【5】找到11的最优解+1
        // 3、取最小值
        int result = Integer.MAX_VALUE;
        for (int i = 0; i < coins.length; i++) {
            int subMin = coinChange(coins, amount - coins[i]);
            // 如果最优解不存在 -1 继续
            if (subMin == -1) continue;
            if(subMin + 1 < result){
                result = subMin +1;
            }
        }
        return result == Integer.MAX_VALUE ? -1 : result;

    }
```

在此过程中，我们确实会出现很多的重复子问题计算，我们需要使用一个memo备忘录进行记录。

```java
private static int changeCoin2(int[] coins,int amount,int[] memo){
    if (amount == 0) return 0;
    if (amount < 0) return -1;
    int res = Integer.MAX_VALUE;

    for (int i = 0; i < coins.length; i++) {
        // 遍历子问题，假设amount为10元，如果有了一个2元，剩下的8元最少需要几个呢？，子问题就是8元所需要的个数
        // 同理8元所需要的个数可以使用递归完成
        int subProblem = Integer.MAX_VALUE;
        if(amount-coins[i] >= 0 && memo[amount-coins[i]] != 0){
            subProblem = memo[amount-coins[i]];
        } else {
            subProblem = changeCoin2(coins,amount-coins[i],memo);
        }

        // 子问题有误解的时候，比如子问题的金额小于硬币的最小金额
        if(subProblem == -1) continue;
        // 我们的最优结果就是，最优的子问题的最优解+1
        res = Math.min(res,1 + subProblem) != Integer.MAX_VALUE ? Math.min(res,1 + subProblem):-1;
    }
    memo[amount] = res;
    return res;
}
```

最后看看，有【备忘录】和没有【备忘录】的性能差异：

```java
public class Change {
	...
    public static void main(String[] args) {

        long start = System.currentTimeMillis();
        System.out.println(changeCoin2(new int[]{1,2,3},100,new int[100+1]));
        long end = System.currentTimeMillis();
        System.out.println(end - start);

        start = System.currentTimeMillis();
        System.out.println(changeCoin(new int[]{1,2,3},100));
        end = System.currentTimeMillis();
        System.out.println(end -start);
    }
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#三、0-1背包问题)三、0-1背包问题

![image-20220315152616525](https://www.ydlclass.com/doc21xnv/assets/image-20220315152616525.4ced1188.png)

**题目**：有一个**容量为 V** 的背包，和一些物品。这些物品分别有两个属性，**体积 w 和价值 v**，每种物品**只有一个**。要求用这个背包装下**价值尽可能多**的物品，求该最大价值，背包**可以不被装满**。

0-1背包问题：在最优解中，每个物品只有两种可能的情况，即**在背包中或者不在背包**中（背包中的**该物品数为0或1**），因此称为0-1背包问题。

**子问题：**子问题必然是和物品有关的，对于每一个物品，有两种结果：能装下或者不能装下。

第一，包的容量比物品体积小，装不下，这时的最大价值和前i-1个物品的最大价值是一样的。

第二，还有足够的容量装下该物品，但是**装了不一定最大价值**，所以要进行比较。由上述分析，子问题中**物品数和背包容量**都应当作为变量。

因此，子问题确定为背包容量为j时，求前i个物品所能达到最大价值。

确定状态：由上述分析，“状态”对应的“值”即为背包容量为j时，求前i个物品所能达到最大价值，设为dp[i][j]。初始时，dp[0][0]为0，没有物品也就没有价值。

**确定状态转移方程：**由上述分析，第i个物品的体积为w,价值为v，则状态转移方程为 $$ f(n,v)=\begin{cases} f(n-1,v), weight[i] > j（装不下）\ Math.max(f(i - 1,j - weight[i]) + value[i], f(i - 1,j)) ,weight[i] <= j（可以装下） \end{cases} $$

我们很多时候，会看到为了解决这个问题会列出一个表格

| 价值  | 重量 | 0    | 1    | 2     | 3    | 4    | 5    | 6            | 7    | 8    | 9    | 10   |
| ----- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ------------ | ---- | ---- | ---- | ---- |
| 3     | 2    | 0    | 0    | 3     | 3    | 3    | 3    | 3            | 3    | 3    | 3    | 3    |
| 4     | 3    | 0    | 0    | **3** | 4    | 4    | 7    | 7            | 7    | 7    | 7    | 7    |
| **5** | 4    | 0    | 0    | 3     | 3    | 5    | 7    | **（3+5）8** |      |      |      |      |
| 8     | 5    | 0    |      |       |      |      |      |              |      |      |      |      |
| 10    | 9    | 0    |      |       |      |      |      |              |      |      |      |      |

**示例代码：**

```java
public class ZeroOnePackage {

    public static void main(String[] args) {
        int num = 5;   //物品有五件
        int capacity = 10;  //背包容量为20
        int[] weight = {2, 3, 4, 5, 9};   //重量 2 3 4 5 9
        int[] value = {3, 4, 5, 8, 10};   //价值 3 4 5 8 10
        int maxValue = zeroOnePackage(weight, value, num, capacity);
        System.out.println(maxValue);
    }
    
    public static int zeroOnePackage(int[] weight,int[] value,int num,int capacity) {
        // dp[i][j]意思是：背包容量为j时，在前i件物品中取小于等于i件物品，此时取得的物品的价值最大
        // capacity为3时需要判断 0，1，2，3的最优解，所以二位数组的容量是capacity +1
        int[][] dp = new int[num][capacity +1];
        // 循环遍历，所有的物品
        for (int i = 1; i < num; i++) {
            // 尝试获取
            for (int j = 1; j <= capacity; j++) {
                // 如果重量比当前测试的包的容量的还大，必然装不下去
                if (weight[i] > j) {
                    // 当前的最优解就是之前的最优解
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // 如果能放进去，先要腾出相应的空间，加上当前的重量的价值
                    // 然后对比上一个最优解，取最大的
                    // 拿：dp[i-1][j-weight[i]]+value[i]   不拿： dp[i-1][j]
                    dp[i][j] = Math.max(dp[i - 1][j - weight[i]] + value[i], dp[i - 1][j]);
                }
            }
        }
        return dp[num-1][capacity];
    }
}
```

完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

多重背包（bounded knapsack problem）与前面不同就是每种物品是有限个：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第五章-回溯)第五章 回溯

回溯算法要做的事情很基础，就是**穷举**，可以说就是**暴力穷举**。解决回溯问题，实际上就是对一个决策树的遍历过程。回溯，我们可以这么理解，比如我们走迷宫，沿着一条路，走到底发现是思路，就要回到原来的出发点，再次选择一条新的路劲，其实这就是回溯。

在回溯的过程中，我们需要注意几点：

1、路劲

2、选择的列表

3、结束条件

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、全排列问题)一、全排列问题

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

示例 1：

输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

示例 2：

输入：nums = [0,1] 输出：[[0,1],[1,0]]

示例 3：

输入：nums = [1] 输出：[[1]]

方法签名如下：`List<List<Integer>> permute(int[] nums)`

![image-20220324193556927](https://www.ydlclass.com/doc21xnv/assets/image-20220324193556927.2dbf1337.png)

```java
class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        List<List<Integer>> permute = solution.permute(new int[]{2, 4, 5, 6});
        System.out.println(permute);
    }
    
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

        // 定义数组的长度
        int n = nums.length;
        // 定义一个栈用来存放数据，使用队列，集合也行
        Deque<Integer> deque = new ArrayDeque<>();
        // 用来保存一个数字有没有使用过
        boolean[] used = new boolean[n];

        backtrack(n, nums, res, 0,deque,used);

        return res;
    }

    public void backtrack(int n, int[] nums, List<List<Integer>> res, int first, Deque<Integer> deque,boolean[] used) {
        // 所有数都填完了
        if (first == n) {
            res.add(new ArrayList<>(deque));
            return;
        }
        for (int i = 0; i < n; i++) {
            // 已经使用过的就不管了
            if(used[i]){
                continue;
            }
            // 给栈中添加元素
            deque.addLast(nums[i]);
            used[i] = true;
            // 继续递归填下一个数
            backtrack(n, nums, res, first + 1,deque,used);
            // 撤销状态
            deque.removeLast();
            used[i] = false;
        }
    }
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#二、n皇后问题)二、N皇后问题

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

![image-20220309152054755](https://www.ydlclass.com/doc21xnv/assets/image-20220309152054755.6892ef7d.png)

```java
/**
 * @author itnanls(微信)
 * 我们的服务： 一路陪跑，顺利就业
 */
public class Find8Queen {

    public static void main(String[] args) {
        Find8Queen find8Queen = new Find8Queen();
        find8Queen.solveNQueens(4);
    }

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();
        check(0, new int[n], res);
        System.out.println(res);
        return res;
    }

    /**
     * 该方法用来检测当前列放置的queen，是否能满足条件
     *
     * @param current 当前列
     * @param queens  保存满足条件的一种情况的数组
     * @param res     结果
     */
    private void check(int current, int[] queens, List<List<String>> res) {
        // 已经试探到了最后一列了
        if (current == queens.length) {
            // 生成改种情况的棋牌，每个棋盘都是一个List<String> [.Q.., ...Q, Q..., ..Q.]
            List<String> board = generateBoard(queens);
            // 将棋盘加入结果集当中
            res.add(board);
            return;
        }
        for (int i = 0; i < queens.length; i++) {
            // 一个一个的放皇后去尝试，
            queens[current] = i;
            // 检查这个皇后是否满足条件，行、列、斜线都没有
            // 如果满足条件，就结束了，否则回溯
            if (judge(current, queens)) {
                check(current + 1, queens, res);
            }
        }
    }

    /**
     * @param n       当前列
     * @param queens 当前情况的  [1,3,0.2]  
     * @return       是否满足条件
     */
    private boolean judge(int n, int[] queens) {

        // n代表要检验的列 i代表每一列
        for (int i = 0; i < n; i++) {
            // 同一行: 不需要判断
            // 同一列：queens[i] == queens[n]，过一遍看看有没有
            // 统一斜线： Math.abs(n-i) == Math.abs(queens[n] - queens[i])
            if (queens[i] == queens[n] || Math.abs(n - i) == Math.abs(queens[n] - queens[i])) {
                return false;
            }
        }
        return true;
    }

    // 根据结果生成棋盘 [1,3] 第一行第一个，第二行第三个
    public List<String> generateBoard(int[] queens) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < queens.length; i++) {
            char[] row = new char[queens.length];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';

            board.add(new String(row));
        }
        return board;
    }
}
```

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第五章-滑动窗口-silding-window)第五章 滑动窗口 silding window

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、最小覆盖子串)一、最小覆盖子串

给你两个字符串S和T，请在S中找到包含T中全部字母的最短子串。如果S中没有这样一个子串，则返回空，如果存在这样一个子串，则可以认为**答案是唯一**的

**比如：**输入 “ABCDEFGHIG” T="CGI" 应该返回 “CDEFGHI”

这个题目是可以进行暴力破解的，但是时间复杂度太高，我们需要使用一些更加优雅的解决方案：

![image-20220330172123097](https://www.ydlclass.com/doc21xnv/assets/image-20220330172123097.196d0317.png)

【滑动窗口】的思路是这个样子的：

1、我们可以使用双指针中的左右指针技巧，初始化 left = right = 0，把索引【左闭右开）称之为一个窗口

2、我们可以不断的增加right指针扩大窗口[left,right）,直至窗口中的字符串满足要求

3、此时我们在不断的缩小left，同时，每次增加left，都要更新一轮结果。

4、重复以上步骤，直至left到达S的尽头，

> 暴力破解

```java
public class SildingWindow {

    public static String minWindow(String s, String t) {
        // 排除一些特殊情况
        if(s == null || t == null || "".equals(s) || "".equals(t) || t.length() > s.length()){
            return "";
        }
        if (s.equals(t)) return s;

        // 将字符串转化成字符数组方便操作
        char[] charS = s.toCharArray();
        char[] charT = t.toCharArray();

        // 定义两个指针，空来控制范围 [left,right)
        int left = 0,right = 1;

        // 定义保存结果的变量
        int offset = 0,minLen = Integer.MAX_VALUE;

        // 核心的迭代逻辑
        while (left < charS.length){
            while (right < charS.length + 1){
                // 检查left和right之间的字符是否满足条件
                if(check(charS,left,right,charT)){
                    if(minLen > right - left){
                        minLen = right - left;
                        offset = left;
                    }
                }
                right++;
            }
            left++;
            right = left+1;
        }

        return new String(charS,offset,minLen == Integer.MAX_VALUE ? 0: minLen );
    }

    private static boolean check(char[] charS, int left, int right, char[] charT) {
        // 特殊情况
        if(right - left < charT.length){
            return false;
        }

        // 转化charT中的每个字符出现的次数一定小于等于charS中对应字符的次数
        int[] numsS = new int[128];
        int[] numsT = new int[128];

        for (int i = left; i < right; i++) {
            numsS[charS[i]]++;
            if(i-left < charT.length){
                numsT[charT[i-left]]++;
            }
        }

        for (int i = 0; i < numsT.length; i++) {
            if(numsS[i] < numsT[i]){
                return false;
            }
        }

        return true;

    }

    public static void main(String[] args) {
        System.out.println(minWindow("a","a"));
    }
}
```

滑动窗口：

```java
public class SildingWindow2 {

    public static String minWindow(String s, String t) {
        // 排除一些特殊情况
        if(s == null || t == null || "".equals(s) || "".equals(t) || t.length() > s.length()){
            return "";
        }
        if (s.equals(t)) return s;

        // 将字符串转化成字符数组方便操作
        char[] charS = s.toCharArray();
        char[] charT = t.toCharArray();

        // 定义两个指针，空来控制范围 [left,right)
        int left = 0,right = 1;

        // 定义保存结果的变量
        int offset = 0,minLen = Integer.MAX_VALUE;

        //
        // 转化charT中的每个字符出现的次数一定小于等于charS中对应字符的次数
        int[] numsS = new int[128];
        int[] numsT = new int[128];

        char currentWord = 128;
        boolean flag = false;

        for (int i = 0; i < charT.length; i++) {
            numsT[charT[i]]++;
        }

        // 核心的迭代逻辑
        while (left < charS.length && right <= charS.length) {
            while (right < charS.length + 1) {
                numsS[charS[right - 1]]++;
                if(flag && charS[right-1] != currentWord){
                    right++;
                    continue;
                }

                // 检查left和right之间的字符是否满足条件
                // 如果满足条件，1、记录最优解，2、右指针暂定
                if (right-left >= charT.length && check(numsS, numsT)) {
                    // 右指针如果满足条件，左指针开始走
                    while (left < right) {
                        if (check(numsS, numsT)) {
                            if (minLen > right - left) {
                                minLen = right - left;
                                offset = left;
                            }
                            numsS[charS[left]]--;
                            currentWord = charS[left];
                            left++;
                        } else {
                            flag = true;
                            break;
                        }
                    }
                    numsS[charS[right - 1]]--;
                    break;
                }
                right++;
            }
        }

        return new String(charS,offset,minLen == Integer.MAX_VALUE ? 0: minLen );
    }

    private static boolean check(int[] numsS, int[] numsT) {

        for (int i = 0; i < numsT.length; i++) {
            if(numsS[i] < numsT[i]){
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(minWindow("DSACDFESDECDS","ECDF"));
    }
}
```

- 时间复杂度：最坏情况下左右指针对 ss 的每个元素各遍历一遍，哈希表中对 ss 中的每个元素各插入、删除一次，对 tt 中的元素各插入一次。每次检查是否可行会遍历整个 tt 的哈希表，哈希表的大小与字符集的大小有关，设字符集大小为 CC，则渐进时间复杂度为 O(C\cdot |s| + |t|)O(C⋅∣s∣+∣t∣)。
- 空间复杂度：这里用了两张哈希表作为辅助空间，每张哈希表最多不会存放超过字符集大小的键值对，我们设字符集大小为 CC ，则渐进空间复杂度为 O(C)O(C)。

## [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#第六章-分治思想)第六章 分治思想

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#一、归并排序)一、归并排序

归并排序是一种稳定的排序方法，它也是一种十分高效的排序，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。

归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。

![image-20220331151224061](https://www.ydlclass.com/doc21xnv/assets/image-20220331151224061.fb4417e3.png)

代码实现如下：

```java
public class MergeSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void sort(int []arr){
        //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
        int []temp = new int[arr.length];
        sort(arr,0,arr.length-1,temp);
    }


    // 核心的递归方法
    private static void sort(int[] arr,int left,int right,int []temp){
        if(left < right){
            int mid = (left+right)/2;
            //左边归并排序，使得左子序列有序
            sort(arr,left,mid,temp);
            //右边归并排序，使得右子序列有序
            sort(arr,mid+1,right,temp);
            //将两个有序子数组合并操作
            merge(arr,left,mid,right,temp);
        }
    }
    private static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i = left; //左序列指针
        int j = mid+1; //右序列指针
        int t = 0;//临时数组指针
        while (i<=mid && j<=right){
            if(arr[i]<=arr[j]){
                temp[t++] = arr[i++];
            }else {
                temp[t++] = arr[j++];
            }
        }
        //将左边剩余元素填充进temp中
        while(i<=mid){
            temp[t++] = arr[i++];
        }
        //将右序列剩余元素填充进temp中
        while(j<=right){
            temp[t++] = arr[j++];
        }
        t = 0;
        //将temp中的元素全部拷贝到原数组中
        while(left <= right){
            arr[left++] = temp[t++];
        }
    }
}
```

### [#](https://www.ydlclass.com/doc21xnv/algorithm/base/#二、快速排序)二、快速排序

快速排序同样使用分治法来把一个串（list）分为两个子串（sub-lists），然后分别进行排序。具体算法描述如下：

- 从数组中挑出一个元素，称为 “基准”（**pivot**）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![image-20220331152503893](https://www.ydlclass.com/doc21xnv/assets/image-20220331152503893.bb11423e.png)

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = { 49, 38, 65, 97, 23, 22, 76, 1, 5, 8, 2, 0, -1, 22 };
        quickSort(arr, 0, arr.length - 1);
        System.out.println("排序后:");
        for (int i : arr) {
            System.out.println(i);
        }
    }

    private static void quickSort(int[] arr, int low, int high) {

        if (low >= high) {
        	return;
        }
        // 找寻排序后的基准数据所处的正确索引
        int index = getIndex(arr, low, high);

        // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序
        // quickSort(arr, 0, index - 1); 之前的版本，这种姿势有很大的性能问题，谢谢大家的建议
        quickSort(arr, low, index - 1);
        quickSort(arr, index + 1, high);     
    }

    private static int getIndex(int[] arr, int low, int high) {
        // 基准数据
        int pivot = arr[low];
        while (low < high) {
            // 当队尾的元素大于等于基准数据时,向前挪动high指针
            while (low < high && arr[high] >= pivot) {
                high--;
            }
            // 如果队尾元素小于pivot了,需要将其赋值给low
            arr[low] = arr[high];
            // 当队首元素小于等于tmp时,向前挪动low指针
            while (low < high && arr[low] <= pivot) {
                low++;
            }
            // 当队首元素大于pivot时,需要将其赋值给high
            arr[high] = arr[low];

        }
        // 跳出循环时low和high相等,此时的low或high就是pivot的正确索引位置
        // 由原理部分可以很清楚的知道low位置的值并不是pivot,所以需要将pivot赋值给arr[low]
        arr[low] = pivot;
        return low; // 返回tmp的正确位置
    }
}
```