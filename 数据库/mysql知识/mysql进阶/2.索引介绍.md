## 一、什么是索引

MySQL官方对索引的定义为：索引是帮助MySQL高效获取数据的数据结构。可以得知，**索引是数据结构**。

可以简单理解**索引是排好序的快速查找数据结构**，因为MySQL索引底层是**B+Tree**，特性便是有序数组链表+平衡二叉树。

一般来说，因为数据量大的元素，索引本身也很大，因为保存了排好序的数据（类似字典目录），所以索引不可能全部存储在内存中，因此往往**以文件的形式存储在磁盘上**。

MySQL除了B树索引外还有hash索引，**其中的优劣**我们后面在说，以及**为什么索引要使用B+树**？

## 二、索引的优劣势

> #### 索引的优势

- 创建唯一索引可以保证数据库每行数据唯一性

- 查询数据速度快，效率高，降低数据库IO成本
- 索引对数据进行排序，降低了order by成本，降低CPU消耗

> #### 索引的劣势

- 索引需要占用物理空间，当数据过大，所需占用的空间也更大
- 创建和维护索引需要大量时间，随着数据增多时间也变得更多
- 索引查询速度快，但是更新速度慢，当数据增删改时，不仅mysql要保存数据，也需要动态维护索引

## 三、MySQL索引数据结构

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

mysql索引有多种数据结构可以使用，如：B+Tree，Hash，R-Tree等等，这里我们介绍主要的两种即B+Tree和Hash索引。

### 3.1 B+Tree索引

一种平衡树的数据结构，其一个节点可以拥有多于2个子节点的二叉树，B树优化大量数据下的IO读写操作，减少定位记录经过的中间过程，使用在索引上大大加快查找速度，以O(logN)时间查询。

并且可以是有序的树结构，对于需要排序的查询速度更快。MyISAM和InnoDB两种引擎都使用B+Tree，但又是不同的B+Tree，我们后面在说。

### 3.2 Hash索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

相比于`B-Tree`索引，哈希索引的实现就比较简单了，它是基于哈希表来实现的，对于要索引的列，存储引擎会计算出一一对应的`哈希码`，然后把哈希码存放在哈希表中作为`key`，`value`值是指向该行数据的指针。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

关于索引数据结构的知识我们会新开一个笔记详细介绍。

## 四、MySQL索引分类

> #### 普通索引和唯一索引

- **普通索引：** 数据库中的基本索引类型，允许在定义索引的列中插入重复值和空值
- **唯一索引：**索引列的值必须唯一，但允许有空值，主键索引是一种特殊的唯一索引，不允许有空值（比如自增ID）

> #### 单列索引和组合索引

- **单列索引：** 即一个索引只包含单个列，一个表可以有多个单列索引
- **组合索引：** 指在表的多个字段组合上创建的索引，**只有在查询条件中使用了这些字段的左边字段时，索引才会被使用**

> #### 全文索引

- **全文索引：** 类型为`FULLTEXT`，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建，**MySQL中只有MyISAM存储引擎支持全文索引**

## 五、索引使用场景

> #### 哪些情况需要创建索引

- 主键自动创建唯一索引
- 频繁查询操作需要创建索引
- 对排序需求大的字段创建索引
- 查询中统计或分组的字段需要创建
- 关联表具有外键关系的需要创建索引（因为A表每个字段都要去B表遍历数据）

> #### 哪些情况不要创建索引

- 经常性会进行增删改操作的表
- 表记录很少
- where条件里用不到的字段

综上，**我们应该对经常查询和排序的数据建立索引**。

## 六、索引基本语法

### 创建

创建索引有三种方式：

1. 创建表时创建索引

```sql
CREATE TABLE mytable(  
	ID INT NOT NULL,   
	username VARCHAR(16) NOT NULL,  
	INDEX [indexName] (username(length))  -- 创建索引
);  
```

1. 修改表结构创建索引

```sql
ALTER table tableName ADD INDEX indexName(columnName); -- 普通索引
ALTER table mytable ADD UNIQUE [indexName] (username(length)); -- 唯一索引
```

1. 直接创建索引

```sql
CREATE INDEX indexName ON mytable(username(length));-- 普通索引
CREATE UNIQUE INDEX indexName ON mytable(username(length));-- 唯一索引
```

### 删除

可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。

```sql
DROP INDEX index_name ON talbe_name
ALTER TABLE table_name DROP INDEX index_name
ALTER TABLE table_name DROP PRIMARY KEY
```

其中，前两条语句是等价的，删除掉`table_name`中的索引`index_name`。
第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。
如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。

### 查看
```sql
show index from tblname;
show keys from tblname;
```

## 七、索引的最左匹配原则

当使用联合索引时，索引只能查找key是否**相等（=）**，而不能用于范围查找（>，<，between，like），如果遇到便**停止匹配**，后续退化为线性查找。

因此，**列的排列顺序绝定了可命中索引数**。

例如：

- 有索引`（a,b,c,d）`，查询条件为`wehre a=1 and b=1 and c>1 and d=1`，则会命中a，b，c的索引，而d未命中，因为在c的时候是范围查找，d就无法命中了
- `select * from user where age >30;` 如果在age列创建索引，那你说会走索引吗？会的