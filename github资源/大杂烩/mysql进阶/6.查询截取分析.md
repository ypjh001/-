## 数据库调优分析

1. 慢查询的开启并捕获
2. explain+慢sql分析
3. show profile 查询sql在mysql服务器中的执行细节与生命周期
4. SQL数据库服务器的参数调优



## 一、查询优化

### 1.1 小表驱动大表

什么叫小表驱动大表？为什么要这样做？

我们来看两个循环

```java
for(int i = 0;i < 9000;i++){
	for(int j = 0;j < 50;j++){

	}
}
for(int i = 0;i < 50;i++){
	for(int j = 0;j < 9000;j++){

	}
}
```

由于数据库表之间查询需要建立连接，我们看第一个循环，会发现i这个表循环了9000次，这样与j就肯定需要9000次连接，而第二个循环只需要50次连接，由此可见的第二个循环更好，即小表驱动大表。

**当使用in或exists时**，就有说法了

![1552270860731](../image/1552270860731.png)

**使用in的时候最好是右表表小于左表的数据**，会优化时间减少。**使用exists时便是左表数据小于右边**。

### 1.2 排序OrderBy优化

当使用mysql的关键字OrderBy进行排序时，具有文件排序和索引排序两种，显而易见的，索引排序更加高效。

导致文件排序是因为排序字段没有创建索引或错误使用索引，如下图：

![1552290529970](../image/1552290529970.png)

**所以，使用排序时，也一定记住最左匹配原则！**

当使用文件排序Using filesort时，mysql底层有两种排序方式：

- 双路排序：进行两次io操作，是mysql4.1之前使用的排序方式
- 单路排序：只进行一次io操作，将数据存放在内存中进行排序读取，这种排序也有问题，就是当缓冲区不够大时，便会进行更多的io磁盘操作，便需要**修改mysql服务器配置**才可以优化。

单路排序优化策略：

- 增大sort_buffer_size参数
- 增大max_length_for_sort_data参数

**GROUPBY关键字和ORDERBY类似**



## 二、慢查询日志

慢查询日志可以记录执行时间大于10秒（默认）的sql，你可以查看这个日志来获取需要优化的慢查询sql。

当然这个大于多少秒是可以设置的，`long_query_time`这个字段来配置，**找到慢sql后可以配合explain进行优化**。

**这个功能默认是关闭的**，如果不是调优需要，不要开启这个功能，因为**会对性能造成影响**。

当然，在生产环境中，如果手工分析日志查找，分析sql非常耗体力，mysql提供一个日志分析工具来帮助我们优化，**mysqldumpslow**



## 三、Show Profile

show profile是mysql提供可以**分析某个会话中语句执行消耗情况**，用于sql调优。

他相较于explain更加的细致专业，在前面说到的**mysql运行过程每一步几乎都会体现出来**，例如优化器优化，打开连接等等。

![1552444924085](../image/1552444924085.png)

### 分析步骤：

1. 是否支持，查看mysql版本是否支持——`show variables like profiling`
2. 是否开启，默认是关闭的——`set profiling 1`
3. 运行sql
4. 查看慢sql集合——`show profiles`
5. 诊断某个慢sql——`show profile cpu,block io for query ?`（这里的？输入第四部查看的某个sql的id）